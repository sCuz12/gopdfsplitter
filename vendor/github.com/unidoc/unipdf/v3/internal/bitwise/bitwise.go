//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_b "encoding/binary";_a "errors";_ea "fmt";_d "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_eb "io";);func (_ccb *BufferedWriter )grow (_ca int ){if _ccb ._c ==nil &&_ca < _ed {_ccb ._c =make ([]byte ,_ca ,_ed );
return ;};_db :=len (_ccb ._c );if _ccb ._da !=0{_db ++;};_af :=cap (_ccb ._c );switch {case _ca <=_af /2-_db :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ccb ._c ),cap (_ccb ._c ),_ca );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_af ,_db );copy (_ccb ._c ,_ccb ._c [_ccb .fullOffset ():]);
case _af > _aa -_af -_ca :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_geb :=make ([]byte ,2*_af +_ca );copy (_geb ,_ccb ._c );_ccb ._c =_geb ;};_ccb ._c =_ccb ._c [:_db +_ca ];
};var _ _eb .Writer =&BufferedWriter {};var _ BinaryWriter =&Writer {};func (_fdg *Reader )BitPosition ()int {return int (_fdg ._gc )};func (_ada *Reader )Length ()uint64 {return uint64 (_ada ._gddcf ._bb )};func (_cec *Reader )RelativePosition ()int64 {return _cec ._bg };
type BinaryWriter interface{BitWriter ;_eb .Writer ;_eb .ByteWriter ;Data ()[]byte ;};type readerSource struct{_efc []byte ;_cb int ;_bb int ;};func (_fca *Reader )Align ()(_gdc byte ){_gdc =_fca ._gc ;_fca ._gc =0;return _gdc };func (_bda *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_bda ._dfg =-1;
_bda ._gc =0;_bda ._fee =0;_bda ._ccbf =0;var _gce int64 ;switch whence {case _eb .SeekStart :_gce =offset ;case _eb .SeekCurrent :_gce =_bda ._bg +offset ;case _eb .SeekEnd :_gce =int64 (_bda ._gddcf ._bb )+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _gce < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_bda ._bg =_gce ;
_bda ._gc =0;return _gce ,nil ;};func (_cg *BufferedWriter )writeFullBytes (_acf []byte )int {_fg :=copy (_cg ._c [_cg .fullOffset ():],_acf );_cg ._ab +=_fg ;return _fg ;};func (_gage *Writer )Write (p []byte )(int ,error ){if len (p )> _gage .byteCapacity (){return 0,_eb .EOF ;
};for _ ,_bec :=range p {if _fbf :=_gage .writeByte (_bec );_fbf !=nil {return 0,_fbf ;};};return len (p ),nil ;};func (_ff *Writer )writeBit (_fcb uint8 )error {if len (_ff ._bac )-1< _ff ._eeb {return _eb .EOF ;};_gba :=_ff ._gag ;if _ff ._abc {_gba =7-_ff ._gag ;
};_ff ._bac [_ff ._eeb ]|=byte (uint16 (_fcb <<_gba )&0xff);_ff ._gag ++;if _ff ._gag ==8{_ff ._eeb ++;_ff ._gag =0;};return nil ;};func (_bef *BufferedWriter )tryGrowByReslice (_fbc int )bool {if _bff :=len (_bef ._c );_fbc <=cap (_bef ._c )-_bff {_bef ._c =_bef ._c [:_bff +_fbc ];
return true ;};return false ;};func (_gcc *Reader )readBool ()(_bbe bool ,_dbc error ){if _gcc ._gc ==0{_gcc ._fee ,_dbc =_gcc .readBufferByte ();if _dbc !=nil {return false ,_dbc ;};_bbe =(_gcc ._fee &0x80)!=0;_gcc ._fee ,_gcc ._gc =_gcc ._fee &0x7f,7;
return _bbe ,nil ;};_gcc ._gc --;_bbe =(_gcc ._fee &(1<<_gcc ._gc ))!=0;_gcc ._fee &=1<<_gcc ._gc -1;return _bbe ,nil ;};func (_de *BufferedWriter )WriteByte (bt byte )error {if _de ._ab > len (_de ._c )-1||(_de ._ab ==len (_de ._c )-1&&_de ._da !=0){_de .expandIfNeeded (1);
};_de .writeByte (bt );return nil ;};func (_gad *Reader )ReadByte ()(byte ,error ){if _gad ._gc ==0{return _gad .readBufferByte ();};return _gad .readUnalignedByte ();};func (_edg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _edg ._gc !=0{return _edg .ReadBits (_edg ._gc );
};return 0,nil ;};func (_ceg *BufferedWriter )writeByte (_fcg byte ){switch {case _ceg ._da ==0:_ceg ._c [_ceg ._ab ]=_fcg ;_ceg ._ab ++;case _ceg ._ec :_ceg ._c [_ceg ._ab ]|=_fcg >>_ceg ._da ;_ceg ._ab ++;_ceg ._c [_ceg ._ab ]=byte (uint16 (_fcg )<<(8-_ceg ._da )&0xff);
default:_ceg ._c [_ceg ._ab ]|=byte (uint16 (_fcg )<<_ceg ._da &0xff);_ceg ._ab ++;_ceg ._c [_ceg ._ab ]=_fcg >>(8-_ceg ._da );};};func (_ba *BufferedWriter )Data ()[]byte {return _ba ._c };func (_gfg *Writer )SkipBits (skip int )error {const _fbac ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_afg :=int (_gfg ._gag )+skip ;if _afg >=0&&_afg < 8{_gfg ._gag =uint8 (_afg );return nil ;};_afg =int (_gfg ._gag )+_gfg ._eeb *8+skip ;if _afg < 0{return _g .Errorf (_fbac ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gcea :=_afg /8;_gagd :=_afg %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gfg ._gag ,_gfg ._eeb ,int (_gfg ._gag )+(_gfg ._eeb )*8,len (_gfg ._bac ),cap (_gfg ._bac ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_afg ,_gagd );_gfg ._gag =uint8 (_gagd );if _dee :=_gcea -_gfg ._eeb ;
_dee > 0&&len (_gfg ._bac )-1< _gcea {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dee );return _g .Errorf (_fbac ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gfg ._eeb =_gcea ;
_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gfg ._gag ,_gfg ._eeb );return nil ;};func (_adgf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _adgf .writeBit (uint8 (bit ));
};return _g .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_eca *BufferedWriter )writeShiftedBytes (_gb []byte )int {for _ ,_gbf :=range _gb {_eca .writeByte (_gbf );
};return len (_gb );};func (_gddc *BufferedWriter )expandIfNeeded (_fd int ){if !_gddc .tryGrowByReslice (_fd ){_gddc .grow (_fd );};};func (_be *BufferedWriter )Reset (){_be ._c =_be ._c [:0];_be ._ab =0;_be ._da =0};func (_ee *Reader )Reset (){_ee ._bg =_ee ._cf ;
_ee ._gc =_ee ._fba ;_ee ._fee =_ee ._bad ;_ee ._ccbf =_ee ._dde ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bac :data ,_abc :true }};func (_dac *BufferedWriter )Write (d []byte )(int ,error ){_dac .expandIfNeeded (len (d ));if _dac ._da ==0{return _dac .writeFullBytes (d ),nil ;
};return _dac .writeShiftedBytes (d ),nil ;};func (_cbe *Writer )UseMSB ()bool {return _cbe ._abc };func (_cc *BufferedWriter )FinishByte (){if _cc ._da ==0{return ;};_cc ._da =0;_cc ._ab ++;};func (_abe *BufferedWriter )byteCapacity ()int {_ace :=len (_abe ._c )-_abe ._ab ;
if _abe ._da !=0{_ace --;};return _ace ;};func (_ede *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _g .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ede ._c )-1< _ede ._ab {_ede .expandIfNeeded (1);};_dea :=_ede ._da ;if _ede ._ec {_dea =7-_ede ._da ;};_ede ._c [_ede ._ab ]|=byte (uint16 (bit <<_dea )&0xff);_ede ._da ++;if _ede ._da ==8{_ede ._ab ++;_ede ._da =0;};return nil ;};func (_dda *Writer )WriteBits (bits uint64 ,number int )(_fbad int ,_fda error ){const _dab ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_g .Errorf (_dab ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cd :=number /8;if _cd > 0{_egfa :=number -_cd *8;for _gga :=_cd -1;_gga >=0;_gga --{_cgd :=byte ((bits >>uint (_gga *8+_egfa ))&0xff);if _fda =_dda .WriteByte (_cgd );_fda !=nil {return _fbad ,_g .Wrapf (_fda ,_dab ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cd -_gga +1);
};};number -=_cd *8;if number ==0{return _cd ,nil ;};};var _baa int ;for _gbg :=0;_gbg < number ;_gbg ++{if _dda ._abc {_baa =int ((bits >>uint (number -1-_gbg ))&0x1);}else {_baa =int (bits &0x1);bits >>=1;};if _fda =_dda .WriteBit (_baa );_fda !=nil {return _fbad ,_g .Wrapf (_fda ,_dab ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gbg );
};};return _cd ,nil ;};type BitWriter interface{WriteBit (_cgc int )error ;WriteBits (_bae uint64 ,_baed int )(_acef int ,_fe error );FinishByte ();SkipBits (_ggc int )error ;};func (_egb *Reader )ReadBit ()(_ged int ,_faddg error ){_dfc ,_faddg :=_egb .readBool ();
if _faddg !=nil {return 0,_faddg ;};if _dfc {_ged =1;};return _ged ,nil ;};func (_fadc *Writer )FinishByte (){if _fadc ._gag ==0{return ;};_fadc ._gag =0;_fadc ._eeb ++;};func (_ge *BufferedWriter )WriteBits (bits uint64 ,number int )(_bf int ,_ac error ){const _gg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_g .Errorf (_gg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_df :=number /8;if _df > 0{_fb :=number -_df *8;for _fc :=_df -1;_fc >=0;_fc --{_egf :=byte ((bits >>uint (_fc *8+_fb ))&0xff);if _ac =_ge .WriteByte (_egf );_ac !=nil {return _bf ,_g .Wrapf (_ac ,_gg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_df -_fc +1);
};};number -=_df *8;if number ==0{return _df ,nil ;};};var _bfd int ;for _bd :=0;_bd < number ;_bd ++{if _ge ._ec {_bfd =int ((bits >>uint (number -1-_bd ))&0x1);}else {_bfd =int (bits &0x1);bits >>=1;};if _ac =_ge .WriteBit (_bfd );_ac !=nil {return _bf ,_g .Wrapf (_ac ,_gg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bd );
};};return _df ,nil ;};func (_gef *Writer )ResetBit (){_gef ._gag =0};type Reader struct{_gddcf readerSource ;_fee byte ;_gc byte ;_bg int64 ;_ccbf int ;_dfg int ;_cf int64 ;_fba byte ;_bad byte ;_dde int ;};type StreamReader interface{_eb .Reader ;_eb .ByteReader ;
_eb .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ef byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_ded *Writer )WriteByte (c byte )error {return _ded .writeByte (c )};
type Writer struct{_bac []byte ;_gag uint8 ;_eeb int ;_abc bool ;};func (_bc *Reader )readUnalignedByte ()(_gfa byte ,_gdb error ){_adae :=_bc ._gc ;_gfa =_bc ._fee <<(8-_adae );_bc ._fee ,_gdb =_bc .readBufferByte ();if _gdb !=nil {return 0,_gdb ;};_gfa |=_bc ._fee >>_adae ;
_bc ._fee &=1<<_adae -1;return _gfa ,nil ;};func (_feef *Reader )ReadUint32 ()(uint32 ,error ){_aff :=make ([]byte ,4);_ ,_gf :=_feef .Read (_aff );if _gf !=nil {return 0,_gf ;};return _b .BigEndian .Uint32 (_aff ),nil ;};type BufferedWriter struct{_c []byte ;
_da uint8 ;_ab int ;_ec bool ;};var _ BinaryWriter =&BufferedWriter {};var (_ _eb .Reader =&Reader {};_ _eb .ByteReader =&Reader {};_ _eb .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_edc *Reader )read (_adad []byte )(int ,error ){if _edc ._bg >=int64 (_edc ._gddcf ._bb ){return 0,_eb .EOF ;
};_edc ._dfg =-1;_bgbf :=copy (_adad ,_edc ._gddcf ._efc [(int64 (_edc ._gddcf ._cb )+_edc ._bg ):(_edc ._gddcf ._cb +_edc ._gddcf ._bb )]);_edc ._bg +=int64 (_bgbf );return _bgbf ,nil ;};func (_ae *Reader )readBufferByte ()(byte ,error ){if _ae ._bg >=int64 (_ae ._gddcf ._bb ){return 0,_eb .EOF ;
};_ae ._dfg =-1;_adg :=_ae ._gddcf ._efc [int64 (_ae ._gddcf ._cb )+_ae ._bg ];_ae ._bg ++;_ae ._ccbf =int (_adg );return _adg ,nil ;};func (_efb *Reader )AbsoluteLength ()uint64 {return uint64 (len (_efb ._gddcf ._efc ))};func NewReader (data []byte )*Reader {return &Reader {_gddcf :readerSource {_efc :data ,_bb :len (data ),_cb :0}};
};func (_cac *Reader )ReadBits (n byte )(_gae uint64 ,_bfdc error ){if n < _cac ._gc {_acefc :=_cac ._gc -n ;_gae =uint64 (_cac ._fee >>_acefc );_cac ._fee &=1<<_acefc -1;_cac ._gc =_acefc ;return _gae ,nil ;};if n > _cac ._gc {if _cac ._gc > 0{_gae =uint64 (_cac ._fee );
n -=_cac ._gc ;};for n >=8{_dbe ,_fbg :=_cac .readBufferByte ();if _fbg !=nil {return 0,_fbg ;};_gae =_gae <<8+uint64 (_dbe );n -=8;};if n > 0{if _cac ._fee ,_bfdc =_cac .readBufferByte ();_bfdc !=nil {return 0,_bfdc ;};_cea :=8-n ;_gae =_gae <<n +uint64 (_cac ._fee >>_cea );
_cac ._fee &=1<<_cea -1;_cac ._gc =_cea ;}else {_cac ._gc =0;};return _gae ,nil ;};_cac ._gc =0;return uint64 (_cac ._fee ),nil ;};const (_ed =64;_aa =int (^uint (0)>>1););func NewWriter (data []byte )*Writer {return &Writer {_bac :data }};func (_dg *BufferedWriter )fullOffset ()int {_dd :=_dg ._ab ;
if _dg ._da !=0{_dd ++;};return _dd ;};func (_cab *Writer )byteCapacity ()int {_edeb :=len (_cab ._bac )-_cab ._eeb ;if _cab ._gag !=0{_edeb --;};return _edeb ;};func (_ccc *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_a .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_ccc ._gddcf ._cb +offset ;};if length > 0{_efa :=len (_ccc ._gddcf ._efc );if relative {_efa =_ccc ._gddcf ._bb ;};if offset +length > _efa {return nil ,_ea .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_ccc ._gddcf ._bb );
};};if length < 0{_fadd :=len (_ccc ._gddcf ._efc );if relative {_fadd =_ccc ._gddcf ._bb ;};length =_fadd -offset ;};return &Reader {_gddcf :readerSource {_efc :_ccc ._gddcf ._efc ,_bb :length ,_cb :offset }},nil ;};var _ _eb .ByteWriter =&BufferedWriter {};
func (_fgc *Reader )AbsolutePosition ()int64 {return _fgc ._bg +int64 (_fgc ._gddcf ._cb )};func (_bab *Reader )Mark (){_bab ._cf =_bab ._bg ;_bab ._fba =_bab ._gc ;_bab ._bad =_bab ._fee ;_bab ._dde =_bab ._ccbf ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ec :true }};
func (_f *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_eaf :=int (_f ._da )+skip ;if _eaf >=0&&_eaf < 8{_f ._da =uint8 (_eaf );return nil ;};_eaf =int (_f ._da )+_f ._ab *8+skip ;if _eaf < 0{return _g .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fa :=_eaf /8;_gdd :=_eaf %8;_f ._da =uint8 (_gdd );if _ad :=_fa -_f ._ab ;_ad > 0&&len (_f ._c )-1< _fa {if _f ._da !=0{_ad ++;};_f .expandIfNeeded (_ad );};_f ._ab =_fa ;return nil ;};func (_ddg *Writer )Data ()[]byte {return _ddg ._bac };func (_gd *BufferedWriter )ResetBitIndex (){_gd ._da =0};
func (_dgc *Reader )Read (p []byte )(_egg int ,_cfc error ){if _dgc ._gc ==0{return _dgc .read (p );};for ;_egg < len (p );_egg ++{if p [_egg ],_cfc =_dgc .readUnalignedByte ();_cfc !=nil {return 0,_cfc ;};};return _egg ,nil ;};func (_abef *Reader )ReadBool ()(bool ,error ){return _abef .readBool ()};
func (_edb *Writer )writeByte (_afe byte )error {if _edb ._eeb > len (_edb ._bac )-1{return _eb .EOF ;};if _edb ._eeb ==len (_edb ._bac )-1&&_edb ._gag !=0{return _eb .EOF ;};if _edb ._gag ==0{_edb ._bac [_edb ._eeb ]=_afe ;_edb ._eeb ++;return nil ;};
if _edb ._abc {_edb ._bac [_edb ._eeb ]|=_afe >>_edb ._gag ;_edb ._eeb ++;_edb ._bac [_edb ._eeb ]=byte (uint16 (_afe )<<(8-_edb ._gag )&0xff);}else {_edb ._bac [_edb ._eeb ]|=byte (uint16 (_afe )<<_edb ._gag &0xff);_edb ._eeb ++;_edb ._bac [_edb ._eeb ]=_afe >>(8-_edb ._gag );
};return nil ;};func (_ce *BufferedWriter )Len ()int {return _ce .byteCapacity ()};