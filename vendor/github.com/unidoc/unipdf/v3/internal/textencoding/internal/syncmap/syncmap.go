//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";func (_bfb *RuneStringMap )Range (f func (_de rune ,_ec string )(_abc bool )){_bfb ._gd .RLock ();defer _bfb ._gd .RUnlock ();for _gfaf ,_gfc :=range _bfb ._gg {if f (_gfaf ,_gfc ){break ;};};};func (_b *ByteRuneMap )Read (b byte )(rune ,bool ){_b ._ea .RLock ();
defer _b ._ea .RUnlock ();_c ,_d :=_b ._a [b ];return _c ,_d ;};type RuneStringMap struct{_gg map[rune ]string ;_gd _f .RWMutex ;};func (_dg *RuneUint16Map )Range (f func (_bbe rune ,_acbd uint16 )(_bec bool )){_dg ._ecb .RLock ();defer _dg ._ecb .RUnlock ();
for _ge ,_cef :=range _dg ._bee {if f (_ge ,_cef ){break ;};};};func (_cda *StringRuneMap )Read (g string )(rune ,bool ){_cda ._fb .RLock ();defer _cda ._fb .RUnlock ();_bda ,_gdf :=_cda ._ee [g ];return _bda ,_gdf ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_bee :make (map[rune ]uint16 ,length )};
};func (_be *RuneByteMap )Length ()int {_be ._fg .RLock ();defer _be ._fg .RUnlock ();return len (_be ._bg )};type StringsMap struct{_bgc map[string ]string ;_bfd _f .RWMutex ;};func (_ac *RuneByteMap )Range (f func (_fc rune ,_dbg byte )(_bb bool )){_ac ._fg .RLock ();
defer _ac ._fg .RUnlock ();for _dce ,_bf :=range _ac ._bg {if f (_dce ,_bf ){break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ef :=map[string ]string {};for _ ,_dba :=range tuples {_ef [_dba .Key ]=_dba .Value ;};return &StringsMap {_bgc :_ef };
};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gfa :make (map[rune ]struct{},length )}};func (_ca *RuneByteMap )Read (r rune )(byte ,bool ){_ca ._fg .RLock ();defer _ca ._fg .RUnlock ();_bc ,_egc :=_ca ._bg [r ];return _bc ,_egc ;};func (_eda *RuneStringMap )Length ()int {_eda ._gd .RLock ();
defer _eda ._gd .RUnlock ();return len (_eda ._gg );};func (_ace *RuneSet )Length ()int {_ace ._acb .RLock ();defer _ace ._acb .RUnlock ();return len (_ace ._gfa );};func (_gb *RuneSet )Range (f func (_cf rune )(_gbc bool )){_gb ._acb .RLock ();defer _gb ._acb .RUnlock ();
for _aa :=range _gb ._gfa {if f (_aa ){break ;};};};func (_af *StringRuneMap )Range (f func (_ecg string ,_dcad rune )(_gfcb bool )){_af ._fb .RLock ();defer _af ._fb .RUnlock ();for _bcg ,_fe :=range _af ._ee {if f (_bcg ,_fe ){break ;};};};func (_ba *StringsMap )Range (f func (_gc ,_fgg string )(_bae bool )){_ba ._bfd .RLock ();
defer _ba ._bfd .RUnlock ();for _aca ,_gbf :=range _ba ._bgc {if f (_aca ,_gbf ){break ;};};};func (_agf *StringsMap )Copy ()*StringsMap {_agf ._bfd .RLock ();defer _agf ._bfd .RUnlock ();_agb :=map[string ]string {};for _gdd ,_dea :=range _agf ._bgc {_agb [_gdd ]=_dea ;
};return &StringsMap {_bgc :_agb };};func (_egcf *RuneStringMap )Write (r rune ,s string ){_egcf ._gd .Lock ();defer _egcf ._gd .Unlock ();_egcf ._gg [r ]=s ;};func (_ecf *RuneUint16Map )Delete (r rune ){_ecf ._ecb .Lock ();defer _ecf ._ecb .Unlock ();
delete (_ecf ._bee ,r );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_a :m }};type StringsTuple struct{Key ,Value string ;};func (_eab *StringsMap )Write (g1 ,g2 string ){_eab ._bfd .Lock ();defer _eab ._bfd .Unlock ();_eab ._bgc [g1 ]=g2 ;
};func (_g *ByteRuneMap )Range (f func (_ae byte ,_ag rune )(_dd bool )){_g ._ea .RLock ();defer _g ._ea .RUnlock ();for _dc ,_bd :=range _g ._a {if f (_dc ,_bd ){break ;};};};type StringRuneMap struct{_ee map[string ]rune ;_fb _f .RWMutex ;};func (_fa *ByteRuneMap )Length ()int {_fa ._ea .RLock ();
defer _fa ._ea .RUnlock ();return len (_fa ._a )};func (_cee *RuneStringMap )Read (r rune )(string ,bool ){_cee ._gd .RLock ();defer _cee ._gd .RUnlock ();_dca ,_fgd :=_cee ._gg [r ];return _dca ,_fgd ;};func (_dbb *StringRuneMap )Write (g string ,r rune ){_dbb ._fb .Lock ();
defer _dbb ._fb .Unlock ();_dbb ._ee [g ]=r ;};func MakeRuneByteMap (length int )*RuneByteMap {_db :=make (map[rune ]byte ,length );return &RuneByteMap {_bg :_db };};func (_agd *RuneSet )Write (r rune ){_agd ._acb .Lock ();defer _agd ._acb .Unlock ();_agd ._gfa [r ]=struct{}{};
};type RuneSet struct{_gfa map[rune ]struct{};_acb _f .RWMutex ;};func (_cd *RuneUint16Map )RangeDelete (f func (_cab rune ,_cg uint16 )(_gbe bool ,_cge bool )){_cd ._ecb .Lock ();defer _cd ._ecb .Unlock ();for _ggd ,_ecc :=range _cd ._bee {_dee ,_ff :=f (_ggd ,_ecc );
if _dee {delete (_cd ._bee ,_ggd );};if _ff {break ;};};};func (_dbd *StringsMap )Read (g string )(string ,bool ){_dbd ._bfd .RLock ();defer _dbd ._bfd .RUnlock ();_geb ,_ggc :=_dbd ._bgc [g ];return _geb ,_ggc ;};func (_gf *RuneByteMap )Write (r rune ,b byte ){_gf ._fg .Lock ();
defer _gf ._fg .Unlock ();_gf ._bg [r ]=b };func (_cc *RuneUint16Map )Length ()int {_cc ._ecb .RLock ();defer _cc ._ecb .RUnlock ();return len (_cc ._bee );};type RuneByteMap struct{_bg map[rune ]byte ;_fg _f .RWMutex ;};func (_ed *RuneSet )Exists (r rune )bool {_ed ._acb .RLock ();
defer _ed ._acb .RUnlock ();_ ,_ab :=_ed ._gfa [r ];return _ab ;};type ByteRuneMap struct{_a map[byte ]rune ;_ea _f .RWMutex ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_a :make (map[byte ]rune ,length )}};type RuneUint16Map struct{_bee map[rune ]uint16 ;
_ecb _f .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ee :m }};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_gg :m }};func (_df *RuneUint16Map )Write (r rune ,g uint16 ){_df ._ecb .Lock ();
defer _df ._ecb .Unlock ();_df ._bee [r ]=g ;};func (_cb *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cb ._ecb .RLock ();defer _cb ._ecb .RUnlock ();_eb ,_bfe :=_cb ._bee [r ];return _eb ,_bfe ;};func (_eg *ByteRuneMap )Write (b byte ,r rune ){_eg ._ea .Lock ();
defer _eg ._ea .Unlock ();_eg ._a [b ]=r };func (_faa *StringRuneMap )Length ()int {_faa ._fb .RLock ();defer _faa ._fb .RUnlock ();return len (_faa ._ee );};