//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_ec "fmt";_b "github.com/unidoc/unipdf/v3/common";_ad "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_d "io";_a "strings";);func (_fd *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_ba int ;
_fce =_be [stats .cx ()][0];_gg =int32 (stats .cx ()););defer func (){_fd ._g ++}();_fd ._c -=_fce ;if (_fd ._fc >>16)< uint64 (_fce ){_ba =_fd .lpsExchange (stats ,_gg ,_fce );if _da :=_fd .renormalize ();_da !=nil {return 0,_da ;};}else {_fd ._fc -=uint64 (_fce )<<16;
if (_fd ._c &0x8000)==0{_ba =_fd .mpsExchange (stats ,_gg );if _bc :=_fd .renormalize ();_bc !=nil {return 0,_bc ;};}else {_ba =int (stats .getMps ());};};return _ba ,nil ;};func (_ggc *DecoderStats )Reset (){for _aag :=0;_aag < len (_ggc ._ddf );_aag ++{_ggc ._ddf [_aag ]=0;
_ggc ._bd [_aag ]=0;};};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_bef *_ad .Reader ;_aa uint8 ;_fc uint64 ;_c uint32 ;_af int64 ;_dc int32 ;_g int32 ;_fg int64 ;};func (_afe *DecoderStats )cx ()byte {return _afe ._ddf [_afe ._dff ]};
func (_ebg *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ebg ._af =1;var _dca uint64 ;for _dca =0;_dca < codeLen ;_dca ++{stats .SetIndex (int32 (_ebg ._af ));_gd ,_bcf :=_ebg .DecodeBit (stats );if _bcf !=nil {return 0,_bcf ;
};_ebg ._af =(_ebg ._af <<1)|int64 (_gd );};_fgd :=_ebg ._af -(1<<codeLen );return _fgd ,nil ;};func New (r *_ad .Reader )(*Decoder ,error ){_de :=&Decoder {_bef :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _gc :=_de .init ();
_gc !=nil {return nil ,_gc ;};return _de ,nil ;};func (_cc *Decoder )init ()error {_cc ._fg =_cc ._bef .AbsolutePosition ();_db ,_ggd :=_cc ._bef .ReadByte ();if _ggd !=nil {_b .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ggd );
return _ggd ;};_cc ._aa =_db ;_cc ._fc =uint64 (_db )<<16;if _ggd =_cc .readByte ();_ggd !=nil {return _ggd ;};_cc ._fc <<=7;_cc ._dc -=7;_cc ._c =0x8000;_cc ._g ++;return nil ;};func (_bbf *DecoderStats )getMps ()byte {return _bbf ._bd [_bbf ._dff ]};
func (_bac *Decoder )decodeIntBit (_ff *DecoderStats )(int ,error ){_ff .SetIndex (int32 (_bac ._af ));_bcc ,_fdc :=_bac .DecodeBit (_ff );if _fdc !=nil {_b .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_fdc );
return _bcc ,_fdc ;};if _bac ._af < 256{_bac ._af =((_bac ._af <<uint64 (1))|int64 (_bcc ))&0x1ff;}else {_bac ._af =(((_bac ._af <<uint64 (1)|int64 (_bcc ))&511)|256)&0x1ff;};return _bcc ,nil ;};func (_bcb *DecoderStats )toggleMps (){_bcb ._bd [_bcb ._dff ]^=1};
func (_adc *Decoder )lpsExchange (_ee *DecoderStats ,_cf int32 ,_ea uint32 )int {_ebb :=_ee .getMps ();if _adc ._c < _ea {_ee .setEntry (int (_be [_cf ][1]));_adc ._c =_ea ;return int (_ebb );};if _be [_cf ][3]==1{_ee .toggleMps ();};_ee .setEntry (int (_be [_cf ][2]));
_adc ._c =_ea ;return int (1-_ebb );};func (_bad *DecoderStats )Overwrite (dNew *DecoderStats ){for _ef :=0;_ef < len (_bad ._ddf );_ef ++{_bad ._ddf [_ef ]=dNew ._ddf [_ef ];_bad ._bd [_ef ]=dNew ._bd [_ef ];};};func (_aga *DecoderStats )setEntry (_ac int ){_ca :=byte (_ac &0x7f);
_aga ._ddf [_aga ._dff ]=_ca };func (_bag *Decoder )readByte ()error {if _bag ._bef .AbsolutePosition ()> _bag ._fg {if _ ,_gb :=_bag ._bef .Seek (-1,_d .SeekCurrent );_gb !=nil {return _gb ;};};_ab ,_baa :=_bag ._bef .ReadByte ();if _baa !=nil {return _baa ;
};_bag ._aa =_ab ;if _bag ._aa ==0xFF{_cb ,_bcd :=_bag ._bef .ReadByte ();if _bcd !=nil {return _bcd ;};if _cb > 0x8F{_bag ._fc +=0xFF00;_bag ._dc =8;if _ ,_dfc :=_bag ._bef .Seek (-2,_d .SeekCurrent );_dfc !=nil {return _dfc ;};}else {_bag ._fc +=uint64 (_cb )<<9;
_bag ._dc =7;};}else {_ab ,_baa =_bag ._bef .ReadByte ();if _baa !=nil {return _baa ;};_bag ._aa =_ab ;_bag ._fc +=uint64 (_bag ._aa )<<8;_bag ._dc =8;};_bag ._fc &=0xFFFFFFFFFF;return nil ;};func (_eb *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_daf ,_fde int32 ;
_cd ,_ggb ,_ag int ;_dd error ;);if stats ==nil {stats =NewStats (512,1);};_eb ._af =1;_ggb ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};_cd ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _cd ==1{_cd ,_dd =_eb .decodeIntBit (stats );
if _dd !=nil {return 0,_dd ;};if _cd ==1{_cd ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _cd ==1{_cd ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _cd ==1{_cd ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;
};if _cd ==1{_ag =32;_fde =4436;}else {_ag =12;_fde =340;};}else {_ag =8;_fde =84;};}else {_ag =6;_fde =20;};}else {_ag =4;_fde =4;};}else {_ag =2;_fde =0;};for _df :=0;_df < _ag ;_df ++{_cd ,_dd =_eb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;
};_daf =(_daf <<1)|int32 (_cd );};_daf +=_fde ;if _ggb ==0{return _daf ,nil ;}else if _ggb ==1&&_daf > 0{return -_daf ,nil ;};return 0,_f .ErrOOB ;};func (_fa *Decoder )mpsExchange (_ffd *DecoderStats ,_gdf int32 )int {_aae :=_ffd ._bd [_ffd ._dff ];if _fa ._c < _be [_gdf ][0]{if _be [_gdf ][3]==1{_ffd .toggleMps ();
};_ffd .setEntry (int (_be [_gdf ][2]));return int (1-_aae );};_ffd .setEntry (int (_be [_gdf ][1]));return int (_aae );};func (_ge *Decoder )renormalize ()error {for {if _ge ._dc ==0{if _gec :=_ge .readByte ();_gec !=nil {return _gec ;};};_ge ._c <<=1;
_ge ._fc <<=1;_ge ._dc --;if (_ge ._c &0x8000)!=0{break ;};};_ge ._fc &=0xffffffff;return nil ;};func (_bb *DecoderStats )String ()string {_dcd :=&_a .Builder {};_dcd .WriteString (_ec .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_bb ._ddf )));
for _ffa ,_ebf :=range _bb ._ddf {if _ebf !=0{_dcd .WriteString (_ec .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_ffa ,_ebf ));};};return _dcd .String ();};func (_gdg *DecoderStats )SetIndex (index int32 ){_gdg ._dff =index };
type DecoderStats struct{_dff int32 ;_fed int32 ;_ddf []byte ;_bd []byte ;};func (_bacg *DecoderStats )Copy ()*DecoderStats {_ggdb :=&DecoderStats {_fed :_bacg ._fed ,_ddf :make ([]byte ,_bacg ._fed )};copy (_ggdb ._ddf ,_bacg ._ddf );return _ggdb ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_dff :index ,_fed :contextSize ,_ddf :make ([]byte ,contextSize ),_bd :make ([]byte ,contextSize )};
};var (_be =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);