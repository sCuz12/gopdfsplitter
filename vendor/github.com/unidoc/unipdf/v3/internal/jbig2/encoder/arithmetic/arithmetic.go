//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_ad "bytes";_ac "github.com/unidoc/unipdf/v3/common";_da "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_ecf *Encoder )emit (){if _ecf ._bb ==_ced {_ecf ._eag =append (_ecf ._eag ,_ecf ._fa );
_ecf ._fa =make ([]byte ,_ced );_ecf ._bb =0;};_ecf ._fa [_ecf ._bb ]=_ecf ._bcb ;_ecf ._bb ++;};func (_dd *codingContext )mps (_acf uint32 )int {return int (_dd ._ag [_acf ])};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;
IARDX ;IARDY ;IARI ;);type codingContext struct{_fc []byte ;_ag []byte ;};func (_eg *Encoder )Refine (iTemp ,iTarget *_da .Bitmap ,ox ,oy int )error {for _fad :=0;_fad < iTarget .Height ;_fad ++{var _bf int ;_bgb :=_fad +oy ;var (_bgf ,_cfg ,_ggb ,_fdb ,_fada uint16 ;
_cgc ,_dde ,_cdc ,_dfa ,_gc byte ;);if _bgb >=1&&(_bgb -1)< iTemp .Height {_cgc =iTemp .Data [(_bgb -1)*iTemp .RowStride ];};if _bgb >=0&&_bgb < iTemp .Height {_dde =iTemp .Data [_bgb *iTemp .RowStride ];};if _bgb >=-1&&_bgb +1< iTemp .Height {_cdc =iTemp .Data [(_bgb +1)*iTemp .RowStride ];
};if _fad >=1{_dfa =iTarget .Data [(_fad -1)*iTarget .RowStride ];};_gc =iTarget .Data [_fad *iTarget .RowStride ];_bff :=uint (6+ox );_bgf =uint16 (_cgc >>_bff );_cfg =uint16 (_dde >>_bff );_ggb =uint16 (_cdc >>_bff );_fdb =uint16 (_dfa >>6);_ae :=uint (2-ox );
_cgc <<=_ae ;_dde <<=_ae ;_cdc <<=_ae ;_dfa <<=2;for _bf =0;_bf < iTarget .Width ;_bf ++{_gcb :=(_bgf <<10)|(_cfg <<7)|(_ggb <<4)|(_fdb <<1)|_fada ;_gbe :=_gc >>7;_fb :=_eg .encodeBit (_eg ._df ,uint32 (_gcb ),_gbe );if _fb !=nil {return _fb ;};_bgf <<=1;
_cfg <<=1;_ggb <<=1;_fdb <<=1;_bgf |=uint16 (_cgc >>7);_cfg |=uint16 (_dde >>7);_ggb |=uint16 (_cdc >>7);_fdb |=uint16 (_dfa >>7);_fada =uint16 (_gbe );_efe :=_bf %8;_bga :=_bf /8+1;if _efe ==5+ox {_cgc ,_dde ,_cdc =0,0,0;if _bga < iTemp .RowStride &&_bgb >=1&&(_bgb -1)< iTemp .Height {_cgc =iTemp .Data [(_bgb -1)*iTemp .RowStride +_bga ];
};if _bga < iTemp .RowStride &&_bgb >=0&&_bgb < iTemp .Height {_dde =iTemp .Data [_bgb *iTemp .RowStride +_bga ];};if _bga < iTemp .RowStride &&_bgb >=-1&&(_bgb +1)< iTemp .Height {_cdc =iTemp .Data [(_bgb +1)*iTemp .RowStride +_bga ];};}else {_cgc <<=1;
_dde <<=1;_cdc <<=1;};if _efe ==5&&_fad >=1{_dfa =0;if _bga < iTarget .RowStride {_dfa =iTarget .Data [(_fad -1)*iTarget .RowStride +_bga ];};}else {_dfa <<=1;};if _efe ==7{_gc =0;if _bga < iTarget .RowStride {_gc =iTarget .Data [_fad *iTarget .RowStride +_bga ];
};}else {_gc <<=1;};_bgf &=7;_cfg &=7;_ggb &=7;_fdb &=7;};};return nil ;};func (_cga *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gdc error ){_ac .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gdc =_cga .encodeIAID (symbolCodeLength ,value );_gdc !=nil {return _e .Wrap (_gdc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_bdd *Encoder )byteOut (){if _bdd ._bcb ==0xff{_bdd .rBlock ();return ;};if _bdd ._cc < 0x8000000{_bdd .lBlock ();
return ;};_bdd ._bcb ++;if _bdd ._bcb !=0xff{_bdd .lBlock ();return ;};_bdd ._cc &=0x7ffffff;_bdd .rBlock ();};func (_bae *Encoder )EncodeInteger (proc Class ,value int )(_dbf error ){_ac .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _dbf =_bae .encodeInteger (proc ,value );_dbf !=nil {return _e .Wrap (_dbf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};const _agf =0x9b25;func (_eb *codingContext )flipMps (_b uint32 ){_eb ._ag [_b ]=1-_eb ._ag [_b ]};
func (_cdf *Encoder )Flush (){_cdf ._bb =0;_cdf ._eag =nil ;_cdf ._gb =-1};type Class int ;var _cda =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func New ()*Encoder {_ef :=&Encoder {};_ef .Init ();return _ef };func (_fea *Encoder )encodeInteger (_adb Class ,_bgfa int )error {const _afd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _bgfa > 2000000000||_bgfa < -2000000000{return _e .Errorf (_afd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bgfa );
};_cbc :=_fea ._ge [_adb ];_dab :=uint32 (1);var _gff int ;for ;;_gff ++{if _gg [_gff ]._ec <=_bgfa &&_gg [_gff ]._cd >=_bgfa {break ;};};if _bgfa < 0{_bgfa =-_bgfa ;};_bgfa -=int (_gg [_gff ]._aa );_dbe :=_gg [_gff ]._db ;for _fadg :=uint8 (0);_fadg < _gg [_gff ]._f ;
_fadg ++{_fdd :=_dbe &1;if _gcbd :=_fea .encodeBit (_cbc ,_dab ,_fdd );_gcbd !=nil {return _e .Wrap (_gcbd ,_afd ,"");};_dbe >>=1;if _dab &0x100> 0{_dab =(((_dab <<1)|uint32 (_fdd ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_fdd );};};_bgfa <<=32-_gg [_gff ]._g ;
for _dff :=uint8 (0);_dff < _gg [_gff ]._g ;_dff ++{_beb :=uint8 ((uint32 (_bgfa )&0x80000000)>>31);if _ffa :=_fea .encodeBit (_cbc ,_dab ,_beb );_ffa !=nil {return _e .Wrap (_ffa ,_afd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_bgfa <<=1;if _dab &0x100!=0{_dab =(((_dab <<1)|uint32 (_beb ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_beb );};};return nil ;};func (_ed *Encoder )Reset (){_ed ._ee =0x8000;_ed ._cc =0;_ed ._bd =12;_ed ._gb =-1;_ed ._bcb =0;_ed ._fg =nil ;_ed ._df =_gd (_cfb );
};func (_dc *Encoder )encodeBit (_ecd *codingContext ,_edd uint32 ,_cbb uint8 )error {const _ab ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_dc ._ea ++;if _edd >=uint32 (len (_ecd ._fc )){return _e .Errorf (_ab ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_edd );
};_ebg :=_ecd ._fc [_edd ];_dfb :=_ecd .mps (_edd );_aff :=_cda [_ebg ]._feg ;_ac .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dc ._ea ,_cbb ,_ebg ,_dfb ,_aff ,_dc ._ee ,_dc ._cc ,_dc ._bd ,_dc ._bcb ,_dc ._gb );
if _cbb ==0{_dc .code0 (_ecd ,_edd ,_aff ,_ebg );}else {_dc .code1 (_ecd ,_edd ,_aff ,_ebg );};return nil ;};func (_gfb *Encoder )dataSize ()int {return _ced *len (_gfb ._eag )+_gfb ._bb };func (_eae *Encoder )EncodeOOB (proc Class )(_aca error ){_ac .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _aca =_eae .encodeOOB (proc );_aca !=nil {return _e .Wrap (_aca ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_dbc *Encoder )renormalize (){for {_dbc ._ee <<=1;_dbc ._cc <<=1;_dbc ._bd --;if _dbc ._bd ==0{_dbc .byteOut ();
};if (_dbc ._ee &0x8000)!=0{break ;};};};type Encoder struct{_cc uint32 ;_ee uint16 ;_bd ,_bcb uint8 ;_gb int ;_ea int ;_eag [][]byte ;_fa []byte ;_bb int ;_df *codingContext ;_ge [13]*codingContext ;_fg *codingContext ;};func (_bda *Encoder )encodeOOB (_fge Class )error {_dgcb :=_bda ._ge [_fge ];
_dbef :=_bda .encodeBit (_dgcb ,1,1);if _dbef !=nil {return _dbef ;};_dbef =_bda .encodeBit (_dgcb ,3,0);if _dbef !=nil {return _dbef ;};_dbef =_bda .encodeBit (_dgcb ,6,0);if _dbef !=nil {return _dbef ;};_dbef =_bda .encodeBit (_dgcb ,12,0);if _dbef !=nil {return _dbef ;
};return nil ;};func (_gf *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _efd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ebbf int64 ;for _aaf ,_cgg :=range _gf ._eag {_ded ,_cgb :=w .Write (_cgg );if _cgb !=nil {return 0,_e .Wrapf (_cgb ,_efd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_aaf );
};_ebbf +=int64 (_ded );};_gf ._fa =_gf ._fa [:_gf ._bb ];_dae ,_dgc :=w .Write (_gf ._fa );if _dgc !=nil {return 0,_e .Wrap (_dgc ,_efd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ebbf +=int64 (_dae );return _ebbf ,nil ;
};func (_aeg *Encoder )codeMPS (_ccd *codingContext ,_dfef uint32 ,_edb uint16 ,_bge byte ){_aeg ._ee -=_edb ;if _aeg ._ee &0x8000!=0{_aeg ._cc +=uint32 (_edb );return ;};if _aeg ._ee < _edb {_aeg ._ee =_edb ;}else {_aeg ._cc +=uint32 (_edb );};_ccd ._fc [_dfef ]=_cda [_bge ]._afb ;
_aeg .renormalize ();};func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_baa *Encoder )flush (){_baa .setBits ();_baa ._cc <<=_baa ._bd ;_baa .byteOut ();_baa ._cc <<=_baa ._bd ;
_baa .byteOut ();_baa .emit ();if _baa ._bcb !=0xff{_baa ._gb ++;_baa ._bcb =0xff;_baa .emit ();};_baa ._gb ++;_baa ._bcb =0xac;_baa ._gb ++;_baa .emit ();};var _ _d .WriterTo =&Encoder {};func (_gbd *Encoder )EncodeBitmap (bm *_da .Bitmap ,duplicateLineRemoval bool )error {_ac .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fd ,_de uint8 ;_ada ,_cb ,_ece uint16 ;_ebc ,_fac ,_be byte ;_bg ,_dfe ,_ca int ;_ba ,_efg []byte ;);for _ebb :=0;_ebb < bm .Height ;_ebb ++{_ebc ,_fac =0,0;if _ebb >=2{_ebc =bm .Data [(_ebb -2)*bm .RowStride ];};if _ebb >=1{_fac =bm .Data [(_ebb -1)*bm .RowStride ];
if duplicateLineRemoval {_dfe =_ebb *bm .RowStride ;_ba =bm .Data [_dfe :_dfe +bm .RowStride ];_ca =(_ebb -1)*bm .RowStride ;_efg =bm .Data [_ca :_ca +bm .RowStride ];if _ad .Equal (_ba ,_efg ){_de =_fd ^1;_fd =1;}else {_de =_fd ;_fd =0;};};};if duplicateLineRemoval {if _eec :=_gbd .encodeBit (_gbd ._df ,_agf ,_de );
_eec !=nil {return _eec ;};if _fd !=0{continue ;};};_be =bm .Data [_ebb *bm .RowStride ];_ada =uint16 (_ebc >>5);_cb =uint16 (_fac >>4);_ebc <<=3;_fac <<=4;_ece =0;for _bg =0;_bg < bm .Width ;_bg ++{_cdd :=uint32 (_ada <<11|_cb <<4|_ece );_cg :=(_be &0x80)>>7;
_dfc :=_gbd .encodeBit (_gbd ._df ,_cdd ,_cg );if _dfc !=nil {return _dfc ;};_ada <<=1;_cb <<=1;_ece <<=1;_ada |=uint16 ((_ebc &0x80)>>7);_cb |=uint16 ((_fac &0x80)>>7);_ece |=uint16 (_cg );_eecf :=_bg %8;_fe :=_bg /8+1;if _eecf ==4&&_ebb >=2{_ebc =0;if _fe < bm .RowStride {_ebc =bm .Data [(_ebb -2)*bm .RowStride +_fe ];
};}else {_ebc <<=1;};if _eecf ==3&&_ebb >=1{_fac =0;if _fe < bm .RowStride {_fac =bm .Data [(_ebb -1)*bm .RowStride +_fe ];};}else {_fac <<=1;};if _eecf ==7{_be =0;if _fe < bm .RowStride {_be =bm .Data [_ebb *bm .RowStride +_fe ];};}else {_be <<=1;};_ada &=31;
_cb &=127;_ece &=15;};};return nil ;};func _gd (_bc int )*codingContext {return &codingContext {_fc :make ([]byte ,_bc ),_ag :make ([]byte ,_bc )};};func (_dg *Encoder )Final (){_dg .flush ()};func (_acd *Encoder )setBits (){_cea :=_acd ._cc +uint32 (_acd ._ee );
_acd ._cc |=0xffff;if _acd ._cc >=_cea {_acd ._cc -=0x8000;};};var _gg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_fgf *Encoder )encodeIAID (_fddf ,_cbe int )error {if _fgf ._fg ==nil {_fgf ._fg =_gd (1<<uint (_fddf ));};_ccdg :=uint32 (1<<uint32 (_fddf +1))-1;_cbe <<=uint (32-_fddf );_fbd :=uint32 (1);for _ffd :=0;_ffd < _fddf ;_ffd ++{_eca :=_fbd &_ccdg ;_ffc :=uint8 ((uint32 (_cbe )&0x80000000)>>31);
if _gca :=_fgf .encodeBit (_fgf ._fg ,_eca ,_ffc );_gca !=nil {return _gca ;};_fbd =(_fbd <<1)|uint32 (_ffc );_cbe <<=1;};return nil ;};func (_cf *Encoder )DataSize ()int {return _cf .dataSize ()};func (_ce *Encoder )code1 (_dbfe *codingContext ,_agbc uint32 ,_fbb uint16 ,_efga byte ){if _dbfe .mps (_agbc )==1{_ce .codeMPS (_dbfe ,_agbc ,_fbb ,_efga );
}else {_ce .codeLPS (_dbfe ,_agbc ,_fbb ,_efga );};};func (_fag *Encoder )lBlock (){if _fag ._gb >=0{_fag .emit ();};_fag ._gb ++;_fag ._bcb =uint8 (_fag ._cc >>19);_fag ._cc &=0x7ffff;_fag ._bd =8;};func (_fbf *Encoder )codeLPS (_bfg *codingContext ,_bac uint32 ,_acb uint16 ,_eaed byte ){_fbf ._ee -=_acb ;
if _fbf ._ee < _acb {_fbf ._cc +=uint32 (_acb );}else {_fbf ._ee =_acb ;};if _cda [_eaed ]._abe ==1{_bfg .flipMps (_bac );};_bfg ._fc [_bac ]=_cda [_eaed ]._ddg ;_fbf .renormalize ();};func (_deeb *Encoder )code0 (_dgg *codingContext ,_ff uint32 ,_gfc uint16 ,_deb byte ){if _dgg .mps (_ff )==0{_deeb .codeMPS (_dgg ,_ff ,_gfc ,_deb );
}else {_deeb .codeLPS (_dgg ,_ff ,_gfc ,_deb );};};const (_cfb =65536;_ced =20*1024;);type intEncRangeS struct{_ec ,_cd int ;_db ,_f uint8 ;_aa uint16 ;_g uint8 ;};func (_fbbg *Encoder )rBlock (){if _fbbg ._gb >=0{_fbbg .emit ();};_fbbg ._gb ++;_fbbg ._bcb =uint8 (_fbbg ._cc >>20);
_fbbg ._cc &=0xfffff;_fbbg ._bd =7;};type state struct{_feg uint16 ;_afb ,_ddg uint8 ;_abe uint8 ;};func (_af *Encoder )Init (){_af ._df =_gd (_cfb );_af ._ee =0x8000;_af ._cc =0;_af ._bd =12;_af ._gb =-1;_af ._bcb =0;_af ._bb =0;_af ._fa =make ([]byte ,_ced );
for _agb :=0;_agb < len (_af ._ge );_agb ++{_af ._ge [_agb ]=_gd (512);};_af ._fg =nil ;};