//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_ec "github.com/unidoc/unipdf/v3/common";_c "math";);const _cag =1e-6;func (_ac Matrix )Mult (b Matrix )Matrix {_ac .Concat (b );return _ac };func (_db Matrix )Angle ()float64 {_df :=_c .Atan2 (-_db [1],_db [0]);if _df < 0.0{_df +=2*_c .Pi ;
};return _df /_c .Pi *180.0;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_gf :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_gf .clampRange ();return _gf ;};func (_gg Matrix )Rotate (theta float64 )Matrix {return _gg .Mult (RotationMatrix (theta ))};func RotationMatrix (angle float64 )Matrix {_ba :=_c .Cos (angle );
_a :=_c .Sin (angle );return NewMatrix (_ba ,_a ,-_a ,_ba ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _gef =1e9;func (_ag *Point )transformByMatrix (_fb Matrix ){_ag .X ,_ag .Y =_fb .Transform (_ag .X ,_ag .Y )};
func (_ecc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ed :=x *_ecc [0]+y *_ecc [3]+_ecc [6];_ggd :=x *_ecc [1]+y *_ecc [4]+_ecc [7];return _ed ,_ggd ;};const _dfa =1.0e-6;type Point struct{X float64 ;Y float64 ;};func (_ebf *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ebf [0],_ebf [1]=a ,b ;
_ebf [3],_ebf [4]=c ,d ;_ebf [6],_ebf [7]=tx ,ty ;_ebf .clampRange ();};func (_eb Matrix )Scale (xScale ,yScale float64 )Matrix {return _eb .Mult (ScaleMatrix (xScale ,yScale ))};func (_cgg Matrix )Singular ()bool {return _c .Abs (_cgg [0]*_cgg [4]-_cgg [1]*_cgg [3])< _gfb };
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_eec *Point )Set (x ,y float64 ){_eec .X ,_eec .Y =x ,y };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_gb Matrix )Translation ()(float64 ,float64 ){return _gb [6],_gb [7]};
func (_bc Point )Distance (b Point )float64 {return _c .Hypot (_bc .X -b .X ,_bc .Y -b .Y )};func (_fgd Point )Displace (delta Point )Point {return Point {_fgd .X +delta .X ,_fgd .Y +delta .Y }};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_fa Matrix )Translate (tx ,ty float64 )Matrix {return _fa .Mult (TranslationMatrix (tx ,ty ))};func (_fac Matrix )ScalingFactorX ()float64 {return _c .Hypot (_fac [0],_fac [1])};func (_bg Matrix )String ()string {_cg ,_bgc ,_fe ,_bb ,_cc ,_ce :=_bg [0],_bg [1],_bg [3],_bg [4],_bg [6],_bg [7];
return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cg ,_bgc ,_fe ,_bb ,_cc ,_ce );
};func (_ae *Matrix )Concat (b Matrix ){*_ae =Matrix {b [0]*_ae [0]+b [1]*_ae [3],b [0]*_ae [1]+b [1]*_ae [4],0,b [3]*_ae [0]+b [4]*_ae [3],b [3]*_ae [1]+b [4]*_ae [4],0,b [6]*_ae [0]+b [7]*_ae [3]+_ae [6],b [6]*_ae [1]+b [7]*_ae [4]+_ae [7],1};_ae .clampRange ();
};func (_eed Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_eed .X +t *b .X ,Y :(1-t )*_eed .Y +t *b .Y };};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_aef Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aef .X ,_aef .Y );
};func (_fc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_caf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_fc .transformByMatrix (_caf );};func (_ff Matrix )ScalingFactorY ()float64 {return _c .Hypot (_ff [3],_ff [4])};func (_cce Matrix )Unrealistic ()bool {_cec ,_ea ,_eee ,_eff :=_c .Abs (_cce [0]),_c .Abs (_cce [1]),_c .Abs (_cce [3]),_c .Abs (_cce [4]);
_ga :=_cec > _cag &&_eff > _cag ;_de :=_ea > _cag &&_eee > _cag ;return !(_ga ||_de );};func (_be *Matrix )Shear (x ,y float64 ){_be .Concat (ShearMatrix (x ,y ))};func (_ebg *Matrix )Clone ()Matrix {return NewMatrix (_ebg [0],_ebg [1],_ebg [3],_ebg [4],_ebg [6],_ebg [7]);
};type Matrix [9]float64 ;func (_cb *Matrix )clampRange (){for _fg ,_cd :=range _cb {if _cd > _gef {_ec .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,_gef );_cb [_fg ]=_gef ;}else if _cd < -_gef {_ec .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,-_gef );
_cb [_fg ]=-_gef ;};};};func (_dbg Point )Rotate (theta float64 )Point {_dbf :=_c .Hypot (_dbg .X ,_dbg .Y );_gce :=_c .Atan2 (_dbg .Y ,_dbg .X );_bd ,_dba :=_c .Sincos (_gce +theta /180.0*_c .Pi );return Point {_dbf *_dba ,_dbf *_bd };};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
const _gfb =1e-10;func (_gga Matrix )Inverse ()(Matrix ,bool ){_ebfd ,_bga :=_gga [0],_gga [1];_ca ,_cf :=_gga [3],_gga [4];_eg ,_ef :=_gga [6],_gga [7];_ccd :=_ebfd *_cf -_bga *_ca ;if _c .Abs (_ccd )< _dfa {return Matrix {},false ;};_bbc ,_gc :=_cf /_ccd ,-_bga /_ccd ;
_ee ,_ge :=-_ca /_ccd ,_ebfd /_ccd ;_da :=-(_bbc *_eg +_ee *_ef );_ecg :=-(_gc *_eg +_ge *_ef );return NewMatrix (_bbc ,_gc ,_ee ,_ge ,_da ,_ecg ),true ;};func (_d Matrix )Identity ()bool {return _d [0]==1&&_d [1]==0&&_d [2]==0&&_d [3]==0&&_d [4]==1&&_d [5]==0&&_d [6]==0&&_d [7]==0&&_d [8]==1;
};func (_f Matrix )Round (precision float64 )Matrix {for _b :=range _f {_f [_b ]=_c .Round (_f [_b ]/precision )*precision ;};return _f ;};