//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_ab "encoding/binary";_d "errors";_dcg "fmt";_c "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_dc "image";_de "image/color";_fe "image/draw";_a "math";);func (_egad *Gray8 )Base ()*ImageBase {return &_egad .ImageBase };
func _cag (_bggc _de .NRGBA )_de .Gray {var _gcaf _de .NRGBA ;if _bggc ==_gcaf {return _de .Gray {Y :0xff};};_adda ,_eeg ,_fcb ,_ :=_bggc .RGBA ();_ddcg :=(19595*_adda +38470*_eeg +7471*_fcb +1<<15)>>24;return _de .Gray {Y :uint8 (_ddcg )};};type CMYK interface{CMYKAt (_befc ,_gbg int )_de .CMYK ;
SetCMYK (_dgdb ,_aab int ,_dae _de .CMYK );};var (_bffa =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_febf =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_ddcb *RGBA32 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_ddcb .Width ,Y :_ddcb .Height }};
};func (_aeg *Monochrome )getBit (_ddca ,_ggdg int )uint8 {return _aeg .Data [_ddca +(_ggdg >>3)]>>uint (7-(_ggdg &7))&1;};func _bacd (_gdcd *Monochrome ,_affcf ,_gggfa ,_baeb ,_eecf int ,_gead RasterOperator ,_bedd *Monochrome ,_acgd ,_abga int )error {if _gdcd ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _gead ==PixDst {return nil ;};switch _gead {case PixClr ,PixSet ,PixNotDst :_dddcc (_gdcd ,_affcf ,_gggfa ,_baeb ,_eecf ,_gead );return nil ;};if _bedd ==nil {_c .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _gad :=_egdd (_gdcd ,_affcf ,_gggfa ,_baeb ,_eecf ,_gead ,_bedd ,_acgd ,_abga );_gad !=nil {return _gad ;};return nil ;};func _ffbb (_dce ,_ddbb int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_dce ,_ddbb ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func (_aeef *ImageBase )getByte (_gfeg int )(byte ,error ){if _gfeg > len (_aeef .Data )-1||_gfeg < 0{return 0,_dcg .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_gfeg );
};return _aeef .Data [_gfeg ],nil ;};var _ Image =&Gray4 {};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _aaff (_eb *Monochrome ,_fgg int ,_fgdf []byte )(_cdce *Monochrome ,_cgf error ){const _eea ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _eb ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _fgg < 1||_fgg > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _eb .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_cdce =_ffbb (_eb .Width /2,_eb .Height /2);
if _fgdf ==nil {_fgdf =_eba ();};_fabc :=_fbag (_eb .BytesPerLine ,2*_cdce .BytesPerLine );switch _fgg {case 1:_cgf =_fee (_eb ,_cdce ,_fgdf ,_fabc );case 2:_cgf =_eac (_eb ,_cdce ,_fgdf ,_fabc );case 3:_cgf =_abab (_eb ,_cdce ,_fgdf ,_fabc );case 4:_cgf =_aee (_eb ,_cdce ,_fgdf ,_fabc );
};if _cgf !=nil {return nil ,_cgf ;};return _cdce ,nil ;};func (_dfee *Gray16 )SetGray (x ,y int ,g _de .Gray ){_addab :=(y *_dfee .BytesPerLine /2+x )*2;if _addab +1>=len (_dfee .Data ){return ;};_dfee .Data [_addab ]=g .Y ;_dfee .Data [_addab +1]=g .Y ;
};func (_efef *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cddc :=_ffbb (width ,height );_ebcag :=make ([]int ,height );_efec :=make ([]int ,width );_bbe :=float64 (_efef .Width )/float64 (width );_dcbb :=float64 (_efef .Height )/float64 (height );for _gffe :=0;_gffe < height ;_gffe ++{_ebcag [_gffe ]=int (_a .Min (_dcbb *float64 (_gffe )+0.5,float64 (_efef .Height -1)));
};for _eeag :=0;_eeag < width ;_eeag ++{_efec [_eeag ]=int (_a .Min (_bbe *float64 (_eeag )+0.5,float64 (_efef .Width -1)));};_cgg :=-1;_fga :=byte (0);for _baae :=0;_baae < height ;_baae ++{_acca :=_ebcag [_baae ]*_efef .BytesPerLine ;_dde :=_baae *_cddc .BytesPerLine ;
for _efce :=0;_efce < width ;_efce ++{_ecea :=_efec [_efce ];if _ecea !=_cgg {_fga =_efef .getBit (_acca ,_ecea );if _fga !=0{_cddc .setBit (_dde ,_efce );};_cgg =_ecea ;}else {if _fga !=0{_cddc .setBit (_dde ,_efce );};};};};return _cddc ,nil ;};func _cfa (_bc *Monochrome ,_gg int ,_ae []uint )(*Monochrome ,error ){_df :=_gg *_bc .Width ;
_fg :=_gg *_bc .Height ;_cfag :=_ffbb (_df ,_fg );for _bcf ,_bg :=range _ae {var _gb error ;switch _bg {case 2:_gb =_ba (_cfag ,_bc );case 4:_gb =_bf (_cfag ,_bc );case 8:_gb =_addc (_cfag ,_bc );};if _gb !=nil {return nil ,_gb ;};if _bcf !=len (_ae )-1{_bc =_cfag .copy ();
};};return _cfag ,nil ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_de .NRGBA64 ,error ){_edgb :=(y *width +x )*2;_gbfc :=_edgb *3;if _gbfc +5>=len (data ){return _de .NRGBA64 {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _eeed =0xffff;_cddbe :=uint16 (_eeed );if alpha !=nil &&len (alpha )> _edgb +1{_cddbe =uint16 (alpha [_edgb ])<<8|uint16 (alpha [_edgb +1]);};_ebage :=uint16 (data [_gbfc ])<<8|uint16 (data [_gbfc +1]);_cbbcc :=uint16 (data [_gbfc +2])<<8|uint16 (data [_gbfc +3]);
_defe :=uint16 (data [_gbfc +4])<<8|uint16 (data [_gbfc +5]);if len (decode )==6{_ebage =uint16 (uint64 (LinearInterpolate (float64 (_ebage ),0,65535,decode [0],decode [1]))&_eeed );_cbbcc =uint16 (uint64 (LinearInterpolate (float64 (_cbbcc ),0,65535,decode [2],decode [3]))&_eeed );
_defe =uint16 (uint64 (LinearInterpolate (float64 (_defe ),0,65535,decode [4],decode [5]))&_eeed );};return _de .NRGBA64 {R :_ebage ,G :_cbbcc ,B :_defe ,A :_cddbe },nil ;};func (_dbbf *Monochrome )IsUnpadded ()bool {return (_dbbf .Width *_dbbf .Height )==len (_dbbf .Data )};
func _fcef (_gcf _de .RGBA )_de .Gray {_ebbd :=(19595*uint32 (_gcf .R )+38470*uint32 (_gcf .G )+7471*uint32 (_gcf .B )+1<<7)>>16;return _de .Gray {Y :uint8 (_ebbd )};};func (_fcga *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_ade :=_dfbd (uint (factor ));
if !IsPowerOf2 (uint (factor )){_ade ++;};_ceae :=make ([]int ,_ade );for _ebca :=range _ceae {_ceae [_ebca ]=4;};_ecd ,_edac :=_bbc (_fcga ,_ceae ...);if _edac !=nil {return nil ,_edac ;};return _ecd ,nil ;};func _ggaf (_agdd ,_fdcaf uint8 )uint8 {if _agdd < _fdcaf {return 255;
};return 0;};func ConverterFunc (converterFunc func (_ggab _dc .Image )(Image ,error ))ColorConverter {return colorConverter {_begg :converterFunc };};func (_caa *ImageBase )setEightPartlyBytes (_gdc ,_bced int ,_bdbf uint64 )(_aeda error ){var (_gcba byte ;
_fffg int ;);for _acf :=1;_acf <=_bced ;_acf ++{_fffg =64-_acf *8;_gcba =byte (_bdbf >>uint (_fffg )&0xff);if _aeda =_caa .setByte (_gdc +_acf -1,_gcba );_aeda !=nil {return _aeda ;};};_bbefa :=_caa .BytesPerLine *8-_caa .Width ;if _bbefa ==0{return nil ;
};_fffg -=8;_gcba =byte (_bdbf >>uint (_fffg )&0xff)<<uint (_bbefa );if _aeda =_caa .setByte (_gdc +_bced ,_gcba );_aeda !=nil {return _aeda ;};return nil ;};func (_ggbe *Gray4 )Validate ()error {if len (_ggbe .Data )!=_ggbe .Height *_ggbe .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_gce *CMYK32 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_gce .Width ,Y :_gce .Height }};};func (_faag *Gray4 )SetGray (x ,y int ,g _de .Gray ){if x >=_faag .Width ||y >=_faag .Height {return ;};g =_debcg (g );
_faag .setGray (x ,y ,g );};type NRGBA16 struct{ImageBase };func _ggd (_dbd ,_gd int ,_ac []byte )*Monochrome {_dg :=_ffbb (_dbd ,_gd );_dg .Data =_ac ;return _dg };func (_fcbf *Gray2 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_fcbf .Width ,Y :_fcbf .Height }};
};func (_ffgb *CMYK32 )Validate ()error {if len (_ffgb .Data )!=4*_ffgb .Width *_ffgb .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bdef (_bba _de .NRGBA64 )_de .NRGBA {return _de .NRGBA {R :uint8 (_bba .R >>8),G :uint8 (_bba .G >>8),B :uint8 (_bba .B >>8),A :uint8 (_bba .A >>8)};};var (_fab =_dcgb ();_ggfd =_aed ();_ffb =_fabd (););func (_bfcg *RGBA32 )Base ()*ImageBase {return &_bfcg .ImageBase };
func (_dgea *Gray4 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_dgea .Width ,Y :_dgea .Height }};};func (_bdgc *RGBA32 )At (x ,y int )_de .Color {_eddg ,_ :=_bdgc .ColorAt (x ,y );return _eddg };func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_dfbd (n )+1);};func _aed ()(_dbe [256]uint32 ){for _beg :=0;_beg < 256;_beg ++{if _beg &0x01!=0{_dbe [_beg ]|=0xf;};if _beg &0x02!=0{_dbe [_beg ]|=0xf0;};if _beg &0x04!=0{_dbe [_beg ]|=0xf00;};if _beg &0x08!=0{_dbe [_beg ]|=0xf000;};if _beg &0x10!=0{_dbe [_beg ]|=0xf0000;
};if _beg &0x20!=0{_dbe [_beg ]|=0xf00000;};if _beg &0x40!=0{_dbe [_beg ]|=0xf000000;};if _beg &0x80!=0{_dbe [_beg ]|=0xf0000000;};};return _dbe ;};func (_cabe *NRGBA64 )setNRGBA64 (_ggfgb int ,_aebc _de .NRGBA64 ,_ffgd int ){_cabe .Data [_ggfgb ]=uint8 (_aebc .R >>8);
_cabe .Data [_ggfgb +1]=uint8 (_aebc .R &0xff);_cabe .Data [_ggfgb +2]=uint8 (_aebc .G >>8);_cabe .Data [_ggfgb +3]=uint8 (_aebc .G &0xff);_cabe .Data [_ggfgb +4]=uint8 (_aebc .B >>8);_cabe .Data [_ggfgb +5]=uint8 (_aebc .B &0xff);if _ffgd +1< len (_cabe .Alpha ){_cabe .Alpha [_ffgd ]=uint8 (_aebc .A >>8);
_cabe .Alpha [_ffgd +1]=uint8 (_aebc .A &0xff);};};func FromGoImage (i _dc .Image )(Image ,error ){switch _fgef :=i .(type ){case Image :return _fgef .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_dc .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_dc .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _egdd (_accf *Monochrome ,_acgf ,_efg int ,_eedd ,_bafb int ,_ffadb RasterOperator ,_bceb *Monochrome ,_cbdf ,_efdd int )error {var _cfed ,_aedag ,_acfb ,_dadg int ;
if _acgf < 0{_cbdf -=_acgf ;_eedd +=_acgf ;_acgf =0;};if _cbdf < 0{_acgf -=_cbdf ;_eedd +=_cbdf ;_cbdf =0;};_cfed =_acgf +_eedd -_accf .Width ;if _cfed > 0{_eedd -=_cfed ;};_aedag =_cbdf +_eedd -_bceb .Width ;if _aedag > 0{_eedd -=_aedag ;};if _efg < 0{_efdd -=_efg ;
_bafb +=_efg ;_efg =0;};if _efdd < 0{_efg -=_efdd ;_bafb +=_efdd ;_efdd =0;};_acfb =_efg +_bafb -_accf .Height ;if _acfb > 0{_bafb -=_acfb ;};_dadg =_efdd +_bafb -_bceb .Height ;if _dadg > 0{_bafb -=_dadg ;};if _eedd <=0||_bafb <=0{return nil ;};var _gface error ;
switch {case _acgf &7==0&&_cbdf &7==0:_gface =_cbca (_accf ,_acgf ,_efg ,_eedd ,_bafb ,_ffadb ,_bceb ,_cbdf ,_efdd );case _acgf &7==_cbdf &7:_gface =_dbcb (_accf ,_acgf ,_efg ,_eedd ,_bafb ,_ffadb ,_bceb ,_cbdf ,_efdd );default:_gface =_acda (_accf ,_acgf ,_efg ,_eedd ,_bafb ,_ffadb ,_bceb ,_cbdf ,_efdd );
};if _gface !=nil {return _gface ;};return nil ;};func (_dgc *ImageBase )HasAlpha ()bool {if _dgc .Alpha ==nil {return false ;};for _dgef :=range _dgc .Alpha {if _dgc .Alpha [_dgef ]!=0xff{return true ;};};return false ;};func (_bcbf *Gray2 )Base ()*ImageBase {return &_bcbf .ImageBase };
type shift int ;func (_aabg *NRGBA32 )Validate ()error {if len (_aabg .Data )!=3*_aabg .Width *_aabg .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func InDelta (expected ,current ,delta float64 )bool {_ccbc :=expected -current ;if _ccbc <=-delta ||_ccbc >=delta {return false ;};return true ;};func (_cacc *RGBA32 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtRGBA32 (x ,y ,_cacc .Width ,_cacc .Data ,_cacc .Alpha ,_cacc .Decode );
};func (_dggg *Monochrome )InverseData ()error {return _dggg .RasterOperation (0,0,_dggg .Width ,_dggg .Height ,PixNotDst ,nil ,0,0);};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Gray ,error ){_gbbe :=y *bytesPerLine +x >>2;
if _gbbe >=len (data ){return _de .Gray {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efeg :=data [_gbbe ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_efeg =uint8 (uint32 (LinearInterpolate (float64 (_efeg ),0,3.0,decode [0],decode [1]))&3);};return _de .Gray {Y :_efeg *85},nil ;};var _ Gray =&Gray8 {};func (_bcd *Gray8 )Histogram ()(_gbdb [256]int ){for _fcaa :=0;
_fcaa < len (_bcd .Data );_fcaa ++{_gbdb [_bcd .Data [_fcaa ]]++;};return _gbdb ;};func (_cdgb *NRGBA16 )Set (x ,y int ,c _de .Color ){_ebf :=y *_cdgb .BytesPerLine +x *3/2;if _ebf +1>=len (_cdgb .Data ){return ;};_gefbd :=NRGBA16Model .Convert (c ).(_de .NRGBA );
_cdgb .setNRGBA (x ,y ,_ebf ,_gefbd );};func _gea (_agaa _de .RGBA )_de .NRGBA {switch _agaa .A {case 0xff:return _de .NRGBA {R :_agaa .R ,G :_agaa .G ,B :_agaa .B ,A :0xff};case 0x00:return _de .NRGBA {};default:_cba ,_baf ,_cae ,_ddd :=_agaa .RGBA ();
_cba =(_cba *0xffff)/_ddd ;_baf =(_baf *0xffff)/_ddd ;_cae =(_cae *0xffff)/_ddd ;return _de .NRGBA {R :uint8 (_cba >>8),G :uint8 (_baf >>8),B :uint8 (_cae >>8),A :uint8 (_ddd >>8)};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;
PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);func (_dgg colorConverter )Convert (src _dc .Image )(Image ,error ){return _dgg ._begg (src )};func (_bdbg *Monochrome )setGrayBit (_gfbbf ,_fdg int ){_bdbg .Data [_gfbbf ]|=0x80>>uint (_fdg &7)};func (_geg *Gray4 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtGray4BPC (x ,y ,_geg .BytesPerLine ,_geg .Data ,_geg .Decode );
};func (_dead *NRGBA16 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_dead .Width ,Y :_dead .Height }};};func (_egda *Monochrome )Histogram ()(_adbd [256]int ){for _ ,_gfcd :=range _egda .Data {_adbd [0xff]+=int (_egge [_egda .Data [_gfcd ]]);
};return _adbd ;};func _aee (_ega ,_ddbgb *Monochrome ,_dcc []byte ,_cbc int )(_agf error ){var (_fcd ,_dbg ,_bge ,_fcdg ,_bdgg ,_ede ,_cead ,_debe int ;_fabg ,_bgga uint32 ;_aca ,_cgef byte ;_fggg uint16 ;);_aafb :=make ([]byte ,4);_ebe :=make ([]byte ,4);
for _bge =0;_bge < _ega .Height -1;_bge ,_fcdg =_bge +2,_fcdg +1{_fcd =_bge *_ega .BytesPerLine ;_dbg =_fcdg *_ddbgb .BytesPerLine ;for _bdgg ,_ede =0,0;_bdgg < _cbc ;_bdgg ,_ede =_bdgg +4,_ede +1{for _cead =0;_cead < 4;_cead ++{_debe =_fcd +_bdgg +_cead ;
if _debe <=len (_ega .Data )-1&&_debe < _fcd +_ega .BytesPerLine {_aafb [_cead ]=_ega .Data [_debe ];}else {_aafb [_cead ]=0x00;};_debe =_fcd +_ega .BytesPerLine +_bdgg +_cead ;if _debe <=len (_ega .Data )-1&&_debe < _fcd +(2*_ega .BytesPerLine ){_ebe [_cead ]=_ega .Data [_debe ];
}else {_ebe [_cead ]=0x00;};};_fabg =_ab .BigEndian .Uint32 (_aafb );_bgga =_ab .BigEndian .Uint32 (_ebe );_bgga &=_fabg ;_bgga &=_bgga <<1;_bgga &=0xaaaaaaaa;_fabg =_bgga |(_bgga <<7);_aca =byte (_fabg >>24);_cgef =byte ((_fabg >>8)&0xff);_debe =_dbg +_ede ;
if _debe +1==len (_ddbgb .Data )-1||_debe +1>=_dbg +_ddbgb .BytesPerLine {_ddbgb .Data [_debe ]=_dcc [_aca ];if _agf =_ddbgb .setByte (_debe ,_dcc [_aca ]);_agf !=nil {return _dcg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_debe );};}else {_fggg =(uint16 (_dcc [_aca ])<<8)|uint16 (_dcc [_cgef ]);
if _agf =_ddbgb .setTwoBytes (_debe ,_fggg );_agf !=nil {return _dcg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_debe );
};_ede ++;};};};return nil ;};func _ffag (_gae ,_deff NRGBA ,_efdfd _dc .Rectangle ){for _bdfa :=0;_bdfa < _efdfd .Max .X ;_bdfa ++{for _ggfge :=0;_ggfge < _efdfd .Max .Y ;_ggfge ++{_deff .SetNRGBA (_bdfa ,_ggfge ,_gae .NRGBAAt (_bdfa ,_ggfge ));};};};
func _dbdg (){for _gddd :=0;_gddd < 256;_gddd ++{_egge [_gddd ]=uint8 (_gddd &0x1)+(uint8 (_gddd >>1)&0x1)+(uint8 (_gddd >>2)&0x1)+(uint8 (_gddd >>3)&0x1)+(uint8 (_gddd >>4)&0x1)+(uint8 (_gddd >>5)&0x1)+(uint8 (_gddd >>6)&0x1)+(uint8 (_gddd >>7)&0x1);};
};var _ RGBA =&RGBA32 {};func (_afaf *Gray2 )ColorModel ()_de .Model {return Gray2Model };func (_abbc *RGBA32 )Validate ()error {if len (_abbc .Data )!=3*_abbc .Width *_abbc .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_bcfe *Monochrome )AddPadding ()(_gbe error ){if _fcg :=((_bcfe .Width *_bcfe .Height )+7)>>3;len (_bcfe .Data )< _fcg {return _dcg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_bcfe .Data ),_fcg );
};_gcga :=_bcfe .Width %8;if _gcga ==0{return nil ;};_edef :=_bcfe .Width /8;_bcc :=_g .NewReader (_bcfe .Data );_cbef :=make ([]byte ,_bcfe .Height *_bcfe .BytesPerLine );_bdca :=_g .NewWriterMSB (_cbef );_cddd :=make ([]byte ,_edef );var (_ebgb int ;
_cfda uint64 ;);for _ebgb =0;_ebgb < _bcfe .Height ;_ebgb ++{if _ ,_gbe =_bcc .Read (_cddd );_gbe !=nil {return _gbe ;};if _ ,_gbe =_bdca .Write (_cddd );_gbe !=nil {return _gbe ;};if _cfda ,_gbe =_bcc .ReadBits (byte (_gcga ));_gbe !=nil {return _gbe ;
};if _gbe =_bdca .WriteByte (byte (_cfda )<<uint (8-_gcga ));_gbe !=nil {return _gbe ;};};_bcfe .Data =_bdca .Data ();return nil ;};func (_gcd *Gray2 )Set (x ,y int ,c _de .Color ){if x >=_gcd .Width ||y >=_gcd .Height {return ;};_eadc :=Gray2Model .Convert (c ).(_de .Gray );
_ebag :=y *_gcd .BytesPerLine ;_ced :=_ebag +(x >>2);_ecc :=_eadc .Y >>6;_gcd .Data [_ced ]=(_gcd .Data [_ced ]&(^(0xc0>>uint (2*((x )&3)))))|(_ecc <<uint (6-2*(x &3)));};func _eecb (_adbc _de .NRGBA )_de .NRGBA {_adbc .R =_adbc .R >>4|(_adbc .R >>4)<<4;
_adbc .G =_adbc .G >>4|(_adbc .G >>4)<<4;_adbc .B =_adbc .B >>4|(_adbc .B >>4)<<4;return _adbc ;};func _becb (_agfde Gray ,_affc NRGBA ,_cbee _dc .Rectangle ){for _acg :=0;_acg < _cbee .Max .X ;_acg ++{for _bdf :=0;_bdf < _cbee .Max .Y ;_bdf ++{_ffaa :=_cag (_affc .NRGBAAt (_acg ,_bdf ));
_agfde .SetGray (_acg ,_bdf ,_ffaa );};};};func (_afcb *NRGBA16 )ColorModel ()_de .Model {return NRGBA16Model };func init (){_dbdg ()};var _ _dc .Image =&Gray16 {};func _cded (_eda _de .Gray )_de .RGBA {return _de .RGBA {R :_eda .Y ,G :_eda .Y ,B :_eda .Y ,A :0xff}};
func _gcb (_abc _dc .Image )(Image ,error ){if _ded ,_bda :=_abc .(*CMYK32 );_bda {return _ded .Copy (),nil ;};_bce :=_abc .Bounds ();_ffgf ,_dcf :=NewImage (_bce .Max .X ,_bce .Max .Y ,8,4,nil ,nil ,nil );if _dcf !=nil {return nil ,_dcf ;};switch _gec :=_abc .(type ){case CMYK :_cce (_gec ,_ffgf .(CMYK ),_bce );
case Gray :_fcde (_gec ,_ffgf .(CMYK ),_bce );case NRGBA :_cfe (_gec ,_ffgf .(CMYK ),_bce );case RGBA :_fec (_gec ,_ffgf .(CMYK ),_bce );default:_cdf (_abc ,_ffgf ,_bce );};return _ffgf ,nil ;};func _eecg (_bcfg _de .CMYK )_de .Gray {_aage ,_cefa ,_acd :=_de .CMYKToRGB (_bcfg .C ,_bcfg .M ,_bcfg .Y ,_bcfg .K );
_bbcg :=(19595*uint32 (_aage )+38470*uint32 (_cefa )+7471*uint32 (_acd )+1<<7)>>16;return _de .Gray {Y :uint8 (_bbcg )};};type Gray interface{GrayAt (_bega ,_gfff int )_de .Gray ;SetGray (_fbd ,_edb int ,_fde _de .Gray );};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_de .NRGBA ,error ){_ggbd :=y *width +x ;
_gdeb :=3*_ggbd ;if _gdeb +2>=len (data ){return _de .NRGBA {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ggbd {_bgf =alpha [_ggbd ];};_cdgd ,_fbgef ,_cacdc :=data [_gdeb ],data [_gdeb +1],data [_gdeb +2];if len (decode )==6{_cdgd =uint8 (uint32 (LinearInterpolate (float64 (_cdgd ),0,255,decode [0],decode [1]))&0xff);
_fbgef =uint8 (uint32 (LinearInterpolate (float64 (_fbgef ),0,255,decode [2],decode [3]))&0xff);_cacdc =uint8 (uint32 (LinearInterpolate (float64 (_cacdc ),0,255,decode [4],decode [5]))&0xff);};return _de .NRGBA {R :_cdgd ,G :_fbgef ,B :_cacdc ,A :_bgf },nil ;
};type RasterOperator int ;func (_cbd *Monochrome )SetGray (x ,y int ,g _de .Gray ){_fbfc :=y *_cbd .BytesPerLine +x >>3;if _fbfc > len (_cbd .Data )-1{return ;};g =_abb (g ,monochromeModel (_cbd .ModelThreshold ));_cbd .setGray (x ,g ,_fbfc );};func _bbc (_aaa *Monochrome ,_abg ...int )(_baea *Monochrome ,_cg error ){if _aaa ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_abg )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fef :=_eba ();_baea =_aaa ;for _ ,_gca :=range _abg {if _gca <=0{break ;};_baea ,_cg =_aaff (_baea ,_gca ,_fef );if _cg !=nil {return nil ,_cg ;};};return _baea ,nil ;};func (_dcff *Gray4 )GrayAt (x ,y int )_de .Gray {_edba ,_ :=ColorAtGray4BPC (x ,y ,_dcff .BytesPerLine ,_dcff .Data ,_dcff .Decode );
return _edba ;};func (_bage *NRGBA16 )setNRGBA (_bgae ,_ffed ,_bbfa int ,_ggeeg _de .NRGBA ){if _bgae *3%2==0{_bage .Data [_bbfa ]=(_ggeeg .R >>4)<<4|(_ggeeg .G >>4);_bage .Data [_bbfa +1]=(_ggeeg .B >>4)<<4|(_bage .Data [_bbfa +1]&0xf);}else {_bage .Data [_bbfa ]=(_bage .Data [_bbfa ]&0xf0)|(_ggeeg .R >>4);
_bage .Data [_bbfa +1]=(_ggeeg .G >>4)<<4|(_ggeeg .B >>4);};if _bage .Alpha !=nil {_afec :=_ffed *BytesPerLine (_bage .Width ,4,1);if _afec < len (_bage .Alpha ){if _bgae %2==0{_bage .Alpha [_afec ]=(_ggeeg .A >>uint (4))<<uint (4)|(_bage .Alpha [_bbfa ]&0xf);
}else {_bage .Alpha [_afec ]=(_bage .Alpha [_afec ]&0xf0)|(_ggeeg .A >>uint (4));};};};};func _dfbd (_cfbb uint )uint {var _gbf uint ;for _cfbb !=0{_cfbb >>=1;_gbf ++;};return _gbf -1;};func (_cdfd *Gray4 )Base ()*ImageBase {return &_cdfd .ImageBase };
func (_fbfb *NRGBA64 )SetNRGBA64 (x ,y int ,c _de .NRGBA64 ){_cabg :=(y *_fbfb .Width +x )*2;_acfc :=_cabg *3;if _acfc +5>=len (_fbfb .Data ){return ;};_fbfb .setNRGBA64 (_acfc ,c ,_cabg );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gcad :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gcad .Data =make ([]byte ,height *_gcad .BytesPerLine );};return _gcad ;};func (_dag *Monochrome )Validate ()error {if len (_dag .Data )!=_dag .Height *_dag .BytesPerLine {return ErrInvalidImage ;};return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ggfb :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _afda Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_afda =&Monochrome {ImageBase :_ggfb ,ModelThreshold :0x0f};case 2:_afda =&Gray2 {ImageBase :_ggfb };case 4:_afda =&Gray4 {ImageBase :_ggfb };case 8:_afda =&Gray8 {ImageBase :_ggfb };
case 16:_afda =&Gray16 {ImageBase :_ggfb };};case 3:switch bitsPerComponent {case 4:_afda =&NRGBA16 {ImageBase :_ggfb };case 8:_afda =&NRGBA32 {ImageBase :_ggfb };case 16:_afda =&NRGBA64 {ImageBase :_ggfb };};case 4:_afda =&CMYK32 {ImageBase :_ggfb };};
if _afda ==nil {return nil ,ErrInvalidImage ;};return _afda ,nil ;};func _cec (_cdaa RGBA ,_fcf NRGBA ,_fddcf _dc .Rectangle ){for _aacg :=0;_aacg < _fddcf .Max .X ;_aacg ++{for _cffe :=0;_cffe < _fddcf .Max .Y ;_cffe ++{_gecf :=_cdaa .RGBAAt (_aacg ,_cffe );
_fcf .SetNRGBA (_aacg ,_cffe ,_gea (_gecf ));};};};func (_dcbe *ImageBase )GetAlpha ()[]byte {return _dcbe .Alpha };func (_cedd *Gray8 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtGray8BPC (x ,y ,_cedd .BytesPerLine ,_cedd .Data ,_cedd .Decode );
};type colorConverter struct{_begg func (_gcg _dc .Image )(Image ,error );};func (_cacd *Gray4 )ColorModel ()_de .Model {return Gray4Model };func _fb (_af *Monochrome ,_e int )(*Monochrome ,error ){if _af ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _e ==1{return _af .copy (),nil ;};if !IsPowerOf2 (uint (_e )){return nil ,_dcg .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_e );
};_eg :=_ddbg (_e );return _cfa (_af ,_e ,_eg );};func (_beee *Gray8 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_beee .Width ,Y :_beee .Height }};};func _gdee (_adcbd CMYK ,_abcb Gray ,_fbge _dc .Rectangle ){for _abgf :=0;_abgf < _fbge .Max .X ;
_abgf ++{for _cddda :=0;_cddda < _fbge .Max .Y ;_cddda ++{_ffbc :=_eecg (_adcbd .CMYKAt (_abgf ,_cddda ));_abcb .SetGray (_abgf ,_cddda ,_ffbc );};};};func (_agb *Gray8 )ColorModel ()_de .Model {return _de .GrayModel };func _bab (_ggee _de .NRGBA64 )_de .RGBA {_cceg ,_dcbc ,_agfd ,_bffgc :=_ggee .RGBA ();
return _de .RGBA {R :uint8 (_cceg >>8),G :uint8 (_dcbc >>8),B :uint8 (_agfd >>8),A :uint8 (_bffgc >>8)};};var _ _dc .Image =&Gray2 {};func (_afaa *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_afaa .copy ()}};func (_eacd *CMYK32 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtCMYK (x ,y ,_eacd .Width ,_eacd .Data ,_eacd .Decode );
};func (_gbc *CMYK32 )CMYKAt (x ,y int )_de .CMYK {_fbee ,_ :=ColorAtCMYK (x ,y ,_gbc .Width ,_gbc .Data ,_gbc .Decode );return _fbee ;};type monochromeModel uint8 ;func (_beff *RGBA32 )ColorModel ()_de .Model {return _de .NRGBAModel };func _dcgf (_eagf _dc .Image ,_fceff Image ,_edcg _dc .Rectangle ){if _dgbd ,_ecada :=_eagf .(SMasker );
_ecada &&_dgbd .HasAlpha (){_fceff .(SMasker ).MakeAlpha ();};switch _aebd :=_eagf .(type ){case Gray :_ddac (_aebd ,_fceff .(NRGBA ),_edcg );case NRGBA :_ffag (_aebd ,_fceff .(NRGBA ),_edcg );case *_dc .NYCbCrA :_beeg (_aebd ,_fceff .(NRGBA ),_edcg );
case CMYK :_baca (_aebd ,_fceff .(NRGBA ),_edcg );case RGBA :_cec (_aebd ,_fceff .(NRGBA ),_edcg );case nrgba64 :_ddcf (_aebd ,_fceff .(NRGBA ),_edcg );default:_cdf (_eagf ,_fceff ,_edcg );};};func _addc (_egd ,_abe *Monochrome )(_bef error ){_db :=_abe .BytesPerLine ;
_dfb :=_egd .BytesPerLine ;var _ggf ,_egf ,_ffe ,_eec ,_fgd int ;for _ffe =0;_ffe < _abe .Height ;_ffe ++{_ggf =_ffe *_db ;_egf =8*_ffe *_dfb ;for _eec =0;_eec < _db ;_eec ++{if _bef =_egd .setEightBytes (_egf +_eec *8,_ffb [_abe .Data [_ggf +_eec ]]);
_bef !=nil {return _bef ;};};for _fgd =1;_fgd < 8;_fgd ++{for _eec =0;_eec < _dfb ;_eec ++{if _bef =_egd .setByte (_egf +_fgd *_dfb +_eec ,_egd .Data [_egf +_eec ]);_bef !=nil {return _bef ;};};};};return nil ;};func (_bcgg *NRGBA16 )SetNRGBA (x ,y int ,c _de .NRGBA ){_abdabf :=y *_bcgg .BytesPerLine +x *3/2;
if _abdabf +1>=len (_bcgg .Data ){return ;};c =_eecb (c );_bcgg .setNRGBA (x ,y ,_abdabf ,c );};func (_cedb *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_cedb .copy ()}};func (_cfbf *NRGBA16 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtNRGBA16 (x ,y ,_cfbf .Width ,_cfbf .BytesPerLine ,_cfbf .Data ,_cfbf .Alpha ,_cfbf .Decode );
};type Image interface{_fe .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_bfedgf ,_gdgb int )(_de .Color ,error );Validate ()error ;};func (_eggf *ImageBase )newAlpha (){_ggcf :=BytesPerLine (_eggf .Width ,_eggf .BitsPerComponent ,1);
_eggf .Alpha =make ([]byte ,_eggf .Height *_ggcf );};func (_faefe *Gray16 )Set (x ,y int ,c _de .Color ){_dbcf :=(y *_faefe .BytesPerLine /2+x )*2;if _dbcf +1>=len (_faefe .Data ){return ;};_adfd :=_de .Gray16Model .Convert (c ).(_de .Gray16 );_faefe .Data [_dbcf ],_faefe .Data [_dbcf +1]=uint8 (_adfd .Y >>8),uint8 (_adfd .Y &0xff);
};type Gray16 struct{ImageBase };func (_cdagc *NRGBA32 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_cdagc .Width ,Y :_cdagc .Height }};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_dcg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;};_fcdb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _fcdb ;};func (_gcaa *Monochrome )getBitAt (_cga ,_dff int )bool {_aedb :=_dff *_gcaa .BytesPerLine +(_cga >>3);
_bbcd :=_cga &0x07;_abaee :=uint (7-_bbcd );if _aedb > len (_gcaa .Data )-1{return false ;};if (_gcaa .Data [_aedb ]>>_abaee )&0x01>=1{return true ;};return false ;};var _ Image =&NRGBA64 {};func _abb (_gfcee _de .Gray ,_faec monochromeModel )_de .Gray {if _gfcee .Y > uint8 (_faec ){return _de .Gray {Y :_a .MaxUint8 };
};return _de .Gray {};};var _ _dc .Image =&Gray4 {};func _abab (_faff ,_ggb *Monochrome ,_gfa []byte ,_geb int )(_deb error ){var (_feg ,_afa ,_bffg ,_fge ,_afe ,_afad ,_eab ,_aef int ;_fad ,_ecb ,_ggac ,_cb uint32 ;_gfb ,_cfagf byte ;_cfad uint16 ;);_gdd :=make ([]byte ,4);
_cea :=make ([]byte ,4);for _bffg =0;_bffg < _faff .Height -1;_bffg ,_fge =_bffg +2,_fge +1{_feg =_bffg *_faff .BytesPerLine ;_afa =_fge *_ggb .BytesPerLine ;for _afe ,_afad =0,0;_afe < _geb ;_afe ,_afad =_afe +4,_afad +1{for _eab =0;_eab < 4;_eab ++{_aef =_feg +_afe +_eab ;
if _aef <=len (_faff .Data )-1&&_aef < _feg +_faff .BytesPerLine {_gdd [_eab ]=_faff .Data [_aef ];}else {_gdd [_eab ]=0x00;};_aef =_feg +_faff .BytesPerLine +_afe +_eab ;if _aef <=len (_faff .Data )-1&&_aef < _feg +(2*_faff .BytesPerLine ){_cea [_eab ]=_faff .Data [_aef ];
}else {_cea [_eab ]=0x00;};};_fad =_ab .BigEndian .Uint32 (_gdd );_ecb =_ab .BigEndian .Uint32 (_cea );_ggac =_fad &_ecb ;_ggac |=_ggac <<1;_cb =_fad |_ecb ;_cb &=_cb <<1;_ecb =_ggac &_cb ;_ecb &=0xaaaaaaaa;_fad =_ecb |(_ecb <<7);_gfb =byte (_fad >>24);
_cfagf =byte ((_fad >>8)&0xff);_aef =_afa +_afad ;if _aef +1==len (_ggb .Data )-1||_aef +1>=_afa +_ggb .BytesPerLine {if _deb =_ggb .setByte (_aef ,_gfa [_gfb ]);_deb !=nil {return _dcg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_aef );};}else {_cfad =(uint16 (_gfa [_gfb ])<<8)|uint16 (_gfa [_cfagf ]);
if _deb =_ggb .setTwoBytes (_aef ,_cfad );_deb !=nil {return _dcg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aef );
};_afad ++;};};};return nil ;};func _ebadd (_ceag []byte ,_egbec Image )error {_eaeg :=true ;for _fgce :=0;_fgce < len (_ceag );_fgce ++{if _ceag [_fgce ]!=0xff{_eaeg =false ;break ;};};if _eaeg {switch _fea :=_egbec .(type ){case *NRGBA32 :_fea .Alpha =nil ;
case *NRGBA64 :_fea .Alpha =nil ;default:return _dcg .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_egbec );
};};return nil ;};var _ _dc .Image =&NRGBA16 {};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_de .RGBA ,error ){_geda :=y *width +x ;_bedca :=3*_geda ;if _bedca +2>=len (data ){return _de .RGBA {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fcc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _geda {_fcc =alpha [_geda ];};_bgde ,_debg ,_fbfbe :=data [_bedca ],data [_bedca +1],data [_bedca +2];if len (decode )==6{_bgde =uint8 (uint32 (LinearInterpolate (float64 (_bgde ),0,255,decode [0],decode [1]))&0xff);
_debg =uint8 (uint32 (LinearInterpolate (float64 (_debg ),0,255,decode [2],decode [3]))&0xff);_fbfbe =uint8 (uint32 (LinearInterpolate (float64 (_fbfbe ),0,255,decode [4],decode [5]))&0xff);};return _de .RGBA {R :_bgde ,G :_debg ,B :_fbfbe ,A :_fcc },nil ;
};func _afg (_ddaf _de .NRGBA )_de .Gray {_gdg ,_egde ,_bfedg ,_ :=_ddaf .RGBA ();_ebbg :=(19595*_gdg +38470*_egde +7471*_bfedg +1<<15)>>24;return _de .Gray {Y :uint8 (_ebbg )};};func (_caac *RGBA32 )Set (x ,y int ,c _de .Color ){_dbdc :=y *_caac .Width +x ;
_cbba :=3*_dbdc ;if _cbba +2>=len (_caac .Data ){return ;};_gebb :=_de .RGBAModel .Convert (c ).(_de .RGBA );_caac .setRGBA (_dbdc ,_gebb );};var _ Image =&CMYK32 {};func _eggfb (_ebdae _dc .Image )(Image ,error ){if _cggb ,_fecc :=_ebdae .(*NRGBA64 );
_fecc {return _cggb .Copy (),nil ;};_ccbb ,_face ,_fbac :=_egafg (_ebdae ,2);_gded ,_ebea :=NewImage (_ccbb .Max .X ,_ccbb .Max .Y ,16,3,nil ,_fbac ,nil );if _ebea !=nil {return nil ,_ebea ;};_afdaa (_ebdae ,_gded ,_ccbb );if len (_fbac )!=0&&!_face {if _fgacf :=_ebadd (_fbac ,_gded );
_fgacf !=nil {return nil ,_fgacf ;};};return _gded ,nil ;};func _cacf (_ggba _dc .Image )(Image ,error ){if _cgec ,_bdae :=_ggba .(*Gray2 );_bdae {return _cgec .Copy (),nil ;};_febd :=_ggba .Bounds ();_bfc ,_cff :=NewImage (_febd .Max .X ,_febd .Max .Y ,2,1,nil ,nil ,nil );
if _cff !=nil {return nil ,_cff ;};_cfde (_ggba ,_bfc ,_febd );return _bfc ,nil ;};func _ba (_cd ,_ga *Monochrome )(_ee error ){_cde :=_ga .BytesPerLine ;_ca :=_cd .BytesPerLine ;var (_bd byte ;_be uint16 ;_ec ,_dec ,_fbe ,_baa ,_def int ;);for _fbe =0;
_fbe < _ga .Height ;_fbe ++{_ec =_fbe *_cde ;_dec =2*_fbe *_ca ;for _baa =0;_baa < _cde ;_baa ++{_bd =_ga .Data [_ec +_baa ];_be =_fab [_bd ];_def =_dec +_baa *2;if _cd .BytesPerLine !=_ga .BytesPerLine *2&&(_baa +1)*2> _cd .BytesPerLine {_ee =_cd .setByte (_def ,byte (_be >>8));
}else {_ee =_cd .setTwoBytes (_def ,_be );};if _ee !=nil {return _ee ;};};for _baa =0;_baa < _ca ;_baa ++{_def =_dec +_ca +_baa ;_bd =_cd .Data [_dec +_baa ];if _ee =_cd .setByte (_def ,_bd );_ee !=nil {return _ee ;};};};return nil ;};func (_fdfb *NRGBA32 )SetNRGBA (x ,y int ,c _de .NRGBA ){_ebbdc :=y *_fdfb .Width +x ;
_ddda :=3*_ebbdc ;if _ddda +2>=len (_fdfb .Data ){return ;};_fdfb .setRGBA (_ebbdc ,c );};func _cca (_fedd RGBA ,_eead Gray ,_dcfa _dc .Rectangle ){for _gegc :=0;_gegc < _dcfa .Max .X ;_gegc ++{for _cdcd :=0;_cdcd < _dcfa .Max .Y ;_cdcd ++{_aaea :=_fcef (_fedd .RGBAAt (_gegc ,_cdcd ));
_eead .SetGray (_gegc ,_cdcd ,_aaea );};};};func _cdee (_adcbde _dc .Image ,_bgee uint8 )*_dc .Gray {_febe :=_adcbde .Bounds ();_fbcb :=_dc .NewGray (_febe );var (_gfec _de .Color ;_cfdfc _de .Gray ;);for _aefg :=0;_aefg < _febe .Max .X ;_aefg ++{for _gabf :=0;
_gabf < _febe .Max .Y ;_gabf ++{_gfec =_adcbde .At (_aefg ,_gabf );_fbcb .Set (_aefg ,_gabf ,_gfec );_cfdfc =_fbcb .GrayAt (_aefg ,_gabf );_fbcb .SetGray (_aefg ,_gabf ,_de .Gray {Y :_ggaf (_cfdfc .Y ,_bgee )});};};return _fbcb ;};func (_faeag *CMYK32 )ColorModel ()_de .Model {return _de .CMYKModel };
type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_de .NRGBA ,error ){_bfaf :=y *bytesPerLine +x *3/2;
if _bfaf +1>=len (data ){return _de .NRGBA {},_dbeg (x ,y );};const (_eage =0xf;_egdde =uint8 (0xff););_gaba :=_egdde ;if alpha !=nil {_aeed :=y *BytesPerLine (width ,4,1);if _aeed < len (alpha ){if x %2==0{_gaba =(alpha [_aeed ]>>uint (4))&_eage ;}else {_gaba =alpha [_aeed ]&_eage ;
};_gaba |=_gaba <<4;};};var _aacdb ,_aaed ,_cbeef uint8 ;if x *3%2==0{_aacdb =(data [_bfaf ]>>uint (4))&_eage ;_aaed =data [_bfaf ]&_eage ;_cbeef =(data [_bfaf +1]>>uint (4))&_eage ;}else {_aacdb =data [_bfaf ]&_eage ;_aaed =(data [_bfaf +1]>>uint (4))&_eage ;
_cbeef =data [_bfaf +1]&_eage ;};if len (decode )==6{_aacdb =uint8 (uint32 (LinearInterpolate (float64 (_aacdb ),0,15,decode [0],decode [1]))&0xf);_aaed =uint8 (uint32 (LinearInterpolate (float64 (_aaed ),0,15,decode [2],decode [3]))&0xf);_cbeef =uint8 (uint32 (LinearInterpolate (float64 (_cbeef ),0,15,decode [4],decode [5]))&0xf);
};return _de .NRGBA {R :(_aacdb <<4)|(_aacdb &0xf),G :(_aaed <<4)|(_aaed &0xf),B :(_cbeef <<4)|(_cbeef &0xf),A :_gaba },nil ;};func _ddbg (_bdc int )[]uint {var _da []uint ;_bae :=_bdc ;_bbg :=_bae /8;if _bbg !=0{for _aaf :=0;_aaf < _bbg ;_aaf ++{_da =append (_da ,8);
};_bfe :=_bae %8;_bae =0;if _bfe !=0{_bae =_bfe ;};};_fae :=_bae /4;if _fae !=0{for _gfd :=0;_gfd < _fae ;_gfd ++{_da =append (_da ,4);};_fd :=_bae %4;_bae =0;if _fd !=0{_bae =_fd ;};};_egc :=_bae /2;if _egc !=0{for _decf :=0;_decf < _egc ;_decf ++{_da =append (_da ,2);
};};return _da ;};func (_afga *NRGBA32 )At (x ,y int )_de .Color {_dafa ,_ :=_afga .ColorAt (x ,y );return _dafa };func (_cee *Monochrome )At (x ,y int )_de .Color {_efed ,_ :=_cee .ColorAt (x ,y );return _efed };func (_begaa *NRGBA16 )Base ()*ImageBase {return &_begaa .ImageBase };
func _gged (_dfcg _dc .Image )(Image ,error ){if _fgf ,_bbfb :=_dfcg .(*Gray16 );_bbfb {return _fgf .Copy (),nil ;};_gbee :=_dfcg .Bounds ();_gcdf ,_febg :=NewImage (_gbee .Max .X ,_gbee .Max .Y ,16,1,nil ,nil ,nil );if _febg !=nil {return nil ,_febg ;
};_cfde (_dfcg ,_gcdf ,_gbee );return _gcdf ,nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Gray ,error ){_dgb :=y *bytesPerLine +x >>1;if _dgb >=len (data ){return _de .Gray {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bacg :=data [_dgb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bacg =uint8 (uint32 (LinearInterpolate (float64 (_bacg ),0,15,decode [0],decode [1]))&0xf);};return _de .Gray {Y :_bacg *17&0xff},nil ;};func (_bccb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_bccb .copy ()}};
func _dbcb (_abdc *Monochrome ,_gfaf ,_bege ,_eaaf ,_gddb int ,_gefb RasterOperator ,_bgeb *Monochrome ,_bafa ,_abgd int )error {var (_bfdd bool ;_eecfa bool ;_gefg int ;_bcced int ;_cdff int ;_cgcdf bool ;_bdgbf byte ;_bbee int ;_aacd int ;_cdcda int ;
_egbe ,_ggbb int ;);_ebdc :=8-(_gfaf &7);_baff :=_febf [_ebdc ];_eggbf :=_abdc .BytesPerLine *_bege +(_gfaf >>3);_cggc :=_bgeb .BytesPerLine *_abgd +(_bafa >>3);if _eaaf < _ebdc {_bfdd =true ;_baff &=_bffa [8-_ebdc +_eaaf ];};if !_bfdd {_gefg =(_eaaf -_ebdc )>>3;
if _gefg > 0{_eecfa =true ;_bcced =_eggbf +1;_cdff =_cggc +1;};};_bbee =(_gfaf +_eaaf )&7;if !(_bfdd ||_bbee ==0){_cgcdf =true ;_bdgbf =_bffa [_bbee ];_aacd =_eggbf +1+_gefg ;_cdcda =_cggc +1+_gefg ;};switch _gefb {case PixSrc :for _egbe =0;_egbe < _gddb ;
_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ],_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]=_bgeb .Data [_cdff +_ggbb ];
};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ],_bdgbf );_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;
};};case PixNotSrc :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^_bgeb .Data [_cggc ],_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;
_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]=^_bgeb .Data [_cdff +_ggbb ];};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^_bgeb .Data [_cdcda ],_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixSrcOrDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ]|_abdc .Data [_eggbf ],_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;
};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]|=_bgeb .Data [_cdff +_ggbb ];};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ]|_abdc .Data [_aacd ],_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixSrcAndDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ]&_abdc .Data [_eggbf ],_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;
};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]&=_bgeb .Data [_cdff +_ggbb ];};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ]&_abdc .Data [_aacd ],_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixSrcXorDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ]^_abdc .Data [_eggbf ],_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;
};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]^=_bgeb .Data [_cdff +_ggbb ];};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ]^_abdc .Data [_aacd ],_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixNotSrcOrDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^(_bgeb .Data [_cggc ])|_abdc .Data [_eggbf ],_baff );_eggbf +=_abdc .BytesPerLine ;
_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]|=^(_bgeb .Data [_cdff +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;
_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^(_bgeb .Data [_cdcda ])|_abdc .Data [_aacd ],_bdgbf );_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixNotSrcAndDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^(_bgeb .Data [_cggc ])&_abdc .Data [_eggbf ],_baff );
_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]&=^_bgeb .Data [_cdff +_ggbb ];};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;
};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^(_bgeb .Data [_cdcda ])&_abdc .Data [_aacd ],_bdgbf );_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixSrcOrNotDst :for _egbe =0;
_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ]|^(_abdc .Data [_eggbf ]),_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;
_ggbb ++{_abdc .Data [_bcced +_ggbb ]=_bgeb .Data [_cdff +_ggbb ]|^(_abdc .Data [_bcced +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ]|^(_abdc .Data [_aacd ]),_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixSrcAndNotDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],_bgeb .Data [_cggc ]&^(_abdc .Data [_eggbf ]),_baff );_eggbf +=_abdc .BytesPerLine ;
_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]=_bgeb .Data [_cdff +_ggbb ]&^(_abdc .Data [_bcced +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;
};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],_bgeb .Data [_cdcda ]&^(_abdc .Data [_aacd ]),_bdgbf );_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixNotPixSrcOrDst :for _egbe =0;
_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^(_bgeb .Data [_cggc ]|_abdc .Data [_eggbf ]),_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;
_ggbb ++{_abdc .Data [_bcced +_ggbb ]=^(_bgeb .Data [_cdff +_ggbb ]|_abdc .Data [_bcced +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^(_bgeb .Data [_cdcda ]|_abdc .Data [_aacd ]),_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixNotPixSrcAndDst :for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^(_bgeb .Data [_cggc ]&_abdc .Data [_eggbf ]),_baff );_eggbf +=_abdc .BytesPerLine ;
_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;_ggbb ++{_abdc .Data [_bcced +_ggbb ]=^(_bgeb .Data [_cdff +_ggbb ]&_abdc .Data [_bcced +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;
};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^(_bgeb .Data [_cdcda ]&_abdc .Data [_aacd ]),_bdgbf );_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};case PixNotPixSrcXorDst :for _egbe =0;
_egbe < _gddb ;_egbe ++{_abdc .Data [_eggbf ]=_gafc (_abdc .Data [_eggbf ],^(_bgeb .Data [_cggc ]^_abdc .Data [_eggbf ]),_baff );_eggbf +=_abdc .BytesPerLine ;_cggc +=_bgeb .BytesPerLine ;};if _eecfa {for _egbe =0;_egbe < _gddb ;_egbe ++{for _ggbb =0;_ggbb < _gefg ;
_ggbb ++{_abdc .Data [_bcced +_ggbb ]=^(_bgeb .Data [_cdff +_ggbb ]^_abdc .Data [_bcced +_ggbb ]);};_bcced +=_abdc .BytesPerLine ;_cdff +=_bgeb .BytesPerLine ;};};if _cgcdf {for _egbe =0;_egbe < _gddb ;_egbe ++{_abdc .Data [_aacd ]=_gafc (_abdc .Data [_aacd ],^(_bgeb .Data [_cdcda ]^_abdc .Data [_aacd ]),_bdgbf );
_aacd +=_abdc .BytesPerLine ;_cdcda +=_bgeb .BytesPerLine ;};};default:_c .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_gefb );return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _bf (_ad ,_cdc *Monochrome )(_fc error ){_bb :=_cdc .BytesPerLine ;_ge :=_ad .BytesPerLine ;_cad :=_cdc .BytesPerLine *4-_ad .BytesPerLine ;var (_bea ,_gba byte ;_bff uint32 ;_ff ,_dd ,_baaa ,_fgc ,_add ,_ddb ,_bgg int ;);for _baaa =0;
_baaa < _cdc .Height ;_baaa ++{_ff =_baaa *_bb ;_dd =4*_baaa *_ge ;for _fgc =0;_fgc < _bb ;_fgc ++{_bea =_cdc .Data [_ff +_fgc ];_bff =_ggfd [_bea ];_ddb =_dd +_fgc *4;if _cad !=0&&(_fgc +1)*4> _ad .BytesPerLine {for _add =_cad ;_add > 0;_add --{_gba =byte ((_bff >>uint (_add *8))&0xff);
_bgg =_ddb +(_cad -_add );if _fc =_ad .setByte (_bgg ,_gba );_fc !=nil {return _fc ;};};}else if _fc =_ad .setFourBytes (_ddb ,_bff );_fc !=nil {return _fc ;};if _fc =_ad .setFourBytes (_dd +_fgc *4,_ggfd [_cdc .Data [_ff +_fgc ]]);_fc !=nil {return _fc ;
};};for _add =1;_add < 4;_add ++{for _fgc =0;_fgc < _ge ;_fgc ++{if _fc =_ad .setByte (_dd +_add *_ge +_fgc ,_ad .Data [_dd +_fgc ]);_fc !=nil {return _fc ;};};};};return nil ;};func (_gdebd *RGBA32 )RGBAAt (x ,y int )_de .RGBA {_ecge ,_ :=ColorAtRGBA32 (x ,y ,_gdebd .Width ,_gdebd .Data ,_gdebd .Alpha ,_gdebd .Decode );
return _ecge ;};type CMYK32 struct{ImageBase };func (_aaag *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_aaag .ImageBase .copy (),ModelThreshold :_aaag .ModelThreshold };};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_faffa *NRGBA64 )ColorModel ()_de .Model {return _de .NRGBA64Model };func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_dcg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _beeg (_cbgf *_dc .NYCbCrA ,_dgge NRGBA ,_cced _dc .Rectangle ){for _abca :=0;_abca < _cced .Max .X ;_abca ++{for _eaae :=0;_eaae < _cced .Max .Y ;_eaae ++{_bbec :=_cbgf .NYCbCrAAt (_abca ,_eaae );_dgge .SetNRGBA (_abca ,_eaae ,_gfbb (_bbec ));};
};};func (_gceaa *NRGBA32 )setRGBA (_ceafc int ,_babe _de .NRGBA ){_ddbbb :=3*_ceafc ;_gceaa .Data [_ddbbb ]=_babe .R ;_gceaa .Data [_ddbbb +1]=_babe .G ;_gceaa .Data [_ddbbb +2]=_babe .B ;if _ceafc < len (_gceaa .Alpha ){_gceaa .Alpha [_ceafc ]=_babe .A ;
};};func (_dab *Gray8 )Validate ()error {if len (_dab .Data )!=_dab .Height *_dab .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gbgfd *NRGBA16 )NRGBAAt (x ,y int )_de .NRGBA {_cgbb ,_ :=ColorAtNRGBA16 (x ,y ,_gbgfd .Width ,_gbgfd .BytesPerLine ,_gbgfd .Data ,_gbgfd .Alpha ,_gbgfd .Decode );
return _cgbb ;};func (_dfgc *NRGBA64 )NRGBA64At (x ,y int )_de .NRGBA64 {_fbgd ,_ :=ColorAtNRGBA64 (x ,y ,_dfgc .Width ,_dfgc .Data ,_dfgc .Alpha ,_dfgc .Decode );return _fbgd ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};var _ _dc .Image =&Gray8 {};
func _fbag (_gfcef int ,_fcba int )int {if _gfcef < _fcba {return _gfcef ;};return _fcba ;};func _fec (_ggdb RGBA ,_adb CMYK ,_cef _dc .Rectangle ){for _bbd :=0;_bbd < _cef .Max .X ;_bbd ++{for _bggg :=0;_bggg < _cef .Max .Y ;_bggg ++{_agg :=_ggdb .RGBAAt (_bbd ,_bggg );
_adb .SetCMYK (_bbd ,_bggg ,_aec (_agg ));};};};func (_gbba *Gray4 )Set (x ,y int ,c _de .Color ){if x >=_gbba .Width ||y >=_gbba .Height {return ;};_gdfd :=Gray4Model .Convert (c ).(_de .Gray );_gbba .setGray (x ,y ,_gdfd );};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_fa :=BytesPerLine (width ,8,1);
if len (data )< _fa *height {return nil ,nil ;};_b :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_aa ,_cf :=MonochromeConverter .Convert (_b );if _cf !=nil {return nil ,_cf ;};return _aa .Base ().Data ,nil ;};func _gdb (_bfb _de .NYCbCrA )_de .RGBA {_gebf ,_faeg ,_bedf ,_gfea :=_gfbb (_bfb ).RGBA ();
return _de .RGBA {R :uint8 (_gebf >>8),G :uint8 (_faeg >>8),B :uint8 (_bedf >>8),A :uint8 (_gfea >>8)};};type Histogramer interface{Histogram ()[256]int ;};func _ffcb (_fgge *_dc .Gray )bool {for _gdca :=0;_gdca < len (_fgge .Pix );_gdca ++{if !_eadbd (_fgge .Pix [_gdca ]){return false ;
};};return true ;};func (_bgb *Monochrome )setBit (_ceg ,_debc int ){_bgb .Data [_ceg +(_debc >>3)]|=0x80>>uint (_debc &7)};func _dcgb ()(_baad [256]uint16 ){for _fce :=0;_fce < 256;_fce ++{if _fce &0x01!=0{_baad [_fce ]|=0x3;};if _fce &0x02!=0{_baad [_fce ]|=0xc;
};if _fce &0x04!=0{_baad [_fce ]|=0x30;};if _fce &0x08!=0{_baad [_fce ]|=0xc0;};if _fce &0x10!=0{_baad [_fce ]|=0x300;};if _fce &0x20!=0{_baad [_fce ]|=0xc00;};if _fce &0x40!=0{_baad [_fce ]|=0x3000;};if _fce &0x80!=0{_baad [_fce ]|=0xc000;};};return _baad ;
};var _ Gray =&Gray4 {};func _debcg (_fcdeb _de .Gray )_de .Gray {_fcdeb .Y >>=4;_fcdeb .Y |=_fcdeb .Y <<4;return _fcdeb };func (_bbce *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bbce .copy ()}};func _dafdd (_ffbe *Monochrome ,_bga ,_bbgg int ,_acgc ,_abdf int ,_dga RasterOperator ){var (_becbc bool ;
_bafe bool ;_abdca int ;_abbd int ;_cagc int ;_cfgd int ;_bad bool ;_gbgfg byte ;);_bfca :=8-(_bga &7);_abdg :=_febf [_bfca ];_agdg :=_ffbe .BytesPerLine *_bbgg +(_bga >>3);if _acgc < _bfca {_becbc =true ;_abdg &=_bffa [8-_bfca +_acgc ];};if !_becbc {_abdca =(_acgc -_bfca )>>3;
if _abdca !=0{_bafe =true ;_abbd =_agdg +1;};};_cagc =(_bga +_acgc )&7;if !(_becbc ||_cagc ==0){_bad =true ;_gbgfg =_bffa [_cagc ];_cfgd =_agdg +1+_abdca ;};var _gbbg ,_cebg int ;switch _dga {case PixClr :for _gbbg =0;_gbbg < _abdf ;_gbbg ++{_ffbe .Data [_agdg ]=_gafc (_ffbe .Data [_agdg ],0x0,_abdg );
_agdg +=_ffbe .BytesPerLine ;};if _bafe {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{for _cebg =0;_cebg < _abdca ;_cebg ++{_ffbe .Data [_abbd +_cebg ]=0x0;};_abbd +=_ffbe .BytesPerLine ;};};if _bad {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{_ffbe .Data [_cfgd ]=_gafc (_ffbe .Data [_cfgd ],0x0,_gbgfg );
_cfgd +=_ffbe .BytesPerLine ;};};case PixSet :for _gbbg =0;_gbbg < _abdf ;_gbbg ++{_ffbe .Data [_agdg ]=_gafc (_ffbe .Data [_agdg ],0xff,_abdg );_agdg +=_ffbe .BytesPerLine ;};if _bafe {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{for _cebg =0;_cebg < _abdca ;
_cebg ++{_ffbe .Data [_abbd +_cebg ]=0xff;};_abbd +=_ffbe .BytesPerLine ;};};if _bad {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{_ffbe .Data [_cfgd ]=_gafc (_ffbe .Data [_cfgd ],0xff,_gbgfg );_cfgd +=_ffbe .BytesPerLine ;};};case PixNotDst :for _gbbg =0;_gbbg < _abdf ;
_gbbg ++{_ffbe .Data [_agdg ]=_gafc (_ffbe .Data [_agdg ],^_ffbe .Data [_agdg ],_abdg );_agdg +=_ffbe .BytesPerLine ;};if _bafe {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{for _cebg =0;_cebg < _abdca ;_cebg ++{_ffbe .Data [_abbd +_cebg ]=^(_ffbe .Data [_abbd +_cebg ]);
};_abbd +=_ffbe .BytesPerLine ;};};if _bad {for _gbbg =0;_gbbg < _abdf ;_gbbg ++{_ffbe .Data [_cfgd ]=_gafc (_ffbe .Data [_cfgd ],^_ffbe .Data [_cfgd ],_gbgfg );_cfgd +=_ffbe .BytesPerLine ;};};};};var _ _dc .Image =&NRGBA64 {};func _afdaa (_faefa _dc .Image ,_gbcg Image ,_ebbge _dc .Rectangle ){if _cgcga ,_adcd :=_faefa .(SMasker );
_adcd &&_cgcga .HasAlpha (){_gbcg .(SMasker ).MakeAlpha ();};_cdf (_faefa ,_gbcg ,_ebbge );};var _ Gray =&Gray2 {};func (_fdcb *Gray16 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_fdcb .Width ,Y :_fdcb .Height }};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Gray ,error ){_cbbg :=y *bytesPerLine +x >>3;
if _cbbg >=len (data ){return _de .Gray {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgc :=data [_cbbg ]>>uint (7-(x &7))&1;if len (decode )==2{_bgc =uint8 (LinearInterpolate (float64 (_bgc ),0.0,1.0,decode [0],decode [1]))&1;};return _de .Gray {Y :_bgc *255},nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_de .CMYK ,error ){_dac :=4*(y *width +x );
if _dac +3>=len (data ){return _de .CMYK {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_dac ]&0xff;M :=data [_dac +1]&0xff;Y :=data [_dac +2]&0xff;K :=data [_dac +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _de .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _cdf (_fbf _dc .Image ,_fda Image ,_cdd _dc .Rectangle ){for _ged :=0;
_ged < _cdd .Max .X ;_ged ++{for _cbf :=0;_cbf < _cdd .Max .Y ;_cbf ++{_bac :=_fbf .At (_ged ,_cbf );_fda .Set (_ged ,_cbf ,_bac );};};};var _ NRGBA =&NRGBA32 {};func _ddcf (_efaae nrgba64 ,_cbfd NRGBA ,_adg _dc .Rectangle ){for _fecg :=0;_fecg < _adg .Max .X ;
_fecg ++{for _feec :=0;_feec < _adg .Max .Y ;_feec ++{_addb :=_efaae .NRGBA64At (_fecg ,_feec );_cbfd .SetNRGBA (_fecg ,_feec ,_bdef (_addb ));};};};func (_dgcd *NRGBA32 )ColorModel ()_de .Model {return _de .NRGBAModel };type Gray4 struct{ImageBase };func _cfgc (_eedb _de .NRGBA )_de .CMYK {_gaa ,_bgd ,_faae ,_ :=_eedb .RGBA ();
_afb ,_edc ,_edd ,_gde :=_de .RGBToCMYK (uint8 (_gaa >>8),uint8 (_bgd >>8),uint8 (_faae >>8));return _de .CMYK {C :_afb ,M :_edc ,Y :_edd ,K :_gde };};func IsGrayImgBlackAndWhite (i *_dc .Gray )bool {return _ffcb (i )};func _ggfgd (_dfggc NRGBA ,_aafa RGBA ,_bdgce _dc .Rectangle ){for _geaaa :=0;
_geaaa < _bdgce .Max .X ;_geaaa ++{for _dgfc :=0;_dgfc < _bdgce .Max .Y ;_dgfc ++{_fbdd :=_dfggc .NRGBAAt (_geaaa ,_dgfc );_aafa .SetRGBA (_geaaa ,_dgfc ,_gfgb (_fbdd ));};};};var _ Image =&Monochrome {};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Gray ,error ){_edgg :=y *bytesPerLine +x ;
if _edgg >=len (data ){return _de .Gray {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eede :=data [_edgg ];if len (decode )==2{_eede =uint8 (uint32 (LinearInterpolate (float64 (_eede ),0,255,decode [0],decode [1]))&0xff);};return _de .Gray {Y :_eede },nil ;};func _afgf (_ddce _dc .Image )(Image ,error ){if _dea ,_fbfa :=_ddce .(*Monochrome );
_fbfa {return _dea ,nil ;};_gdde :=_ddce .Bounds ();var _deag Gray ;switch _ccegb :=_ddce .(type ){case Gray :_deag =_ccegb ;case NRGBA :_deag =&Gray8 {ImageBase :NewImageBase (_gdde .Max .X ,_gdde .Max .Y ,8,1,nil ,nil ,nil )};_becb (_deag ,_ccegb ,_gdde );
case nrgba64 :_deag =&Gray8 {ImageBase :NewImageBase (_gdde .Max .X ,_gdde .Max .Y ,8,1,nil ,nil ,nil )};_dgdd (_deag ,_ccegb ,_gdde );default:_gaf ,_cbaf :=GrayConverter .Convert (_ddce );if _cbaf !=nil {return nil ,_cbaf ;};_deag =_gaf .(Gray );};_fba ,_dge :=NewImage (_gdde .Max .X ,_gdde .Max .Y ,1,1,nil ,nil ,nil );
if _dge !=nil {return nil ,_dge ;};_aecd :=_fba .(*Monochrome );_ggc :=AutoThresholdTriangle (GrayHistogram (_deag ));for _dgf :=0;_dgf < _gdde .Max .X ;_dgf ++{for _fbg :=0;_fbg < _gdde .Max .Y ;_fbg ++{_dddc :=_abb (_deag .GrayAt (_dgf ,_fbg ),monochromeModel (_ggc ));
_aecd .SetGray (_dgf ,_fbg ,_dddc );};};return _fba ,nil ;};func (_efcf *Gray8 )At (x ,y int )_de .Color {_fcbc ,_ :=_efcf .ColorAt (x ,y );return _fcbc };func _cab (_ababb _de .NRGBA64 )_de .Gray {var _dbb _de .NRGBA64 ;if _ababb ==_dbb {return _de .Gray {Y :0xff};
};_daa ,_cfadg ,_ecba ,_ :=_ababb .RGBA ();_dee :=(19595*_daa +38470*_cfadg +7471*_ecba +1<<15)>>24;return _de .Gray {Y :uint8 (_dee )};};func _eggc (_baba *_dc .Gray ,_ceeag uint8 )*_dc .Gray {_bfcd :=_baba .Bounds ();_cgag :=_dc .NewGray (_bfcd );for _bdebe :=0;
_bdebe < _bfcd .Dx ();_bdebe ++{for _bede :=0;_bede < _bfcd .Dy ();_bede ++{_bgba :=_baba .GrayAt (_bdebe ,_bede );_cgag .SetGray (_bdebe ,_bede ,_de .Gray {Y :_ggaf (_bgba .Y ,_ceeag )});};};return _cgag ;};var _ Image =&NRGBA32 {};func (_becc *NRGBA64 )Set (x ,y int ,c _de .Color ){_cedde :=(y *_becc .Width +x )*2;
_geff :=_cedde *3;if _geff +5>=len (_becc .Data ){return ;};_cddf :=_de .NRGBA64Model .Convert (c ).(_de .NRGBA64 );_becc .setNRGBA64 (_geff ,_cddf ,_cedde );};func (_cbeea *Monochrome )ResolveDecode ()error {if len (_cbeea .Decode )!=2{return nil ;};if _cbeea .Decode [0]==1&&_cbeea .Decode [1]==0{if _becbd :=_cbeea .InverseData ();
_becbd !=nil {return _becbd ;};_cbeea .Decode =nil ;};return nil ;};var _ Image =&Gray16 {};func (_agaf *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_agaf .copy ()}};func (_gcfb *monochromeThresholdConverter )Convert (img _dc .Image )(Image ,error ){if _deeg ,_ffdc :=img .(*Monochrome );
_ffdc {return _deeg .Copy (),nil ;};_adba :=img .Bounds ();_fafg ,_bdeb :=NewImage (_adba .Max .X ,_adba .Max .Y ,1,1,nil ,nil ,nil );if _bdeb !=nil {return nil ,_bdeb ;};_fafg .(*Monochrome ).ModelThreshold =_gcfb .Threshold ;for _ddae :=0;_ddae < _adba .Max .X ;
_ddae ++{for _befe :=0;_befe < _adba .Max .Y ;_befe ++{_gfeb :=img .At (_ddae ,_befe );_fafg .Set (_ddae ,_befe ,_gfeb );};};return _fafg ,nil ;};func (_bbf *CMYK32 )Base ()*ImageBase {return &_bbf .ImageBase };func (_egg *Monochrome )GrayAt (x ,y int )_de .Gray {_cgca ,_ :=ColorAtGray1BPC (x ,y ,_egg .BytesPerLine ,_egg .Data ,_egg .Decode );
return _cgca ;};func _dbgbg (_bcce ,_agcc Gray ,_dgbe _dc .Rectangle ){for _edec :=0;_edec < _dgbe .Max .X ;_edec ++{for _gafe :=0;_gafe < _dgbe .Max .Y ;_gafe ++{_agcc .SetGray (_edec ,_gafe ,_bcce .GrayAt (_edec ,_gafe ));};};};func (_ccfe *Gray16 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtGray16BPC (x ,y ,_ccfe .BytesPerLine ,_ccfe .Data ,_ccfe .Decode );
};type ColorConverter interface{Convert (_abcc _dc .Image )(Image ,error );};func (_fdc *Monochrome )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_fdc .Width ,Y :_fdc .Height }};};func (_baaag *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_baaag .copy ()}};
type RGBA interface{RGBAAt (_agab ,_cbgd int )_de .RGBA ;SetRGBA (_eece ,_afc int ,_eedf _de .RGBA );};func _acda (_gddc *Monochrome ,_afab ,_eaf ,_fddf ,_ggcc int ,_cege RasterOperator ,_dgcc *Monochrome ,_cccc ,_bbeg int )error {var (_cbcb bool ;_cddb bool ;
_ccg byte ;_gee int ;_aeee int ;_gdfe int ;_dgdf int ;_ebcb bool ;_cffa int ;_ebcac int ;_bfa int ;_decfb bool ;_caea byte ;_ecda int ;_abaca int ;_ffdf int ;_edcb byte ;_bbfbc int ;_bdacd int ;_bfae uint ;_efb uint ;_fabf byte ;_aegc shift ;_edbf bool ;
_fgeg bool ;_ecad ,_gaab int ;);if _cccc &7!=0{_bdacd =8-(_cccc &7);};if _afab &7!=0{_aeee =8-(_afab &7);};if _bdacd ==0&&_aeee ==0{_fabf =_febf [0];}else {if _aeee > _bdacd {_bfae =uint (_aeee -_bdacd );}else {_bfae =uint (8-(_bdacd -_aeee ));};_efb =8-_bfae ;
_fabf =_febf [_bfae ];};if (_afab &7)!=0{_cbcb =true ;_gee =8-(_afab &7);_ccg =_febf [_gee ];_gdfe =_gddc .BytesPerLine *_eaf +(_afab >>3);_dgdf =_dgcc .BytesPerLine *_bbeg +(_cccc >>3);_bbfbc =8-(_cccc &7);if _gee > _bbfbc {_aegc =_eee ;if _fddf >=_bdacd {_edbf =true ;
};}else {_aegc =_befcf ;};};if _fddf < _gee {_cddb =true ;_ccg &=_bffa [8-_gee +_fddf ];};if !_cddb {_cffa =(_fddf -_gee )>>3;if _cffa !=0{_ebcb =true ;_ebcac =_gddc .BytesPerLine *_eaf +((_afab +_aeee )>>3);_bfa =_dgcc .BytesPerLine *_bbeg +((_cccc +_aeee )>>3);
};};_ecda =(_afab +_fddf )&7;if !(_cddb ||_ecda ==0){_decfb =true ;_caea =_bffa [_ecda ];_abaca =_gddc .BytesPerLine *_eaf +((_afab +_aeee )>>3)+_cffa ;_ffdf =_dgcc .BytesPerLine *_bbeg +((_cccc +_aeee )>>3)+_cffa ;if _ecda > int (_efb ){_fgeg =true ;};
};switch _cege {case PixSrc :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb ,_ccg );
_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]=_edcb ;
};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb ,_caea );
_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixNotSrc :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;
};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^_edcb ,_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );
_gddc .Data [_ebcac +_gaab ]=^_edcb ;};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );
};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^_edcb ,_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixSrcOrDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );
};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb |_gddc .Data [_gdfe ],_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;
_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]|=_edcb ;};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;
_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb |_gddc .Data [_abaca ],_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;
};};case PixSrcAndDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb &_gddc .Data [_gdfe ],_ccg );
_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]&=_edcb ;
};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb &_gddc .Data [_abaca ],_caea );
_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixSrcXorDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};
}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb ^_gddc .Data [_gdfe ],_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;
_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]^=_edcb ;};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;
if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb ^_gddc .Data [_abaca ],_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixNotSrcOrDst :if _cbcb {for _ecad =0;
_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^_edcb |_gddc .Data [_gdfe ],_ccg );
_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]|=^_edcb ;
};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^_edcb |_gddc .Data [_abaca ],_caea );
_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixNotSrcAndDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );
};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^_edcb &_gddc .Data [_gdfe ],_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;
_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]&=^_edcb ;};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;
_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^_edcb &_gddc .Data [_abaca ],_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;
};};case PixSrcOrNotDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb |^_gddc .Data [_gdfe ],_ccg );
_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]=_edcb |^_gddc .Data [_ebcac +_gaab ];
};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb |^_gddc .Data [_abaca ],_caea );
_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixSrcAndNotDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );
};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],_edcb &^_gddc .Data [_gdfe ],_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;
_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]=_edcb &^_gddc .Data [_ebcac +_gaab ];};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;
_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],_edcb &^_gddc .Data [_abaca ],_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^(_edcb |_gddc .Data [_gdfe ]),_ccg );
_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]=^(_edcb |_gddc .Data [_ebcac +_gaab ]);
};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^(_edcb |_gddc .Data [_abaca ]),_caea );
_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};case PixNotPixSrcAndDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );
};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^(_edcb &_gddc .Data [_gdfe ]),_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;
_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );_gddc .Data [_ebcac +_gaab ]=^(_edcb &_gddc .Data [_ebcac +_gaab ]);};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;
_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^(_edcb &_gddc .Data [_abaca ]),_caea );_abaca +=_gddc .BytesPerLine ;
_ffdf +=_dgcc .BytesPerLine ;};};case PixNotPixSrcXorDst :if _cbcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{if _aegc ==_eee {_edcb =_dgcc .Data [_dgdf ]<<_bfae ;if _edbf {_edcb =_gafc (_edcb ,_dgcc .Data [_dgdf +1]>>_efb ,_fabf );};}else {_edcb =_dgcc .Data [_dgdf ]>>_efb ;
};_gddc .Data [_gdfe ]=_gafc (_gddc .Data [_gdfe ],^(_edcb ^_gddc .Data [_gdfe ]),_ccg );_gdfe +=_gddc .BytesPerLine ;_dgdf +=_dgcc .BytesPerLine ;};};if _ebcb {for _ecad =0;_ecad < _ggcc ;_ecad ++{for _gaab =0;_gaab < _cffa ;_gaab ++{_edcb =_gafc (_dgcc .Data [_bfa +_gaab ]<<_bfae ,_dgcc .Data [_bfa +_gaab +1]>>_efb ,_fabf );
_gddc .Data [_ebcac +_gaab ]=^(_edcb ^_gddc .Data [_ebcac +_gaab ]);};_ebcac +=_gddc .BytesPerLine ;_bfa +=_dgcc .BytesPerLine ;};};if _decfb {for _ecad =0;_ecad < _ggcc ;_ecad ++{_edcb =_dgcc .Data [_ffdf ]<<_bfae ;if _fgeg {_edcb =_gafc (_edcb ,_dgcc .Data [_ffdf +1]>>_efb ,_fabf );
};_gddc .Data [_abaca ]=_gafc (_gddc .Data [_abaca ],^(_edcb ^_gddc .Data [_abaca ]),_caea );_abaca +=_gddc .BytesPerLine ;_ffdf +=_dgcc .BytesPerLine ;};};default:_c .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_cege );
return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _gfbb (_ebc _de .NYCbCrA )_de .NRGBA {_eaca :=int32 (_ebc .Y )*0x10101;
_adc :=int32 (_ebc .Cb )-128;_gggf :=int32 (_ebc .Cr )-128;_faad :=_eaca +91881*_gggf ;if uint32 (_faad )&0xff000000==0{_faad >>=8;}else {_faad =^(_faad >>31)&0xffff;};_dcfb :=_eaca -22554*_adc -46802*_gggf ;if uint32 (_dcfb )&0xff000000==0{_dcfb >>=8;
}else {_dcfb =^(_dcfb >>31)&0xffff;};_cda :=_eaca +116130*_adc ;if uint32 (_cda )&0xff000000==0{_cda >>=8;}else {_cda =^(_cda >>31)&0xffff;};return _de .NRGBA {R :uint8 (_faad >>8),G :uint8 (_dcfb >>8),B :uint8 (_cda >>8),A :_ebc .A };};func (_gdda *Gray4 )setGray (_fbb int ,_dagg int ,_adcb _de .Gray ){_ceda :=_dagg *_gdda .BytesPerLine ;
_aafe :=_ceda +(_fbb >>1);if _aafe >=len (_gdda .Data ){return ;};_bfcb :=_adcb .Y >>4;_gdda .Data [_aafe ]=(_gdda .Data [_aafe ]&(^(0xf0>>uint (4*(_fbb &1)))))|(_bfcb <<uint (4-4*(_fbb &1)));};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bacd (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_geae *Gray16 )Base ()*ImageBase {return &_geae .ImageBase };func (_bbbcc *ImageBase )setEightFullBytes (_ddfb int ,_egfc uint64 )error {if _ddfb +7> len (_bbbcc .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bbbcc .Data [_ddfb ]=byte ((_egfc &0xff00000000000000)>>56);_bbbcc .Data [_ddfb +1]=byte ((_egfc &0xff000000000000)>>48);_bbbcc .Data [_ddfb +2]=byte ((_egfc &0xff0000000000)>>40);_bbbcc .Data [_ddfb +3]=byte ((_egfc &0xff00000000)>>32);_bbbcc .Data [_ddfb +4]=byte ((_egfc &0xff000000)>>24);
_bbbcc .Data [_ddfb +5]=byte ((_egfc &0xff0000)>>16);_bbbcc .Data [_ddfb +6]=byte ((_egfc &0xff00)>>8);_bbbcc .Data [_ddfb +7]=byte (_egfc &0xff);return nil ;};func _gcc (_dcb _de .Gray )_de .NRGBA {return _de .NRGBA {R :_dcb .Y ,G :_dcb .Y ,B :_dcb .Y ,A :0xff}};
func (_ggead *NRGBA32 )Base ()*ImageBase {return &_ggead .ImageBase };func (_bcbfe *NRGBA64 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bcbfe .Width ,_bcbfe .Data ,_bcbfe .Alpha ,_bcbfe .Decode );};func _gbb (_dbc _de .Gray )_de .Gray {_fegf :=_dbc .Y >>6;
_fegf |=_fegf <<2;_dbc .Y =_fegf |_fegf <<4;return _dbc ;};func (_acad *Monochrome )copy ()*Monochrome {_cdfe :=_ffbb (_acad .Width ,_acad .Height );_cdfe .ModelThreshold =_acad .ModelThreshold ;_cdfe .Data =make ([]byte ,len (_acad .Data ));copy (_cdfe .Data ,_acad .Data );
if len (_acad .Decode )!=0{_cdfe .Decode =make ([]float64 ,len (_acad .Decode ));copy (_cdfe .Decode ,_acad .Decode );};if len (_acad .Alpha )!=0{_cdfe .Alpha =make ([]byte ,len (_acad .Alpha ));copy (_cdfe .Alpha ,_acad .Alpha );};return _cdfe ;};func MonochromeModel (threshold uint8 )_de .Model {return monochromeModel (threshold )};
func (_efe *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gcae bool ;_cdfa :=scale ;if scale < 1{_cdfa =1/scale ;_gcae =true ;};_ebcd :=NextPowerOf2 (uint (_cdfa ));if InDelta (float64 (_ebcd ),_cdfa ,0.001){if _gcae {return _efe .ReduceBinary (_cdfa );
};return _efe .ExpandBinary (int (_ebcd ));};_bbb :=int (_a .RoundToEven (float64 (_efe .Width )*scale ));_bcfd :=int (_a .RoundToEven (float64 (_efe .Height )*scale ));return _efe .ScaleLow (_bbb ,_bcfd );};var (Gray2Model =_de .ModelFunc (_fcbd );Gray4Model =_de .ModelFunc (_bcga );
NRGBA16Model =_de .ModelFunc (_fcbe ););func _fbec (_adgc nrgba64 ,_fgegf RGBA ,_ggec _dc .Rectangle ){for _gfad :=0;_gfad < _ggec .Max .X ;_gfad ++{for _fbgbe :=0;_fbgbe < _ggec .Max .Y ;_fbgbe ++{_acfcf :=_adgc .NRGBA64At (_gfad ,_fbgbe );_fgegf .SetRGBA (_gfad ,_fbgbe ,_bab (_acfcf ));
};};};func (_bedc *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_dcg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _fb (_bedc ,factor );};type NRGBA32 struct{ImageBase };func (_dfg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_dfg .copy ()}};func _ebda (_begag _dc .Image )(Image ,error ){if _fcee ,_ffadg :=_begag .(*Gray4 );_ffadg {return _fcee .Copy (),nil ;
};_fgda :=_begag .Bounds ();_gbce ,_bgdb :=NewImage (_fgda .Max .X ,_fgda .Max .Y ,4,1,nil ,nil ,nil );if _bgdb !=nil {return nil ,_bgdb ;};_cfde (_begag ,_gbce ,_fgda );return _gbce ,nil ;};var _ NRGBA =&NRGBA16 {};func (_efedd *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bacd (_efedd ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func ImgToBinary (i _dc .Image ,threshold uint8 )*_dc .Gray {switch _efac :=i .(type ){case *_dc .Gray :if _ffcb (_efac ){return _efac ;};return _eggc (_efac ,threshold );case *_dc .Gray16 :return _effb (_efac ,threshold );default:return _cdee (_efac ,threshold );
};};func (_adfc *ImageBase )setTwoBytes (_bbgc int ,_gbdbc uint16 )error {if _bbgc +1> len (_adfc .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_adfc .Data [_bbgc ]=byte ((_gbdbc &0xff00)>>8);
_adfc .Data [_bbgc +1]=byte (_gbdbc &0xff);return nil ;};func _fcge (_ggeegc _dc .Image )(Image ,error ){if _gbda ,_ccgb :=_ggeegc .(*RGBA32 );_ccgb {return _gbda .Copy (),nil ;};_ggce ,_ffcc ,_cdfeg :=_egafg (_ggeegc ,1);_acbg :=&RGBA32 {ImageBase :NewImageBase (_ggce .Max .X ,_ggce .Max .Y ,8,3,nil ,_cdfeg ,nil )};
_cbae (_ggeegc ,_acbg ,_ggce );if len (_cdfeg )!=0&&!_ffcc {if _gbef :=_ebadd (_cdfeg ,_acbg );_gbef !=nil {return nil ,_gbef ;};};return _acbg ,nil ;};func (_ccbd *NRGBA64 )Base ()*ImageBase {return &_ccbd .ImageBase };func _dddcc (_fgcb *Monochrome ,_gdcdg ,_bfgd ,_abdcd ,_dafd int ,_deg RasterOperator ){if _gdcdg < 0{_abdcd +=_gdcdg ;
_gdcdg =0;};_dcd :=_gdcdg +_abdcd -_fgcb .Width ;if _dcd > 0{_abdcd -=_dcd ;};if _bfgd < 0{_dafd +=_bfgd ;_bfgd =0;};_aegg :=_bfgd +_dafd -_fgcb .Height ;if _aegg > 0{_dafd -=_aegg ;};if _abdcd <=0||_dafd <=0{return ;};if (_gdcdg &7)==0{_dcdb (_fgcb ,_gdcdg ,_bfgd ,_abdcd ,_dafd ,_deg );
}else {_dafdd (_fgcb ,_gdcdg ,_bfgd ,_abdcd ,_dafd ,_deg );};};func _gdac (_adag ,_gbgfc RGBA ,_bbfae _dc .Rectangle ){for _fgae :=0;_fgae < _bbfae .Max .X ;_fgae ++{for _agae :=0;_agae < _bbfae .Max .Y ;_agae ++{_gbgfc .SetRGBA (_fgae ,_agae ,_adag .RGBAAt (_fgae ,_agae ));
};};};type RGBA32 struct{ImageBase };func (_bggcd *NRGBA16 )At (x ,y int )_de .Color {_bdec ,_ :=_bggcd .ColorAt (x ,y );return _bdec };func _cfe (_dda NRGBA ,_ffc CMYK ,_fadb _dc .Rectangle ){for _dfc :=0;_dfc < _fadb .Max .X ;_dfc ++{for _decb :=0;_decb < _fadb .Max .Y ;
_decb ++{_eed :=_dda .NRGBAAt (_dfc ,_decb );_ffc .SetCMYK (_dfc ,_decb ,_cfgc (_eed ));};};};type Gray2 struct{ImageBase };var _ _dc .Image =&Monochrome {};func _dcdb (_gbcf *Monochrome ,_gcfc ,_ecdad int ,_dbgc ,_ebded int ,_dbfa RasterOperator ){var (_ebcad int ;
_gegb byte ;_eega ,_ecdab int ;_gada int ;);_faca :=_dbgc >>3;_efceb :=_dbgc &7;if _efceb > 0{_gegb =_bffa [_efceb ];};_ebcad =_gbcf .BytesPerLine *_ecdad +(_gcfc >>3);switch _dbfa {case PixClr :for _eega =0;_eega < _ebded ;_eega ++{_gada =_ebcad +_eega *_gbcf .BytesPerLine ;
for _ecdab =0;_ecdab < _faca ;_ecdab ++{_gbcf .Data [_gada ]=0x0;_gada ++;};if _efceb > 0{_gbcf .Data [_gada ]=_gafc (_gbcf .Data [_gada ],0x0,_gegb );};};case PixSet :for _eega =0;_eega < _ebded ;_eega ++{_gada =_ebcad +_eega *_gbcf .BytesPerLine ;for _ecdab =0;
_ecdab < _faca ;_ecdab ++{_gbcf .Data [_gada ]=0xff;_gada ++;};if _efceb > 0{_gbcf .Data [_gada ]=_gafc (_gbcf .Data [_gada ],0xff,_gegb );};};case PixNotDst :for _eega =0;_eega < _ebded ;_eega ++{_gada =_ebcad +_eega *_gbcf .BytesPerLine ;for _ecdab =0;
_ecdab < _faca ;_ecdab ++{_gbcf .Data [_gada ]=^_gbcf .Data [_gada ];_gada ++;};if _efceb > 0{_gbcf .Data [_gada ]=_gafc (_gbcf .Data [_gada ],^_gbcf .Data [_gada ],_gegb );};};};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cbacg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _cbacg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ceba :=width *colorComponents *bitsPerComponent ;_abdab :=_cbacg *8;_fgff :=8-(_abdab -_ceba );_gef :=_g .NewReader (data );_cdccf :=_cbacg -1;_dece :=make ([]byte ,_cdccf );_bcaa :=make ([]byte ,height *_cbacg );
_ffgc :=_g .NewWriterMSB (_bcaa );var _gddde uint64 ;var _gcea error ;for _ggdbc :=0;_ggdbc < height ;_ggdbc ++{_ ,_gcea =_gef .Read (_dece );if _gcea !=nil {return nil ,_gcea ;};_ ,_gcea =_ffgc .Write (_dece );if _gcea !=nil {return nil ,_gcea ;};_gddde ,_gcea =_gef .ReadBits (byte (_fgff ));
if _gcea !=nil {return nil ,_gcea ;};_ ,_gcea =_ffgc .WriteBits (_gddde ,_fgff );if _gcea !=nil {return nil ,_gcea ;};_ffgc .FinishByte ();};return _bcaa ,nil ;};func (_cdfag *Gray2 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtGray2BPC (x ,y ,_cdfag .BytesPerLine ,_cdfag .Data ,_cdfag .Decode );
};func _eadbd (_dcba uint8 )bool {if _dcba ==0||_dcba ==255{return true ;};return false ;};func (_fbeg *ImageBase )setByte (_cebc int ,_dbdf byte )error {if _cebc > len (_fbeg .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fbeg .Data [_cebc ]=_dbdf ;return nil ;};func (_gcfe *Gray2 )Validate ()error {if len (_gcfe .Data )!=_gcfe .Height *_gcfe .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ Image =&Gray2 {};var (MonochromeConverter =ConverterFunc (_afgf );
Gray2Converter =ConverterFunc (_cacf );Gray4Converter =ConverterFunc (_ebda );GrayConverter =ConverterFunc (_ffaf );Gray16Converter =ConverterFunc (_gged );NRGBA16Converter =ConverterFunc (_cgcg );NRGBAConverter =ConverterFunc (_bgdfa );NRGBA64Converter =ConverterFunc (_eggfb );
RGBAConverter =ConverterFunc (_fcge );CMYKConverter =ConverterFunc (_gcb ););func (_abea *CMYK32 )SetCMYK (x ,y int ,c _de .CMYK ){_efd :=4*(y *_abea .Width +x );if _efd +3>=len (_abea .Data ){return ;};_abea .Data [_efd ]=c .C ;_abea .Data [_efd +1]=c .M ;
_abea .Data [_efd +2]=c .Y ;_abea .Data [_efd +3]=c .K ;};func (_cefaa *NRGBA32 )NRGBAAt (x ,y int )_de .NRGBA {_fced ,_ :=ColorAtNRGBA32 (x ,y ,_cefaa .Width ,_cefaa .Data ,_cefaa .Alpha ,_cefaa .Decode );return _fced ;};func _ddac (_gdfdb Gray ,_cgd NRGBA ,_geee _dc .Rectangle ){for _aacc :=0;
_aacc < _geee .Max .X ;_aacc ++{for _bedfc :=0;_bedfc < _geee .Max .Y ;_bedfc ++{_ggge :=_gdfdb .GrayAt (_aacc ,_bedfc );_cgd .SetNRGBA (_aacc ,_bedfc ,_gcc (_ggge ));};};};func (_fbabb *NRGBA64 )Bounds ()_dc .Rectangle {return _dc .Rectangle {Max :_dc .Point {X :_fbabb .Width ,Y :_fbabb .Height }};
};func (_egef *Gray16 )GrayAt (x ,y int )_de .Gray {_caga ,_ :=_egef .ColorAt (x ,y );return _de .Gray {Y :uint8 (_caga .(_de .Gray16 ).Y >>8)};};func (_bebb *Gray2 )GrayAt (x ,y int )_de .Gray {_efae ,_ :=ColorAtGray2BPC (x ,y ,_bebb .BytesPerLine ,_bebb .Data ,_bebb .Decode );
return _efae ;};func (_bca *ImageBase )Pix ()[]byte {return _bca .Data };func (_bgcd *Gray2 )Histogram ()(_bdfd [256]int ){for _gaag :=0;_gaag < _bgcd .Width ;_gaag ++{for _eggb :=0;_eggb < _bgcd .Height ;_eggb ++{_bdfd [_bgcd .GrayAt (_gaag ,_eggb ).Y ]++;
};};return _bdfd ;};func (_ggfg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ggfg .copy ()}};const (_eee shift =iota ;_befcf ;);func (_fdeb *NRGBA64 )Validate ()error {if len (_fdeb .Data )!=3*2*_fdeb .Width *_fdeb .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _dbeg (_beab int ,_aeb int )error {return _dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_beab ,_aeb );
};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_de .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_dcg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};type Gray8 struct{ImageBase };func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_de .Gray16 ,error ){_egaf :=(y *bytesPerLine /2+x )*2;if _egaf +1>=len (data ){return _de .Gray16 {},_dcg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dgbb :=uint16 (data [_egaf ])<<8|uint16 (data [_egaf +1]);if len (decode )==2{_dgbb =uint16 (uint64 (LinearInterpolate (float64 (_dgbb ),0,65535,decode [0],decode [1])));};return _de .Gray16 {Y :_dgbb },nil ;};func (_bgaa *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_bgaa .copy ()}};
var _ _dc .Image =&RGBA32 {};func (_efaa *NRGBA32 )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtNRGBA32 (x ,y ,_efaa .Width ,_efaa .Data ,_efaa .Alpha ,_efaa .Decode );};func (_cfca *NRGBA32 )Set (x ,y int ,c _de .Color ){_bbbf :=y *_cfca .Width +x ;
_affd :=3*_bbbf ;if _affd +2>=len (_cfca .Data ){return ;};_gadd :=_de .NRGBAModel .Convert (c ).(_de .NRGBA );_cfca .setRGBA (_bbbf ,_gadd );};func _gfgb (_ffab _de .NRGBA )_de .RGBA {_acc ,_daf ,_eadb ,_efc :=_ffab .RGBA ();return _de .RGBA {R :uint8 (_acc >>8),G :uint8 (_daf >>8),B :uint8 (_eadb >>8),A :uint8 (_efc >>8)};
};func _eba ()(_beb []byte ){_beb =make ([]byte ,256);for _faea :=0;_faea < 256;_faea ++{_agc :=byte (_faea );_beb [_agc ]=(_agc &0x01)|((_agc &0x04)>>1)|((_agc &0x10)>>2)|((_agc &0x40)>>3)|((_agc &0x02)<<3)|((_agc &0x08)<<2)|((_agc &0x20)<<1)|(_agc &0x80);
};return _beb ;};func _bdb (_ggg *Monochrome ,_eca ,_ag int )(*Monochrome ,error ){if _ggg ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _eca <=0||_ag <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _eca ==_ag {if _eca ==1{return _ggg .copy (),nil ;};if _eca ==2||_eca ==4||_eca ==8{_cfd ,_gc :=_fb (_ggg ,_eca );if _gc !=nil {return nil ,_gc ;};return _cfd ,nil ;};};_decc :=_eca *_ggg .Width ;_bcg :=_ag *_ggg .Height ;_cc :=_ffbb (_decc ,_bcg );
_ed :=_cc .BytesPerLine ;var (_fff ,_eef ,_ecg ,_aag ,_gf int ;_adf byte ;_aae error ;);for _eef =0;_eef < _ggg .Height ;_eef ++{_fff =_ag *_eef *_ed ;for _ecg =0;_ecg < _ggg .Width ;_ecg ++{if _aff :=_ggg .getBitAt (_ecg ,_eef );_aff {_gf =_eca *_ecg ;
for _aag =0;_aag < _eca ;_aag ++{_cc .setIndexedBit (_fff *8+_gf +_aag );};};};for _aag =1;_aag < _ag ;_aag ++{_ddc :=_fff +_aag *_ed ;for _bee :=0;_bee < _ed ;_bee ++{if _adf ,_aae =_cc .getByte (_fff +_bee );_aae !=nil {return nil ,_aae ;};if _aae =_cc .setByte (_ddc +_bee ,_adf );
_aae !=nil {return nil ,_aae ;};};};};return _cc ,nil ;};func (_bbbc *Gray8 )Set (x ,y int ,c _de .Color ){_cgfe :=y *_bbbc .BytesPerLine +x ;if _cgfe > len (_bbbc .Data )-1{return ;};_cfc :=_de .GrayModel .Convert (c );_bbbc .Data [_cgfe ]=_cfc .(_de .Gray ).Y ;
};func (_abda *Gray4 )Histogram ()(_edg [256]int ){for _bdgb :=0;_bdgb < _abda .Width ;_bdgb ++{for _efdf :=0;_efdf < _abda .Height ;_efdf ++{_edg [_abda .GrayAt (_bdgb ,_efdf ).Y ]++;};};return _edg ;};func _egafg (_edae _dc .Image ,_cgac int )(_dc .Rectangle ,bool ,[]byte ){_ebddd :=_edae .Bounds ();
var (_acb bool ;_gcgg []byte ;);switch _fgca :=_edae .(type ){case SMasker :_acb =_fgca .HasAlpha ();case NRGBA ,RGBA ,*_dc .RGBA64 ,nrgba64 ,*_dc .NYCbCrA :_gcgg =make ([]byte ,_ebddd .Max .X *_ebddd .Max .Y *_cgac );case *_dc .Paletted :var _ebfd bool ;
for _ ,_adcg :=range _fgca .Palette {_ecdcc ,_defc ,_fceb ,_gfee :=_adcg .RGBA ();if _ecdcc ==0&&_defc ==0&&_fceb ==0&&_gfee !=0{_ebfd =true ;break ;};};if _ebfd {_gcgg =make ([]byte ,_ebddd .Max .X *_ebddd .Max .Y *_cgac );};};return _ebddd ,_acb ,_gcgg ;
};func _fcbd (_gbd _de .Color )_de .Color {_fed :=_de .GrayModel .Convert (_gbd ).(_de .Gray );return _gbb (_fed );};func _ffaf (_cefc _dc .Image )(Image ,error ){if _decg ,_gced :=_cefc .(*Gray8 );_gced {return _decg .Copy (),nil ;};_ceea :=_cefc .Bounds ();
_fdge ,_bcff :=NewImage (_ceea .Max .X ,_ceea .Max .Y ,8,1,nil ,nil ,nil );if _bcff !=nil {return nil ,_bcff ;};_cfde (_cefc ,_fdge ,_ceea );return _fdge ,nil ;};func _eac (_afd ,_bcb *Monochrome ,_cge []byte ,_dfa int )(_ffa error ){var (_ecf ,_aga ,_fca ,_dgd ,_bdg ,_caf ,_ccc ,_dbf int ;
_gfc ,_ead ,_bec ,_fddc uint32 ;_faa ,_faac byte ;_gda uint16 ;);_gga :=make ([]byte ,4);_gag :=make ([]byte ,4);for _fca =0;_fca < _afd .Height -1;_fca ,_dgd =_fca +2,_dgd +1{_ecf =_fca *_afd .BytesPerLine ;_aga =_dgd *_bcb .BytesPerLine ;for _bdg ,_caf =0,0;
_bdg < _dfa ;_bdg ,_caf =_bdg +4,_caf +1{for _ccc =0;_ccc < 4;_ccc ++{_dbf =_ecf +_bdg +_ccc ;if _dbf <=len (_afd .Data )-1&&_dbf < _ecf +_afd .BytesPerLine {_gga [_ccc ]=_afd .Data [_dbf ];}else {_gga [_ccc ]=0x00;};_dbf =_ecf +_afd .BytesPerLine +_bdg +_ccc ;
if _dbf <=len (_afd .Data )-1&&_dbf < _ecf +(2*_afd .BytesPerLine ){_gag [_ccc ]=_afd .Data [_dbf ];}else {_gag [_ccc ]=0x00;};};_gfc =_ab .BigEndian .Uint32 (_gga );_ead =_ab .BigEndian .Uint32 (_gag );_bec =_gfc &_ead ;_bec |=_bec <<1;_fddc =_gfc |_ead ;
_fddc &=_fddc <<1;_ead =_bec |_fddc ;_ead &=0xaaaaaaaa;_gfc =_ead |(_ead <<7);_faa =byte (_gfc >>24);_faac =byte ((_gfc >>8)&0xff);_dbf =_aga +_caf ;if _dbf +1==len (_bcb .Data )-1||_dbf +1>=_aga +_bcb .BytesPerLine {if _ffa =_bcb .setByte (_dbf ,_cge [_faa ]);
_ffa !=nil {return _dcg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_dbf );};}else {_gda =(uint16 (_cge [_faa ])<<8)|uint16 (_cge [_faac ]);if _ffa =_bcb .setTwoBytes (_dbf ,_gda );_ffa !=nil {return _dcg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dbf );
};_caf ++;};};};return nil ;};func (_ecdc *NRGBA16 )Validate ()error {if len (_ecdc .Data )!=3*_ecdc .Width *_ecdc .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_bcca *Monochrome )setGray (_acac int ,_dfe _de .Gray ,_eeb int ){if _dfe .Y ==0{_bcca .clearBit (_eeb ,_acac );}else {_bcca .setGrayBit (_eeb ,_acac );};};func (_bagc *Monochrome )setIndexedBit (_cbg int ){_bagc .Data [(_cbg >>3)]|=0x80>>uint (_cbg &7)};
func (_dgcg *ImageBase )setFourBytes (_cedf int ,_abcg uint32 )error {if _cedf +3> len (_dgcg .Data )-1{return _dcg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_cedf );
};_dgcg .Data [_cedf ]=byte ((_abcg &0xff000000)>>24);_dgcg .Data [_cedf +1]=byte ((_abcg &0xff0000)>>16);_dgcg .Data [_cedf +2]=byte ((_abcg &0xff00)>>8);_dgcg .Data [_cedf +3]=byte (_abcg &0xff);return nil ;};func (_bfd *ImageBase )setEightBytes (_cggg int ,_dedb uint64 )error {_bbcde :=_bfd .BytesPerLine -(_cggg %_bfd .BytesPerLine );
if _bfd .BytesPerLine !=_bfd .Width >>3{_bbcde --;};if _bbcde >=8{return _bfd .setEightFullBytes (_cggg ,_dedb );};return _bfd .setEightPartlyBytes (_cggg ,_bbcde ,_dedb );};var _ _dc .Image =&NRGBA32 {};func _cgcg (_aea _dc .Image )(Image ,error ){if _fbgb ,_fbgbd :=_aea .(*NRGBA16 );
_fbgbd {return _fbgb .Copy (),nil ;};_agba :=_aea .Bounds ();_fdfg ,_ccfd :=NewImage (_agba .Max .X ,_agba .Max .Y ,4,3,nil ,nil ,nil );if _ccfd !=nil {return nil ,_ccfd ;};_dcgf (_aea ,_fdfg ,_agba );return _fdfg ,nil ;};var _egge [256]uint8 ;func (_ggeec *Gray2 )SetGray (x ,y int ,gray _de .Gray ){_fffc :=_gbb (gray );
_cfdf :=y *_ggeec .BytesPerLine ;_beca :=_cfdf +(x >>2);if _beca >=len (_ggeec .Data ){return ;};_cfadbf :=_fffc .Y >>6;_ggeec .Data [_beca ]=(_ggeec .Data [_beca ]&(^(0xc0>>uint (2*((x )&3)))))|(_cfadbf <<uint (6-2*(x &3)));};var _ Gray =&Monochrome {};
func GrayHistogram (g Gray )(_egbd [256]int ){switch _gfgbd :=g .(type ){case Histogramer :return _gfgbd .Histogram ();case _dc .Image :_ffccb :=_gfgbd .Bounds ();for _ddg :=0;_ddg < _ffccb .Max .X ;_ddg ++{for _fgcc :=0;_fgcc < _ffccb .Max .Y ;_fgcc ++{_egbd [g .GrayAt (_ddg ,_fgcc ).Y ]++;
};};return _egbd ;default:return [256]int {};};};func _fcde (_gff Gray ,_cbb CMYK ,_ddf _dc .Rectangle ){for _feff :=0;_feff < _ddf .Max .X ;_feff ++{for _gggg :=0;_gggg < _ddf .Max .Y ;_gggg ++{_cbe :=_gff .GrayAt (_feff ,_gggg );_cbb .SetCMYK (_feff ,_gggg ,_dacg (_cbe ));
};};};func _gdcda (_fcca CMYK ,_aaafe RGBA ,_fbeef _dc .Rectangle ){for _dgfcg :=0;_dgfcg < _fbeef .Max .X ;_dgfcg ++{for _geaf :=0;_geaf < _fbeef .Max .Y ;_geaf ++{_affb :=_fcca .CMYKAt (_dgfcg ,_geaf );_aaafe .SetRGBA (_dgfcg ,_geaf ,_dbef (_affb ));
};};};var _ Gray =&Gray16 {};type NRGBA interface{NRGBAAt (_beddd ,_efgd int )_de .NRGBA ;SetNRGBA (_dgca ,_afge int ,_ccea _de .NRGBA );};func (_cfea *Monochrome )clearBit (_eff ,_fgb int ){_cfea .Data [_eff ]&=^(0x80>>uint (_fgb &7))};func _cce (_bbcb ,_gac CMYK ,_gge _dc .Rectangle ){for _gfe :=0;
_gfe < _gge .Max .X ;_gfe ++{for _ebed :=0;_ebed < _gge .Max .Y ;_ebed ++{_gac .SetCMYK (_gfe ,_ebed ,_bbcb .CMYKAt (_gfe ,_ebed ));};};};func (_gggd *Gray4 )At (x ,y int )_de .Color {_gece ,_ :=_gggd .ColorAt (x ,y );return _gece };type nrgba64 interface{NRGBA64At (_bdgga ,_ffbca int )_de .NRGBA64 ;
SetNRGBA64 (_aaga ,_cfbcb int ,_ggedd _de .NRGBA64 );};func (_ecce *ImageBase )copy ()ImageBase {_ccb :=*_ecce ;_ccb .Data =make ([]byte ,len (_ecce .Data ));copy (_ccb .Data ,_ecce .Data );return _ccb ;};func _dacg (_abae _de .Gray )_de .CMYK {return _de .CMYK {K :0xff-_abae .Y }};
var _ Image =&Gray8 {};var _ Image =&RGBA32 {};func (_ebaa *CMYK32 )At (x ,y int )_de .Color {_gfac ,_ :=_ebaa .ColorAt (x ,y );return _gfac };func _cgcea (_eceb Gray ,_fcea RGBA ,_cbaeg _dc .Rectangle ){for _edbb :=0;_edbb < _cbaeg .Max .X ;_edbb ++{for _afeg :=0;
_afeg < _cbaeg .Max .Y ;_afeg ++{_fgga :=_eceb .GrayAt (_edbb ,_afeg );_fcea .SetRGBA (_edbb ,_afeg ,_cded (_fgga ));};};};func (_fgac *Gray8 )SetGray (x ,y int ,g _de .Gray ){_fac :=y *_fgac .BytesPerLine +x ;if _fac > len (_fgac .Data )-1{return ;};_fgac .Data [_fac ]=g .Y ;
};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _bbga (_fabgg _de .CMYK )_de .NRGBA {_cafg ,_cdfb ,_gfg :=_de .CMYKToRGB (_fabgg .C ,_fabgg .M ,_fabgg .Y ,_fabgg .K );
return _de .NRGBA {R :_cafg ,G :_cdfb ,B :_gfg ,A :0xff};};func (_efa *Gray2 )At (x ,y int )_de .Color {_dad ,_ :=_efa .ColorAt (x ,y );return _dad };func (_cfbc *Gray16 )Histogram ()(_bgea [256]int ){for _fgcf :=0;_fgcf < _cfbc .Width ;_fgcf ++{for _eceg :=0;
_eceg < _cfbc .Height ;_eceg ++{_bgea [_cfbc .GrayAt (_fgcf ,_eceg ).Y ]++;};};return _bgea ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func _cbca (_ebde *Monochrome ,_gecb ,_cfdac ,_faab ,_fdag int ,_effa RasterOperator ,_cbbc *Monochrome ,_edgd ,_fdcg int )error {var (_ebdd byte ;
_fddd int ;_ffca int ;_gegcd ,_gcgad int ;_ebad ,_dafc int ;);_fgffe :=_faab >>3;_ada :=_faab &7;if _ada > 0{_ebdd =_bffa [_ada ];};_fddd =_cbbc .BytesPerLine *_fdcg +(_edgd >>3);_ffca =_ebde .BytesPerLine *_cfdac +(_gecb >>3);switch _effa {case PixSrc :for _ebad =0;
_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=_cbbc .Data [_gegcd ];_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ],_ebdd );
};};case PixNotSrc :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=^(_cbbc .Data [_gegcd ]);_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^_cbbc .Data [_gegcd ],_ebdd );
};};case PixSrcOrDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]|=_cbbc .Data [_gegcd ];_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ]|_ebde .Data [_gcgad ],_ebdd );
};};case PixSrcAndDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]&=_cbbc .Data [_gegcd ];_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ]&_ebde .Data [_gcgad ],_ebdd );
};};case PixSrcXorDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]^=_cbbc .Data [_gegcd ];_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ]^_ebde .Data [_gcgad ],_ebdd );
};};case PixNotSrcOrDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]|=^(_cbbc .Data [_gegcd ]);_gcgad ++;_gegcd ++;
};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^(_cbbc .Data [_gegcd ])|_ebde .Data [_gcgad ],_ebdd );};};case PixNotSrcAndDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;
for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]&=^(_cbbc .Data [_gegcd ]);_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^(_cbbc .Data [_gegcd ])&_ebde .Data [_gcgad ],_ebdd );};};case PixSrcOrNotDst :for _ebad =0;
_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=_cbbc .Data [_gegcd ]|^(_ebde .Data [_gcgad ]);_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ]|^(_ebde .Data [_gcgad ]),_ebdd );
};};case PixSrcAndNotDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=_cbbc .Data [_gegcd ]&^(_ebde .Data [_gcgad ]);
_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],_cbbc .Data [_gegcd ]&^(_ebde .Data [_gcgad ]),_ebdd );};};case PixNotPixSrcOrDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;
for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=^(_cbbc .Data [_gegcd ]|_ebde .Data [_gcgad ]);_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^(_cbbc .Data [_gegcd ]|_ebde .Data [_gcgad ]),_ebdd );};};case PixNotPixSrcAndDst :for _ebad =0;
_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=^(_cbbc .Data [_gegcd ]&_ebde .Data [_gcgad ]);_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^(_cbbc .Data [_gegcd ]&_ebde .Data [_gcgad ]),_ebdd );
};};case PixNotPixSrcXorDst :for _ebad =0;_ebad < _fdag ;_ebad ++{_gegcd =_fddd +_ebad *_cbbc .BytesPerLine ;_gcgad =_ffca +_ebad *_ebde .BytesPerLine ;for _dafc =0;_dafc < _fgffe ;_dafc ++{_ebde .Data [_gcgad ]=^(_cbbc .Data [_gegcd ]^_ebde .Data [_gcgad ]);
_gcgad ++;_gegcd ++;};if _ada > 0{_ebde .Data [_gcgad ]=_gafc (_ebde .Data [_gcgad ],^(_cbbc .Data [_gegcd ]^_ebde .Data [_gcgad ]),_ebdd );};};default:_c .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_effa );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_fdac *Gray16 )At (x ,y int )_de .Color {_bfgg ,_ :=_fdac .ColorAt (x ,y );return _bfgg };
func _fabd ()(_cdcc [256]uint64 ){for _ege :=0;_ege < 256;_ege ++{if _ege &0x01!=0{_cdcc [_ege ]|=0xff;};if _ege &0x02!=0{_cdcc [_ege ]|=0xff00;};if _ege &0x04!=0{_cdcc [_ege ]|=0xff0000;};if _ege &0x08!=0{_cdcc [_ege ]|=0xff000000;};if _ege &0x10!=0{_cdcc [_ege ]|=0xff00000000;
};if _ege &0x20!=0{_cdcc [_ege ]|=0xff0000000000;};if _ege &0x40!=0{_cdcc [_ege ]|=0xff000000000000;};if _ege &0x80!=0{_cdcc [_ege ]|=0xff00000000000000;};};return _cdcc ;};func (_egb *Gray16 )Validate ()error {if len (_egb .Data )!=_egb .Height *_egb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _adbf ,_cedag ,_cadf ,_aeea int ;for _edga :=0;_edga < len (histogram );_edga ++{if histogram [_edga ]> 0{_adbf =_edga ;break ;};};if _adbf > 0{_adbf --;};for _cedbf :=255;_cedbf > 0;
_cedbf --{if histogram [_cedbf ]> 0{_aeea =_cedbf ;break ;};};if _aeea < 255{_aeea ++;};for _caed :=0;_caed < 256;_caed ++{if histogram [_caed ]> _cedag {_cadf =_caed ;_cedag =histogram [_caed ];};};var _agce bool ;if (_cadf -_adbf )< (_aeea -_cadf ){_agce =true ;
var _agbad int ;_ffce :=255;for _agbad < _ffce {_eadca :=histogram [_agbad ];histogram [_agbad ]=histogram [_ffce ];histogram [_ffce ]=_eadca ;_agbad ++;_ffce --;};_adbf =255-_aeea ;_cadf =255-_cadf ;};if _adbf ==_cadf {return uint8 (_adbf );};_ecdg :=float64 (histogram [_cadf ]);
_ggfga :=float64 (_adbf -_cadf );_abbda :=_a .Sqrt (_ecdg *_ecdg +_ggfga *_ggfga );_ecdg /=_abbda ;_ggfga /=_abbda ;_abbda =_ecdg *float64 (_adbf )+_ggfga *float64 (histogram [_adbf ]);_febgd :=_adbf ;var _gegca float64 ;for _ceff :=_adbf +1;_ceff <=_cadf ;
_ceff ++{_babd :=_ecdg *float64 (_ceff )+_ggfga *float64 (histogram [_ceff ])-_abbda ;if _babd > _gegca {_febgd =_ceff ;_gegca =_babd ;};};_febgd --;if _agce {var _fafc int ;_defg :=255;for _fafc < _defg {_cbeg :=histogram [_fafc ];histogram [_fafc ]=histogram [_defg ];
histogram [_defg ]=_cbeg ;_fafc ++;_defg --;};return uint8 (255-_febgd );};return uint8 (_febgd );};func _bcga (_eag _de .Color )_de .Color {_aac :=_de .GrayModel .Convert (_eag ).(_de .Gray );return _debcg (_aac );};func (_fdcf monochromeModel )Convert (c _de .Color )_de .Color {_bag :=_de .GrayModel .Convert (c ).(_de .Gray );
return _abb (_bag ,_fdcf );};func (_ebgg *ImageBase )MakeAlpha (){_ebgg .newAlpha ()};func _gafc (_afdg ,_ccaa ,_gdfeb byte )byte {return (_afdg &^(_gdfeb ))|(_ccaa &_gdfeb )};func (_dca *CMYK32 )Set (x ,y int ,c _de .Color ){_faef :=4*(y *_dca .Width +x );
if _faef +3>=len (_dca .Data ){return ;};_fggf :=_de .CMYKModel .Convert (c ).(_de .CMYK );_dca .Data [_faef ]=_fggf .C ;_dca .Data [_faef +1]=_fggf .M ;_dca .Data [_faef +2]=_fggf .Y ;_dca .Data [_faef +3]=_fggf .K ;};func _cfde (_ddebf _dc .Image ,_afac Image ,_dddg _dc .Rectangle ){switch _dacf :=_ddebf .(type ){case Gray :_dbgbg (_dacf ,_afac .(Gray ),_dddg );
case NRGBA :_ddfa (_dacf ,_afac .(Gray ),_dddg );case CMYK :_gdee (_dacf ,_afac .(Gray ),_dddg );case RGBA :_cca (_dacf ,_afac .(Gray ),_dddg );default:_cdf (_ddebf ,_afac ,_dddg );};};func (_bece *Monochrome )Set (x ,y int ,c _de .Color ){_gbgf :=y *_bece .BytesPerLine +x >>3;
if _gbgf > len (_bece .Data )-1{return ;};_cfeb :=_bece .ColorModel ().Convert (c ).(_de .Gray );_bece .setGray (x ,_cfeb ,_gbgf );};func (_cgc *Monochrome )ColorAt (x ,y int )(_de .Color ,error ){return ColorAtGray1BPC (x ,y ,_cgc .BytesPerLine ,_cgc .Data ,_cgc .Decode );
};func (_bcgf *Monochrome )ColorModel ()_de .Model {return MonochromeModel (_bcgf .ModelThreshold )};func _ddfa (_cbac NRGBA ,_eacg Gray ,_ecgbf _dc .Rectangle ){for _fgaf :=0;_fgaf < _ecgbf .Max .X ;_fgaf ++{for _ddaee :=0;_ddaee < _ecgbf .Max .Y ;_ddaee ++{_gfgf :=_afg (_cbac .NRGBAAt (_fgaf ,_ddaee ));
_eacg .SetGray (_fgaf ,_ddaee ,_gfgf );};};};func _dgdd (_ggcb Gray ,_ffeg nrgba64 ,_gab _dc .Rectangle ){for _aedg :=0;_aedg < _gab .Max .X ;_aedg ++{for _eaa :=0;_eaa < _gab .Max .Y ;_eaa ++{_cdg :=_cab (_ffeg .NRGBA64At (_aedg ,_eaa ));_ggcb .SetGray (_aedg ,_eaa ,_cdg );
};};};func (_aegd *RGBA32 )setRGBA (_badf int ,_bdea _de .RGBA ){_eaed :=3*_badf ;_aegd .Data [_eaed ]=_bdea .R ;_aegd .Data [_eaed +1]=_bdea .G ;_aegd .Data [_eaed +2]=_bdea .B ;if _badf < len (_aegd .Alpha ){_aegd .Alpha [_badf ]=_bdea .A ;};};func _effb (_daad *_dc .Gray16 ,_aega uint8 )*_dc .Gray {_dfbe :=_daad .Bounds ();
_dfaf :=_dc .NewGray (_dfbe );for _ddcd :=0;_ddcd < _dfbe .Dx ();_ddcd ++{for _efaf :=0;_efaf < _dfbe .Dy ();_efaf ++{_ecdgg :=_daad .Gray16At (_ddcd ,_efaf );_dfaf .SetGray (_ddcd ,_efaf ,_de .Gray {Y :_ggaf (uint8 (_ecdgg .Y /256),_aega )});};};return _dfaf ;
};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_de .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_dcg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _cbae (_aad _dc .Image ,_fgdb Image ,_cbdfd _dc .Rectangle ){if _gcgd ,_fadbc :=_aad .(SMasker );_fadbc &&_gcgd .HasAlpha (){_fgdb .(SMasker ).MakeAlpha ();};switch _cccce :=_aad .(type ){case Gray :_cgcea (_cccce ,_fgdb .(RGBA ),_cbdfd );case NRGBA :_ggfgd (_cccce ,_fgdb .(RGBA ),_cbdfd );
case *_dc .NYCbCrA :_cegf (_cccce ,_fgdb .(RGBA ),_cbdfd );case CMYK :_gdcda (_cccce ,_fgdb .(RGBA ),_cbdfd );case RGBA :_gdac (_cccce ,_fgdb .(RGBA ),_cbdfd );case nrgba64 :_fbec (_cccce ,_fgdb .(RGBA ),_cbdfd );default:_cdf (_aad ,_fgdb ,_cbdfd );};};
func (_ebbgd *RGBA32 )SetRGBA (x ,y int ,c _de .RGBA ){_fgafg :=y *_ebbgd .Width +x ;_cgab :=3*_fgafg ;if _cgab +2>=len (_ebbgd .Data ){return ;};_ebbgd .setRGBA (_fgafg ,c );};func _baca (_ggca CMYK ,_efge NRGBA ,_aege _dc .Rectangle ){for _cdcb :=0;_cdcb < _aege .Max .X ;
_cdcb ++{for _fbfcd :=0;_fbfcd < _aege .Max .Y ;_fbfcd ++{_ccac :=_ggca .CMYKAt (_cdcb ,_fbfcd );_efge .SetNRGBA (_cdcb ,_fbfcd ,_bbga (_ccac ));};};};func _bgdfa (_affg _dc .Image )(Image ,error ){if _fcab ,_fbegc :=_affg .(*NRGBA32 );_fbegc {return _fcab .Copy (),nil ;
};_gbcd ,_bgfa ,_debf :=_egafg (_affg ,1);_bdace ,_cdeb :=NewImage (_gbcd .Max .X ,_gbcd .Max .Y ,8,3,nil ,_debf ,nil );if _cdeb !=nil {return nil ,_cdeb ;};_dcgf (_affg ,_bdace ,_gbcd );if len (_debf )!=0&&!_bgfa {if _dfgg :=_ebadd (_debf ,_bdace );_dfgg !=nil {return nil ,_dfgg ;
};};return _bdace ,nil ;};var _ Image =&NRGBA16 {};func ImgToGray (i _dc .Image )*_dc .Gray {if _fag ,_fdca :=i .(*_dc .Gray );_fdca {return _fag ;};_cgeg :=i .Bounds ();_gfdec :=_dc .NewGray (_cgeg );for _gfcdf :=0;_gfcdf < _cgeg .Max .X ;_gfcdf ++{for _dddga :=0;
_dddga < _cgeg .Max .Y ;_dddga ++{_gdad :=i .At (_gfcdf ,_dddga );_gfdec .Set (_gfcdf ,_dddga ,_gdad );};};return _gfdec ;};func (_dcgc *Gray16 )ColorModel ()_de .Model {return _de .Gray16Model };func _fee (_ddbc ,_ffd *Monochrome ,_bde []byte ,_cac int )(_faf error ){var (_bed ,_aba ,_ebb ,_feb ,_ece ,_bfed ,_ea ,_ef int ;
_dfd ,_ffg uint32 ;_ce ,_ecgf byte ;_cfb uint16 ;);_dba :=make ([]byte ,4);_feee :=make ([]byte ,4);for _ebb =0;_ebb < _ddbc .Height -1;_ebb ,_feb =_ebb +2,_feb +1{_bed =_ebb *_ddbc .BytesPerLine ;_aba =_feb *_ffd .BytesPerLine ;for _ece ,_bfed =0,0;_ece < _cac ;
_ece ,_bfed =_ece +4,_bfed +1{for _ea =0;_ea < 4;_ea ++{_ef =_bed +_ece +_ea ;if _ef <=len (_ddbc .Data )-1&&_ef < _bed +_ddbc .BytesPerLine {_dba [_ea ]=_ddbc .Data [_ef ];}else {_dba [_ea ]=0x00;};_ef =_bed +_ddbc .BytesPerLine +_ece +_ea ;if _ef <=len (_ddbc .Data )-1&&_ef < _bed +(2*_ddbc .BytesPerLine ){_feee [_ea ]=_ddbc .Data [_ef ];
}else {_feee [_ea ]=0x00;};};_dfd =_ab .BigEndian .Uint32 (_dba );_ffg =_ab .BigEndian .Uint32 (_feee );_ffg |=_dfd ;_ffg |=_ffg <<1;_ffg &=0xaaaaaaaa;_dfd =_ffg |(_ffg <<7);_ce =byte (_dfd >>24);_ecgf =byte ((_dfd >>8)&0xff);_ef =_aba +_bfed ;if _ef +1==len (_ffd .Data )-1||_ef +1>=_aba +_ffd .BytesPerLine {_ffd .Data [_ef ]=_bde [_ce ];
}else {_cfb =(uint16 (_bde [_ce ])<<8)|uint16 (_bde [_ecgf ]);if _faf =_ffd .setTwoBytes (_ef ,_cfb );_faf !=nil {return _dcg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ef );
};_bfed ++;};};};return nil ;};func (_bgdf *Monochrome )Base ()*ImageBase {return &_bgdf .ImageBase };func _dbef (_ebd _de .CMYK )_de .RGBA {_bcbg ,_fbc ,_gfce :=_de .CMYKToRGB (_ebd .C ,_ebd .M ,_ebd .Y ,_ebd .K );return _de .RGBA {R :_bcbg ,G :_fbc ,B :_gfce ,A :0xff};
};func _fcbe (_dacgd _de .Color )_de .Color {_agafa :=_de .NRGBAModel .Convert (_dacgd ).(_de .NRGBA );return _eecb (_agafa );};func (_ceb *Gray8 )GrayAt (x ,y int )_de .Gray {_dadc ,_ :=ColorAtGray8BPC (x ,y ,_ceb .BytesPerLine ,_ceb .Data ,_ceb .Decode );
return _dadc ;};func (_bbgb *NRGBA64 )At (x ,y int )_de .Color {_acdc ,_ :=_bbgb .ColorAt (x ,y );return _acdc };func _cegf (_abf *_dc .NYCbCrA ,_bedg RGBA ,_dfcf _dc .Rectangle ){for _dcga :=0;_dcga < _dfcf .Max .X ;_dcga ++{for _cdge :=0;_cdge < _dfcf .Max .Y ;
_cdge ++{_fdfbb :=_abf .NYCbCrAAt (_dcga ,_cdge );_bedg .SetRGBA (_dcga ,_cdge ,_gdb (_fdfbb ));};};};func _aec (_gdf _de .RGBA )_de .CMYK {_ebg ,_geaa ,_fdf ,_afba :=_de .RGBToCMYK (_gdf .R ,_gdf .G ,_gdf .B );return _de .CMYK {C :_ebg ,M :_geaa ,Y :_fdf ,K :_afba };
};type NRGBA64 struct{ImageBase };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};