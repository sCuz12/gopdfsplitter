//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_ge "fmt";_a "github.com/unidoc/unipdf/v3/contentstream";_c "github.com/unidoc/unipdf/v3/core";_d "github.com/unidoc/unipdf/v3/internal/transform";_b "github.com/unidoc/unipdf/v3/model";_g "math";);

// GetBounds returns the bounding box of the Bezier curve.
func (_eg CubicBezierCurve )GetBounds ()_b .PdfRectangle {_ag :=_eg .P0 .X ;_ef :=_eg .P0 .X ;_ac :=_eg .P0 .Y ;_f :=_eg .P0 .Y ;for _ce :=0.0;_ce <=1.0;_ce +=0.001{Rx :=_eg .P0 .X *_g .Pow (1-_ce ,3)+_eg .P1 .X *3*_ce *_g .Pow (1-_ce ,2)+_eg .P2 .X *3*_g .Pow (_ce ,2)*(1-_ce )+_eg .P3 .X *_g .Pow (_ce ,3);
Ry :=_eg .P0 .Y *_g .Pow (1-_ce ,3)+_eg .P1 .Y *3*_ce *_g .Pow (1-_ce ,2)+_eg .P2 .Y *3*_g .Pow (_ce ,2)*(1-_ce )+_eg .P3 .Y *_g .Pow (_ce ,3);if Rx < _ag {_ag =Rx ;};if Rx > _ef {_ef =Rx ;};if Ry < _ac {_ac =Ry ;};if Ry > _f {_f =Ry ;};};_bf :=_b .PdfRectangle {};
_bf .Llx =_ag ;_bf .Lly =_ac ;_bf .Urx =_ef ;_bf .Ury =_f ;return _bf ;};

// Copy returns a clone of the Bezier path.
func (_gd CubicBezierPath )Copy ()CubicBezierPath {_fd :=CubicBezierPath {};_fd .Curves =append (_fd .Curves ,_gd .Curves ...);return _fd ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Offset shifts the Bezier path with the specified offsets.
func (_fg CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _gg ,_ff :=range _fg .Curves {_fg .Curves [_gg ]=_ff .AddOffsetXY (offX ,offY );};return _fg ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_dc CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_dc .P0 .X +=offX ;_dc .P1 .X +=offX ;_dc .P2 .X +=offX ;_dc .P3 .X +=offX ;_dc .P0 .Y +=offY ;_dc .P1 .Y +=offY ;_dc .P2 .Y +=offY ;_dc .P3 .Y +=offY ;return _dc ;};

// Magnitude returns the magnitude of the vector.
func (_dce Vector )Magnitude ()float64 {return _g .Sqrt (_g .Pow (_dce .Dx ,2.0)+_g .Pow (_dce .Dy ,2.0))};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_aca Polygon )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_aebd :=_a .NewContentCreator ();_aebd .Add_q ();_aca .FillEnabled =_aca .FillEnabled &&_aca .FillColor !=nil ;if _aca .FillEnabled {_aebd .SetNonStrokingColor (_aca .FillColor );
};_aca .BorderEnabled =_aca .BorderEnabled &&_aca .BorderColor !=nil ;if _aca .BorderEnabled {_aebd .SetStrokingColor (_aca .BorderColor );_aebd .Add_w (_aca .BorderWidth );};if len (gsName )> 1{_aebd .Add_gs (_c .PdfObjectName (gsName ));};_gce :=NewPath ();
for _ ,_ecc :=range _aca .Points {for _cea ,_bbc :=range _ecc {_gce =_gce .AppendPoint (_bbc );if _cea ==0{_aebd .Add_m (_bbc .X ,_bbc .Y );}else {_aebd .Add_l (_bbc .X ,_bbc .Y );};};_aebd .Add_h ();};if _aca .FillEnabled &&_aca .BorderEnabled {_aebd .Add_B ();
}else if _aca .FillEnabled {_aebd .Add_f ();}else if _aca .BorderEnabled {_aebd .Add_S ();};_aebd .Add_Q ();return _aebd .Bytes (),_gce .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_cc Point )Rotate (theta float64 )Point {_cbf :=_d .NewPoint (_cc .X ,_cc .Y ).Rotate (theta );return NewPoint (_cbf .X ,_cbf .Y );};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_aeg CurvePolygon )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_afa :=_a .NewContentCreator ();_afa .Add_q ();_aeg .FillEnabled =_aeg .FillEnabled &&_aeg .FillColor !=nil ;if _aeg .FillEnabled {_afa .SetNonStrokingColor (_aeg .FillColor );
};_aeg .BorderEnabled =_aeg .BorderEnabled &&_aeg .BorderColor !=nil ;if _aeg .BorderEnabled {_afa .SetStrokingColor (_aeg .BorderColor );_afa .Add_w (_aeg .BorderWidth );};if len (gsName )> 1{_afa .Add_gs (_c .PdfObjectName (gsName ));};_bgd :=NewCubicBezierPath ();
for _ ,_fdg :=range _aeg .Rings {for _fce ,_gfd :=range _fdg {if _fce ==0{_afa .Add_m (_gfd .P0 .X ,_gfd .P0 .Y );}else {_afa .Add_l (_gfd .P0 .X ,_gfd .P0 .Y );};_afa .Add_c (_gfd .P1 .X ,_gfd .P1 .Y ,_gfd .P2 .X ,_gfd .P2 .Y ,_gfd .P3 .X ,_gfd .P3 .Y );
_bgd =_bgd .AppendCurve (_gfd );};_afa .Add_h ();};if _aeg .FillEnabled &&_aeg .BorderEnabled {_afa .Add_B ();}else if _aeg .FillEnabled {_afa .Add_f ();}else if _aeg .BorderEnabled {_afa .Add_S ();};_afa .Add_Q ();return _afa .Bytes (),_bgd .GetBoundingBox ().ToPdfRectangle (),nil ;
};func (_gcb Point )String ()string {return _ge .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_gcb .X ,_gcb .Y );};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_dd CubicBezierPath )GetBoundingBox ()Rectangle {_ae :=Rectangle {};_gc :=0.0;_fdb :=0.0;_ab :=0.0;_cb :=0.0;for _efc ,_ed :=range _dd .Curves {_abd :=_ed .GetBounds ();if _efc ==0{_gc =_abd .Llx ;_fdb =_abd .Urx ;_ab =_abd .Lly ;_cb =_abd .Ury ;
continue ;};if _abd .Llx < _gc {_gc =_abd .Llx ;};if _abd .Urx > _fdb {_fdb =_abd .Urx ;};if _abd .Lly < _ab {_ab =_abd .Lly ;};if _abd .Ury > _cb {_cb =_abd .Ury ;};};_ae .X =_gc ;_ae .Y =_ab ;_ae .Width =_fdb -_gc ;_ae .Height =_cb -_ab ;return _ae ;
};

// Length returns the number of points in the path.
func (_gf Path )Length ()int {return len (_gf .Points )};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _b .PdfColor ;FillEnabled bool ;FillColor _b .PdfColor ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_bd :=CubicBezierPath {};_bd .Curves =[]CubicBezierCurve {};return _bd ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_aed Path )GetPointNumber (number int )Point {if number < 1||number > len (_aed .Points ){return Point {};};return _aed .Points [number -1];};

// FlipY flips the sign of the Dy component of the vector.
func (_egg Vector )FlipY ()Vector {_egg .Dy =-_egg .Dy ;return _egg };

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_a .ContentCreator ){for _dfc ,_gef :=range bpath .Curves {if _dfc ==0{creator .Add_m (_gef .P0 .X ,_gef .P0 .Y );};creator .Add_c (_gef .P1 .X ,_gef .P1 .Y ,_gef .P2 .X ,_gef .P2 .Y ,_gef .P3 .X ,_gef .P3 .Y );
};};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_dae :=Vector {};_dae .Dx =b .X -a .X ;_dae .Dy =b .Y -a .Y ;return _dae ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _b .PdfColor ;BorderEnabled bool ;BorderColor _b .PdfColor ;BorderWidth float64 ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_a .ContentCreator ){for _dbc ,_dgd :=range path .Points {if _dbc ==0{creator .Add_m (_dgd .X ,_dgd .Y );}else {creator .Add_l (_dgd .X ,_dgd .Y );};};};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// AddVector adds vector to a point.
func (_dda Point )AddVector (v Vector )Point {_dda .X +=v .Dx ;_dda .Y +=v .Dy ;return _dda };

// Rotate rotates the vector by the specified angle.
func (_ede Vector )Rotate (phi float64 )Vector {_egfe :=_ede .Magnitude ();_faef :=_ede .GetPolarAngle ();return NewVectorPolar (_egfe ,_faef +phi );};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;
);

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_ggd Circle )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_dcc :=_ggd .Width /2;_af :=_ggd .Height /2;if _ggd .BorderEnabled {_dcc -=_ggd .BorderWidth /2;_af -=_ggd .BorderWidth /2;};_dg :=0.551784;_cf :=_dcc *_dg ;_fff :=_af *_dg ;_cbe :=NewCubicBezierPath ();
_cbe =_cbe .AppendCurve (NewCubicBezierCurve (-_dcc ,0,-_dcc ,_fff ,-_cf ,_af ,0,_af ));_cbe =_cbe .AppendCurve (NewCubicBezierCurve (0,_af ,_cf ,_af ,_dcc ,_fff ,_dcc ,0));_cbe =_cbe .AppendCurve (NewCubicBezierCurve (_dcc ,0,_dcc ,-_fff ,_cf ,-_af ,0,-_af ));
_cbe =_cbe .AppendCurve (NewCubicBezierCurve (0,-_af ,-_cf ,-_af ,-_dcc ,-_fff ,-_dcc ,0));_cbe =_cbe .Offset (_dcc ,_af );if _ggd .BorderEnabled {_cbe =_cbe .Offset (_ggd .BorderWidth /2,_ggd .BorderWidth /2);};if _ggd .X !=0||_ggd .Y !=0{_cbe =_cbe .Offset (_ggd .X ,_ggd .Y );
};_gda :=_a .NewContentCreator ();_gda .Add_q ();if _ggd .FillEnabled {_gda .SetNonStrokingColor (_ggd .FillColor );};if _ggd .BorderEnabled {_gda .SetStrokingColor (_ggd .BorderColor );_gda .Add_w (_ggd .BorderWidth );};if len (gsName )> 1{_gda .Add_gs (_c .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_cbe ,_gda );_gda .Add_h ();if _ggd .FillEnabled &&_ggd .BorderEnabled {_gda .Add_B ();}else if _ggd .FillEnabled {_gda .Add_f ();}else if _ggd .BorderEnabled {_gda .Add_S ();};_gda .Add_Q ();_efd :=_cbe .GetBoundingBox ();
if _ggd .BorderEnabled {_efd .Height +=_ggd .BorderWidth ;_efd .Width +=_ggd .BorderWidth ;_efd .X -=_ggd .BorderWidth /2;_efd .Y -=_ggd .BorderWidth /2;};return _gda .Bytes (),_efd .ToPdfRectangle (),nil ;};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_ddad Line )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_adc ,_gff :=_ddad .X1 ,_ddad .X2 ;_edfg ,_acb :=_ddad .Y1 ,_ddad .Y2 ;_fab :=_acb -_edfg ;_dcd :=_gff -_adc ;_eac :=_g .Atan2 (_fab ,_dcd );L :=_g .Sqrt (_g .Pow (_dcd ,2.0)+_g .Pow (_fab ,2.0));
_fda :=_ddad .LineWidth ;_cab :=_g .Pi ;_gfdb :=1.0;if _dcd < 0{_gfdb *=-1.0;};if _fab < 0{_gfdb *=-1.0;};VsX :=_gfdb *(-_fda /2*_g .Cos (_eac +_cab /2));VsY :=_gfdb *(-_fda /2*_g .Sin (_eac +_cab /2)+_fda *_g .Sin (_eac +_cab /2));V1X :=VsX +_fda /2*_g .Cos (_eac +_cab /2);
V1Y :=VsY +_fda /2*_g .Sin (_eac +_cab /2);V2X :=VsX +_fda /2*_g .Cos (_eac +_cab /2)+L *_g .Cos (_eac );V2Y :=VsY +_fda /2*_g .Sin (_eac +_cab /2)+L *_g .Sin (_eac );V3X :=VsX +_fda /2*_g .Cos (_eac +_cab /2)+L *_g .Cos (_eac )+_fda *_g .Cos (_eac -_cab /2);
V3Y :=VsY +_fda /2*_g .Sin (_eac +_cab /2)+L *_g .Sin (_eac )+_fda *_g .Sin (_eac -_cab /2);V4X :=VsX +_fda /2*_g .Cos (_eac -_cab /2);V4Y :=VsY +_fda /2*_g .Sin (_eac -_cab /2);_gdg :=NewPath ();_gdg =_gdg .AppendPoint (NewPoint (V1X ,V1Y ));_gdg =_gdg .AppendPoint (NewPoint (V2X ,V2Y ));
_gdg =_gdg .AppendPoint (NewPoint (V3X ,V3Y ));_gdg =_gdg .AppendPoint (NewPoint (V4X ,V4Y ));_ddac :=_ddad .LineEndingStyle1 ;_bbf :=_ddad .LineEndingStyle2 ;_eba :=3*_fda ;_efe :=3*_fda ;_gag :=(_efe -_fda )/2;if _bbf ==LineEndingStyleArrow {_gdc :=_gdg .GetPointNumber (2);
_cca :=NewVectorPolar (_eba ,_eac +_cab );_fea :=_gdc .AddVector (_cca );_ddea :=NewVectorPolar (_efe /2,_eac +_cab /2);_gcec :=NewVectorPolar (_eba ,_eac );_cd :=NewVectorPolar (_gag ,_eac +_cab /2);_ba :=_fea .AddVector (_cd );_dec :=_gcec .Add (_ddea .Flip ());
_ffg :=_ba .AddVector (_dec );_bfe :=_ddea .Scale (2).Flip ().Add (_dec .Flip ());_eccd :=_ffg .AddVector (_bfe );_dfg :=_fea .AddVector (NewVectorPolar (_fda ,_eac -_cab /2));_cac :=NewPath ();_cac =_cac .AppendPoint (_gdg .GetPointNumber (1));_cac =_cac .AppendPoint (_fea );
_cac =_cac .AppendPoint (_ba );_cac =_cac .AppendPoint (_ffg );_cac =_cac .AppendPoint (_eccd );_cac =_cac .AppendPoint (_dfg );_cac =_cac .AppendPoint (_gdg .GetPointNumber (4));_gdg =_cac ;};if _ddac ==LineEndingStyleArrow {_da :=_gdg .GetPointNumber (1);
_aae :=_gdg .GetPointNumber (_gdg .Length ());_edfe :=NewVectorPolar (_fda /2,_eac +_cab +_cab /2);_bgb :=_da .AddVector (_edfe );_dbb :=NewVectorPolar (_eba ,_eac ).Add (NewVectorPolar (_efe /2,_eac +_cab /2));_aag :=_bgb .AddVector (_dbb );_egca :=NewVectorPolar (_gag ,_eac -_cab /2);
_dbbe :=_aag .AddVector (_egca );_cce :=NewVectorPolar (_eba ,_eac );_daf :=_aae .AddVector (_cce );_bdc :=NewVectorPolar (_gag ,_eac +_cab +_cab /2);_aac :=_daf .AddVector (_bdc );_ega :=_bgb ;_cdd :=NewPath ();_cdd =_cdd .AppendPoint (_bgb );_cdd =_cdd .AppendPoint (_aag );
_cdd =_cdd .AppendPoint (_dbbe );for _ ,_ece :=range _gdg .Points [1:len (_gdg .Points )-1]{_cdd =_cdd .AppendPoint (_ece );};_cdd =_cdd .AppendPoint (_daf );_cdd =_cdd .AppendPoint (_aac );_cdd =_cdd .AppendPoint (_ega );_gdg =_cdd ;};_fdab :=_a .NewContentCreator ();
_fdab .Add_q ().SetNonStrokingColor (_ddad .LineColor );if len (gsName )> 1{_fdab .Add_gs (_c .PdfObjectName (gsName ));};_gdg =_gdg .Offset (_ddad .X1 ,_ddad .Y1 );_baf :=_gdg .GetBoundingBox ();DrawPathWithCreator (_gdg ,_fdab );if _ddad .LineStyle ==LineStyleDashed {_fdab .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_fdab .Add_f ().Add_Q ();};return _fdab .Bytes (),_baf .ToPdfRectangle (),nil ;};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_de Path )RemovePoint (number int )Path {if number < 1||number > len (_de .Points ){return _de ;};_fb :=number -1;_de .Points =append (_de .Points [:_fb ],_de .Points [_fb +1:]...);return _de ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _b .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;DashArray []int64 ;DashPhase int64 ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_ec BoundingBox )ToPdfRectangle ()*_b .PdfRectangle {return &_b .PdfRectangle {Llx :_ec .X ,Lly :_ec .Y ,Urx :_ec .X +_ec .Width ,Ury :_ec .Y +_ec .Height };};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _b .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _b .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_ffe Point )Add (dx ,dy float64 )Point {_ffe .X +=dx ;_ffe .Y +=dy ;return _ffe };

// Offset shifts the path with the specified offsets.
func (_aba Path )Offset (offX ,offY float64 )Path {for _fbd ,_df :=range _aba .Points {_aba .Points [_fbd ]=_df .Add (offX ,offY );};return _aba ;};

// FlipX flips the sign of the Dx component of the vector.
func (_ecd Vector )FlipX ()Vector {_ecd .Dx =-_ecd .Dx ;return _ecd };

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_bag :=Vector {};_bag .Dx =dx ;_bag .Dy =dy ;return _bag };

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_fe Rectangle )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_fac :=_a .NewContentCreator ();_fac .Add_q ();if _fe .FillEnabled {_fac .SetNonStrokingColor (_fe .FillColor );};if _fe .BorderEnabled {_fac .SetStrokingColor (_fe .BorderColor );
_fac .Add_w (_fe .BorderWidth );};if len (gsName )> 1{_fac .Add_gs (_c .PdfObjectName (gsName ));};var (_aee ,_gab =_fe .X ,_fe .Y ;_fae ,_ceb =_fe .Width ,_fe .Height ;_bga =_g .Abs (_fe .BorderRadiusTopLeft );_fcd =_g .Abs (_fe .BorderRadiusTopRight );
_edf =_g .Abs (_fe .BorderRadiusBottomLeft );_aa =_g .Abs (_fe .BorderRadiusBottomRight );_cbg =0.4477;);_ca :=Path {Points :[]Point {{X :_aee +_fae -_aa ,Y :_gab },{X :_aee +_fae ,Y :_gab +_ceb -_fcd },{X :_aee +_bga ,Y :_gab +_ceb },{X :_aee ,Y :_gab +_edf }}};
_cbfa :=[][7]float64 {{_aa ,_aee +_fae -_aa *_cbg ,_gab ,_aee +_fae ,_gab +_aa *_cbg ,_aee +_fae ,_gab +_aa },{_fcd ,_aee +_fae ,_gab +_ceb -_fcd *_cbg ,_aee +_fae -_fcd *_cbg ,_gab +_ceb ,_aee +_fae -_fcd ,_gab +_ceb },{_bga ,_aee +_bga *_cbg ,_gab +_ceb ,_aee ,_gab +_ceb -_bga *_cbg ,_aee ,_gab +_ceb -_bga },{_edf ,_aee ,_gab +_edf *_cbg ,_aee +_edf *_cbg ,_gab ,_aee +_edf ,_gab }};
_fac .Add_m (_aee +_edf ,_gab );for _ea :=0;_ea < 4;_ea ++{_bgc :=_ca .Points [_ea ];_fac .Add_l (_bgc .X ,_bgc .Y );_aebb :=_cbfa [_ea ];if _geg :=_aebb [0];_geg !=0{_fac .Add_c (_aebb [1],_aebb [2],_aebb [3],_aebb [4],_aebb [5],_aebb [6]);};};_fac .Add_h ();
if _fe .FillEnabled &&_fe .BorderEnabled {_fac .Add_B ();}else if _fe .FillEnabled {_fac .Add_f ();}else if _fe .BorderEnabled {_fac .Add_S ();};_fac .Add_Q ();return _fac .Bytes (),_ca .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_fa PolyBezierCurve )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){if _fa .BorderColor ==nil {_fa .BorderColor =_b .NewPdfColorDeviceRGB (0,0,0);};_agd :=NewCubicBezierPath ();for _ ,_edb :=range _fa .Curves {_agd =_agd .AppendCurve (_edb );
};_bgf :=_a .NewContentCreator ();_bgf .Add_q ();_fa .FillEnabled =_fa .FillEnabled &&_fa .FillColor !=nil ;if _fa .FillEnabled {_bgf .SetNonStrokingColor (_fa .FillColor );};_bgf .SetStrokingColor (_fa .BorderColor );_bgf .Add_w (_fa .BorderWidth );if len (gsName )> 1{_bgf .Add_gs (_c .PdfObjectName (gsName ));
};for _faf ,_bb :=range _agd .Curves {if _faf ==0{_bgf .Add_m (_bb .P0 .X ,_bb .P0 .Y );}else {_bgf .Add_l (_bb .P0 .X ,_bb .P0 .Y );};_bgf .Add_c (_bb .P1 .X ,_bb .P1 .Y ,_bb .P2 .X ,_bb .P2 .Y ,_bb .P3 .X ,_bb .P3 .Y );};if _fa .FillEnabled {_bgf .Add_h ();
_bgf .Add_B ();}else {_bgf .Add_S ();};_bgf .Add_Q ();return _bgf .Bytes (),_agd .GetBoundingBox ().ToPdfRectangle (),nil ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _b .PdfColor ;BorderEnabled bool ;BorderColor _b .PdfColor ;BorderWidth float64 ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_efg :=Vector {};_efg .Dx =length *_g .Cos (theta );_efg .Dy =length *_g .Sin (theta );return _efg ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_ee CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_ee .Curves =append (_ee .Curves ,curve );return _ee ;};

// Flip changes the sign of the vector: -vector.
func (_ggf Vector )Flip ()Vector {_age :=_ggf .Magnitude ();_cbc :=_ggf .GetPolarAngle ();_ggf .Dx =_age *_g .Cos (_cbc +_g .Pi );_ggf .Dy =_age *_g .Sin (_cbc +_g .Pi );return _ggf ;};

// AppendPoint adds the specified point to the path.
func (_egc Path )AppendPoint (point Point )Path {_egc .Points =append (_egc .Points ,point );return _egc };

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// GetBoundingBox returns the bounding box of the path.
func (_dde Path )GetBoundingBox ()BoundingBox {_ad :=BoundingBox {};_ga :=0.0;_fc :=0.0;_eea :=0.0;_agc :=0.0;for _aeb ,_ggc :=range _dde .Points {if _aeb ==0{_ga =_ggc .X ;_fc =_ggc .X ;_eea =_ggc .Y ;_agc =_ggc .Y ;continue ;};if _ggc .X < _ga {_ga =_ggc .X ;
};if _ggc .X > _fc {_fc =_ggc .X ;};if _ggc .Y < _eea {_eea =_ggc .Y ;};if _ggc .Y > _agc {_agc =_ggc .Y ;};};_ad .X =_ga ;_ad .Y =_eea ;_ad .Width =_fc -_ga ;_ad .Height =_agc -_eea ;return _ad ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_gb :=CubicBezierCurve {};_gb .P0 =NewPoint (x0 ,y0 );_gb .P1 =NewPoint (x1 ,y1 );_gb .P2 =NewPoint (x2 ,y2 );_gb .P3 =NewPoint (x3 ,y3 );return _gb ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_cee Vector )GetPolarAngle ()float64 {return _g .Atan2 (_cee .Dy ,_cee .Dx )};

// Scale scales the vector by the specified factor.
func (_dgg Vector )Scale (factor float64 )Vector {_fdf :=_dgg .Magnitude ();_dafb :=_dgg .GetPolarAngle ();_dgg .Dx =factor *_fdf *_g .Cos (_dafb );_dgg .Dy =factor *_fdf *_g .Sin (_dafb );return _dgg ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _b .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _b .PdfColor ;LineWidth float64 ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_be Rectangle )ToPdfRectangle ()*_b .PdfRectangle {return &_b .PdfRectangle {Llx :_be .X ,Lly :_be .Y ,Urx :_be .X +_be .Width ,Ury :_be .Y +_be .Height };};

// Add adds the specified vector to the current one and returns the result.
func (_egf Vector )Add (other Vector )Vector {_egf .Dx +=other .Dx ;_egf .Dy +=other .Dy ;return _egf };

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_eag Polyline )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){if _eag .LineColor ==nil {_eag .LineColor =_b .NewPdfColorDeviceRGB (0,0,0);};_egcd :=NewPath ();for _ ,_egaa :=range _eag .Points {_egcd =_egcd .AppendPoint (_egaa );};_fcf :=_a .NewContentCreator ();
_fcf .Add_q ().SetStrokingColor (_eag .LineColor ).Add_w (_eag .LineWidth );if len (gsName )> 1{_fcf .Add_gs (_c .PdfObjectName (gsName ));};DrawPathWithCreator (_egcd ,_fcf );_fcf .Add_S ();_fcf .Add_Q ();return _fcf .Bytes (),_egcd .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _b .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _b .PdfColor ;Opacity float64 ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_bac BasicLine )Draw (gsName string )([]byte ,*_b .PdfRectangle ,error ){_cbd :=NewPath ();_cbd =_cbd .AppendPoint (NewPoint (_bac .X1 ,_bac .Y1 ));_cbd =_cbd .AppendPoint (NewPoint (_bac .X2 ,_bac .Y2 ));_gea :=_a .NewContentCreator ();_gea .Add_q ().Add_w (_bac .LineWidth ).SetStrokingColor (_bac .LineColor );
if _bac .LineStyle ==LineStyleDashed {if _bac .DashArray ==nil {_bac .DashArray =[]int64 {1,1};};_gea .Add_d (_bac .DashArray ,_bac .DashPhase );};if len (gsName )> 1{_gea .Add_gs (_c .PdfObjectName (gsName ));};DrawPathWithCreator (_cbd ,_gea );_gea .Add_S ().Add_Q ();
return _gea .Bytes (),_cbd .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Copy returns a clone of the path.
func (_dea Path )Copy ()Path {_bg :=Path {};_bg .Points =append (_bg .Points ,_dea .Points ...);return _bg ;};