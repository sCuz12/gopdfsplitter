//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_ef "bytes";_f "encoding/xml";_e "errors";_g "fmt";_ab "github.com/gorilla/i18n/linebreak";_ff "github.com/unidoc/unichart/render";_eef "github.com/unidoc/unipdf/v3/common";_bd "github.com/unidoc/unipdf/v3/contentstream";_ce "github.com/unidoc/unipdf/v3/contentstream/draw";
_ea "github.com/unidoc/unipdf/v3/core";_ga "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_ffe "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_ae "github.com/unidoc/unipdf/v3/internal/license";_de "github.com/unidoc/unipdf/v3/internal/transform";
_fa "github.com/unidoc/unipdf/v3/model";_b "golang.org/x/text/unicode/bidi";_cd "image";_dfd "io";_ec "math";_df "os";_ee "regexp";_d "sort";_a "strconv";_dc "strings";_cb "text/template";_efe "unicode";);func (_bdef *Image )rotatedSize ()(float64 ,float64 ){_bdgag :=_bdef ._gfef ;
_bdgc :=_bdef ._ffab ;_cdbbd :=_bdef ._dgb ;if _cdbbd ==0{return _bdgag ,_bdgc ;};_fgdf :=_ce .Path {Points :[]_ce .Point {_ce .NewPoint (0,0).Rotate (_cdbbd ),_ce .NewPoint (_bdgag ,0).Rotate (_cdbbd ),_ce .NewPoint (0,_bdgc ).Rotate (_cdbbd ),_ce .NewPoint (_bdgag ,_bdgc ).Rotate (_cdbbd )}}.GetBoundingBox ();
return _fgdf .Width ,_fgdf .Height ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_dbefd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_ceac :=&_dbefd ._bagf ._faaba ;return _dbefd ._fdbdf ,_ceac .Right ,_ceac .Top ,_ceac .Bottom ;};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_fdba *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dagfb (x1 ,y1 ,x2 ,y2 )};

// SetSideBorderColor sets the cell's side border color.
func (_dbcfe *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_dbcfe ._bbcfdd =col ;_dbcfe ._cfaea =col ;_dbcfe ._cgce =col ;_dbcfe ._egddb =col ;case CellBorderSideTop :_dbcfe ._bbcfdd =col ;case CellBorderSideBottom :_dbcfe ._cfaea =col ;
case CellBorderSideLeft :_dbcfe ._cgce =col ;case CellBorderSideRight :_dbcfe ._egddb =col ;};};

// SetCoords sets the center coordinates of the ellipse.
func (_cafa *Ellipse )SetCoords (xc ,yc float64 ){_cafa ._fgcb =xc ;_cafa ._eadb =yc };func _dggdf (_gggf *templateProcessor ,_edcbe *templateNode )(interface{},error ){return _gggf .parseRectangle (_edcbe );};func (_ddef *templateProcessor )parseFontAttr (_gaaeg ,_bacg string )*_fa .PdfFont {_eef .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gaaeg ,_bacg );
_dfgda :=_ddef .creator ._aebd ;if _bacg ==""{return _dfgda ;};_dbedg :=_dc .Split (_bacg ,"\u002c");for _ ,_edcbc :=range _dbedg {_edcbc =_dc .TrimSpace (_edcbc );if _edcbc ==""{continue ;};_ccga ,_fedb :=_ddef ._cbdga .FontMap [_bacg ];if _fedb {return _ccga ;
};_adfc ,_fedb :=map[string ]_fa .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_fa .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_fa .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_fa .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_fa .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_fa .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_fa .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_fa .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_fa .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_fa .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_fa .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_fa .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_fa .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_fa .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_fa .TimesBoldItalicName }[_bacg ];
if _fedb {if _babge ,_ebbgg :=_fa .NewStandard14Font (_adfc );_ebbgg ==nil {return _babge ;};};if _bgfe :=_ddef .parseAttrPropList (_edcbc );len (_bgfe )> 0{if _dgagg ,_eeee :=_bgfe ["\u0070\u0061\u0074\u0068"];_eeee {_aaae :=_fa .NewPdfFontFromTTFFile ;
if _ffcef ,_ebef :=_bgfe ["\u0074\u0079\u0070\u0065"];_ebef &&_ffcef =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_aaae =_fa .NewCompositePdfFontFromTTFFile ;};if _afggc ,_dbacc :=_aaae (_dgagg );_dbacc !=nil {_eef .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_dgagg ,_dbacc );
}else {return _afggc ;};};};};return _dfgda ;};

// SetHeight sets the height of the rectangle.
func (_fcce *Rectangle )SetHeight (height float64 ){_fcce ._baag =height };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gedg *TOC )SetLinePageStyle (style TextStyle ){_gedg ._dbdbc =style };func (_gcgb *templateProcessor )parseMarginAttr (_ecabc ,_ggec string )Margins {_eef .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_ecabc ,_ggec );
_decbg :=Margins {};switch _gcbcf :=_dc .Fields (_ggec );len (_gcbcf ){case 1:_decbg .Top ,_ =_a .ParseFloat (_gcbcf [0],64);_decbg .Bottom =_decbg .Top ;_decbg .Left =_decbg .Top ;_decbg .Right =_decbg .Top ;case 2:_decbg .Top ,_ =_a .ParseFloat (_gcbcf [0],64);
_decbg .Bottom =_decbg .Top ;_decbg .Left ,_ =_a .ParseFloat (_gcbcf [1],64);_decbg .Right =_decbg .Left ;case 3:_decbg .Top ,_ =_a .ParseFloat (_gcbcf [0],64);_decbg .Left ,_ =_a .ParseFloat (_gcbcf [1],64);_decbg .Right =_decbg .Left ;_decbg .Bottom ,_ =_a .ParseFloat (_gcbcf [2],64);
case 4:_decbg .Top ,_ =_a .ParseFloat (_gcbcf [0],64);_decbg .Right ,_ =_a .ParseFloat (_gcbcf [1],64);_decbg .Bottom ,_ =_a .ParseFloat (_gcbcf [2],64);_decbg .Left ,_ =_a .ParseFloat (_gcbcf [3],64);};return _decbg ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// FitMode returns the fit mode of the ellipse.
func (_ebeg *Ellipse )FitMode ()FitMode {return _ebeg ._facg };

// SetPos sets absolute positioning with specified coordinates.
func (_bdcd *Paragraph )SetPos (x ,y float64 ){_bdcd ._aacf =PositionAbsolute ;_bdcd ._ggde =x ;_bdcd ._ffdcg =y ;};

// SetNumber sets the number of the invoice.
func (_gegbc *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gegbc ._cgga [1].Value =number ;return _gegbc ._cgga [0],_gegbc ._cgga [1];};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_abec :_ec .Max (_ec .Min (r ,1.0),0.0),_eafb :_ec .Max (_ec .Min (g ,1.0),0.0),_baa :_ec .Max (_ec .Min (b ,1.0),0.0)};};

// SetWidthRight sets border width for right.
func (_ecfe *border )SetWidthRight (bw float64 ){_ecfe ._gea =bw };

// EnableWordWrap sets the paragraph word wrap flag.
func (_bebgb *StyledParagraph )EnableWordWrap (val bool ){_bebgb ._ebgbe =val };func _babadc (_faeac string ,_fgaag ,_bcdf TextStyle )*TOC {_gbgdaa :=_bcdf ;_gbgdaa .FontSize =14;_agbf :=_defdc (_gbgdaa );_agbf .SetEnableWrap (true );_agbf .SetTextAlignment (TextAlignmentLeft );
_agbf .SetMargins (0,0,0,5);_bedac :=_agbf .Append (_faeac );_bedac .Style =_gbgdaa ;return &TOC {_edbe :_agbf ,_agfbb :[]*TOCLine {},_fdfac :_fgaag ,_agde :_fgaag ,_dbfad :_fgaag ,_dbdbc :_fgaag ,_abgga :"\u002e",_gafab :10,_adgec :Margins {0,0,2,2},_cafed :PositionRelative ,_bcgff :_fgaag ,_cfgge :true };
};

// SkipOver skips over a specified number of rows and cols.
func (_caad *Table )SkipOver (rows ,cols int ){_bfbg :=rows *_caad ._beege +cols -1;if _bfbg < 0{_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _bgfb :=0;_bgfb < _bfbg ;_bgfb ++{_caad .NewCell ();};};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_acdb *Creator )Flip (flipH ,flipV bool )error {_bebb :=_acdb .getActivePage ();if _bebb ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_bcge ,_egg :=_acdb ._fgec [_bebb ];if !_egg {_bcge =&pageTransformations {};
_acdb ._fgec [_bebb ]=_bcge ;};_bcge ._gdbeg =flipH ;_bcge ._bag =flipV ;return nil ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_gffd *Line )SetColor (color Color ){_gffd ._cabf =color };func (_abab *Creator )initContext (){_abab ._gbb .X =_abab ._bcbf .Left ;_abab ._gbb .Y =_abab ._bcbf .Top ;_abab ._gbb .Width =_abab ._ggfe -_abab ._bcbf .Right -_abab ._bcbf .Left ;_abab ._gbb .Height =_abab ._bbdg -_abab ._bcbf .Bottom -_abab ._bcbf .Top ;
_abab ._gbb .PageHeight =_abab ._bbdg ;_abab ._gbb .PageWidth =_abab ._ggfe ;_abab ._gbb .Margins =_abab ._bcbf ;_abab ._gbb ._bfdb =_abab .UnsupportedCharacterReplacement ;};func (_bcbbg *Invoice )newCell (_dcag string ,_bcbae InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_bcbae ,_dcag };
};func (_aafg *Creator )newPage ()*_fa .PdfPage {_ccc :=_fa .NewPdfPage ();_adad :=_aafg ._cab [0];_fbbg :=_aafg ._cab [1];_dff :=_fa .PdfRectangle {Llx :0,Lly :0,Urx :_adad ,Ury :_fbbg };_ccc .MediaBox =&_dff ;_aafg ._ggfe =_adad ;_aafg ._bbdg =_fbbg ;
_aafg .initContext ();return _ccc ;};func _cggbe (_aafce *templateProcessor ,_effd *templateNode )(interface{},error ){return _aafce .parseList (_effd );};

// NewChapter creates a new chapter with the specified title as the heading.
func (_bbgb *Creator )NewChapter (title string )*Chapter {_bbgb ._eddf ++;_bec :=_bbgb .NewTextStyle ();_bec .FontSize =16;return _bdbc (nil ,_bbgb ._bbgg ,_bbgb ._ffgcf ,title ,_bbgb ._eddf ,_bec );};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetBorderWidth sets the border width of the rectangle.
func (_bbafc *Rectangle )SetBorderWidth (bw float64 ){_bbafc ._aebcg =bw };func (_gfbab *templateProcessor )run ()error {_edfaa :=_f .NewDecoder (_ef .NewReader (_gfbab ._bbfa ));var _dagge *templateNode ;for {_cfde ,_ccfc :=_edfaa .Token ();if _ccfc !=nil {if _ccfc ==_dfd .EOF {return nil ;
};return _ccfc ;};if _cfde ==nil {break ;};_aegd ,_feea :=_fbab (_edfaa );_cfdd :=_edfaa .InputOffset ();switch _ggacf :=_cfde .(type ){case _f .StartElement :_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_ggacf .Name .Local );
_gcfgb ,_dfdef :=_gecc [_ggacf .Name .Local ];if !_dfdef {if _gfbab ._cdgag ==""{if _aegd !=0{_eef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_ggacf .Name .Local ,_aegd ,_feea );
}else {_eef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_ggacf .Name .Local ,_cfdd );
};}else {if _aegd !=0{_eef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_ggacf .Name .Local ,_gfbab ._cdgag ,_aegd ,_feea );
}else {_eef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_ggacf .Name .Local ,_gfbab ._cdgag ,_cfdd );
};};continue ;};_dagge =&templateNode {_facfb :_ggacf ,_bgba :_dagge ,_edcb :_aegd ,_gdbed :_feea ,_fcagb :_cfdd };if _gbafb :=_gcfgb ._gcee ;_gbafb !=nil {_dagge ._ccfeb ,_ccfc =_gbafb (_gfbab ,_dagge );if _ccfc !=nil {return _ccfc ;};};case _f .EndElement :_eef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_ggacf .Name .Local );
if _dagge !=nil {if _dagge ._ccfeb !=nil {if _ecec :=_gfbab .renderNode (_dagge );_ecec !=nil {return _ecec ;};};_dagge =_dagge ._bgba ;};case _f .CharData :if _dagge !=nil &&_dagge ._ccfeb !=nil {if _cbgbf :=_gfbab .addNodeText (_dagge ,string (_ggacf ));
_cbgbf !=nil {return _cbgbf ;};};case _f .Comment :_eef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_ggacf ));
};};return nil ;};func (_ebaa *Rectangle )applyFitMode (_fcaef float64 ){_fcaef -=_ebaa ._bacfa .Left +_ebaa ._bacfa .Right +_ebaa ._aebcg ;switch _ebaa ._gcdg {case FitModeFillWidth :_ebaa .ScaleToWidth (_fcaef );};};func (_ddba *Table )getLastCellFromCol (_gegd int )(int ,*TableCell ){for _dggbc :=len (_ddba ._bdfef )-1;
_dggbc >=0;_dggbc --{if _ddba ._bdfef [_dggbc ]._baceb ==_gegd {return _dggbc ,_ddba ._bdfef [_dggbc ];};};return 0,nil ;};func (_geef *templateProcessor )parseTextRenderingModeAttr (_ddaf ,_egcfcg string )TextRenderingMode {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ddaf ,_egcfcg );
_ddbee :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_egcfcg ];
return _ddbee ;};

// CurRow returns the currently active cell's row number.
func (_caae *Table )CurRow ()int {_cgcf :=(_caae ._aeba -1)/_caae ._beege +1;return _cgcf };

// SetFont sets the Paragraph's font.
func (_bdcf *Paragraph )SetFont (font *_fa .PdfFont ){_bdcf ._gcedf =font };func (_egegc *templateProcessor )parseChapterHeading (_ddgbb *templateNode )(interface{},error ){if _ddgbb ._bgba ==nil {_egegc .nodeLogError (_ddgbb ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_abag ;};_adeee ,_gdgf :=_ddgbb ._bgba ._ccfeb .(*Chapter );if !_gdgf {_egegc .nodeLogError (_ddgbb ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_ddgbb ._bgba ._ccfeb );
return nil ,_abag ;};_cgfef :=_adeee .GetHeading ();if _ ,_bfgcf :=_egegc .parseParagraph (_ddgbb ,_cgfef );_bfgcf !=nil {return nil ,_bfgcf ;};return _cgfef ,nil ;};type cmykColor struct{_cgge ,_fbcb ,_abad ,_gdad float64 };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func _eebf (_cebe ,_cbfb *_fa .PdfPageResources )error {_fbc ,_ :=_cebe .GetColorspaces ();if _fbc !=nil &&len (_fbc .Colorspaces )> 0{for _gad ,_adee :=range _fbc .Colorspaces {_fec :=*_ea .MakeName (_gad );
if _cbfb .HasColorspaceByName (_fec ){continue ;};_gebc :=_cbfb .SetColorspaceByName (_fec ,_adee );if _gebc !=nil {return _gebc ;};};};return nil ;};func (_gdafe *Image )makeXObject ()error {_gbda ,_abcc :=_fa .NewXObjectImageFromImage (_gdafe ._dca ,nil ,_gdafe ._fbfd );
if _abcc !=nil {_eef .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_abcc );return _abcc ;};_gdafe ._eadbf =_gbda ;
return nil ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_dfbc float64 ;_gbfgg float64 ;_faaa float64 ;_baag float64 ;_fdde Positioning ;_abbg Color ;_efgb float64 ;_bada Color ;_aebcg float64 ;_gacec float64 ;_efcb float64 ;_caab float64 ;_ebagc float64 ;_bafe float64 ;_bacfa Margins ;
_gcdg FitMode ;};func _daa (_cgfb ,_eeeg ,_abc ,_gced float64 )*Ellipse {return &Ellipse {_fgcb :_cgfb ,_eadb :_eeeg ,_bgea :_abc ,_dceb :_gced ,_dada :PositionAbsolute ,_facc :1.0,_edcd :ColorBlack ,_cadd :1.0,_acdcf :1.0};};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_feccb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gbac []*Block ;_cdfd bool ;_cae error ;_aega =_feccb ._gbfg .IsRelative ();_bee =_feccb ._cdef .Top ;);if _aega &&!_feccb ._gfbg &&!_feccb ._dacf {_ddfa :=_feccb .ctxHeight (ctx .Width );
if _ddfa > ctx .Height -_feccb ._cdef .Top &&_ddfa <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _gbac ,ctx ,_cae =_ddge ().GeneratePageBlocks (ctx );_cae !=nil {return nil ,ctx ,_cae ;};_cdfd =true ;_bee =0;};};_faa :=ctx ;_aeae :=ctx ;
if _aega {ctx .X +=_feccb ._cdef .Left ;ctx .Y +=_bee ;ctx .Width -=_feccb ._cdef .Left +_feccb ._cdef .Right ;ctx .Height -=_bee ;_aeae =ctx ;ctx .X +=_feccb ._dgfg .Left ;ctx .Y +=_feccb ._dgfg .Top ;ctx .Width -=_feccb ._dgfg .Left +_feccb ._dgfg .Right ;
ctx .Height -=_feccb ._dgfg .Top ;ctx .Margins .Top +=_feccb ._dgfg .Top ;ctx .Margins .Bottom +=_feccb ._dgfg .Bottom ;ctx .Margins .Left +=_feccb ._cdef .Left +_feccb ._dgfg .Left ;ctx .Margins .Right +=_feccb ._cdef .Right +_feccb ._dgfg .Right ;};ctx .Inline =_feccb ._dacf ;
_eaaae :=ctx ;_aadf :=ctx ;var _bgda float64 ;for _ ,_faab :=range _feccb ._cga {if ctx .Inline {if (ctx .X -_eaaae .X )+_faab .Width ()<=ctx .Width {ctx .Y =_aadf .Y ;ctx .Height =_aadf .Height ;}else {ctx .X =_eaaae .X ;ctx .Width =_eaaae .Width ;_aadf .Y +=_bgda ;
_aadf .Height -=_bgda ;_bgda =0;};};_ffad ,_cbe ,_gbdbf :=_faab .GeneratePageBlocks (ctx );if _gbdbf !=nil {_eef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_gbdbf );
return nil ,ctx ,_gbdbf ;};if len (_ffad )< 1{continue ;};if len (_gbac )> 0{_gbac [len (_gbac )-1].mergeBlocks (_ffad [0]);_gbac =append (_gbac ,_ffad [1:]...);}else {if _gbbe :=_ffad [0]._ffc ;_gbbe ==nil ||len (*_gbbe )==0{_cdfd =true ;};_gbac =append (_gbac ,_ffad [0:]...);
};if ctx .Inline {if ctx .Page !=_cbe .Page {_eaaae .Y =ctx .Margins .Top ;_eaaae .Height =ctx .PageHeight -ctx .Margins .Top ;_aadf .Y =_eaaae .Y ;_aadf .Height =_eaaae .Height ;_bgda =_cbe .Height -_eaaae .Height ;}else {if _dbbb :=ctx .Height -_cbe .Height ;
_dbbb > _bgda {_bgda =_dbbb ;};};}else {_cbe .X =ctx .X ;};ctx =_cbe ;};ctx .Inline =_faa .Inline ;ctx .Margins =_faa .Margins ;if _aega {ctx .X =_faa .X ;ctx .Width =_faa .Width ;ctx .Y +=_feccb ._dgfg .Bottom ;ctx .Height -=_feccb ._dgfg .Bottom ;};if _feccb ._gcde !=nil {_gbac ,_cae =_feccb .drawBackground (_gbac ,_aeae ,ctx ,_cdfd );
if _cae !=nil {return nil ,ctx ,_cae ;};};if _feccb ._gbfg .IsAbsolute (){return _gbac ,_faa ,nil ;};ctx .Y +=_feccb ._cdef .Bottom ;ctx .Height -=_feccb ._cdef .Bottom ;return _gbac ,ctx ,nil ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_adeff *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_adeff ._ggdf =align ;};func (_cddbd *StyledParagraph )split (_efgf DrawContext )(_gafea ,_agca *StyledParagraph ,_bggg error ){if _bggg =_cddbd .wrapChunks (false );
_bggg !=nil {return nil ,nil ,_bggg ;};if len (_cddbd ._egffa )==1&&_cddbd ._gbcb > _efgf .Height {return _cddbd ,nil ,nil ;};_gaac :=func (_dcdf []*TextChunk ,_gdgab []*TextChunk )[]*TextChunk {if len (_gdgab )==0{return _dcdf ;};_bfbbc :=len (_dcdf );
if _bfbbc ==0{return append (_dcdf ,_gdgab ...);};if _dcdf [_bfbbc -1].Style ==_gdgab [0].Style {_dcdf [_bfbbc -1].Text +=_gdgab [0].Text ;}else {_dcdf =append (_dcdf ,_gdgab [0]);};return append (_dcdf ,_gdgab [1:]...);};_bcfeg :=func (_aagc *StyledParagraph ,_bcee []*TextChunk )*StyledParagraph {if len (_bcee )==0{return nil ;
};_geeee :=*_aagc ;_geeee ._cfbcg =_bcee ;return &_geeee ;};var (_ccbca float64 ;_gceac []*TextChunk ;_gfcb []*TextChunk ;);for _ ,_agef :=range _cddbd ._egffa {var _cdee float64 ;_feadf :=make ([]*TextChunk ,0,len (_agef ));for _ ,_bgbg :=range _agef {if _gbgda :=_bgbg .Style .FontSize ;
_gbgda > _cdee {_cdee =_gbgda ;};_feadf =append (_feadf ,_bgbg .clone ());};_cdee *=_cddbd ._gbcb ;if _cddbd ._defc .IsRelative (){if _ccbca +_cdee > _efgf .Height {_gfcb =_gaac (_gfcb ,_feadf );}else {_gceac =_gaac (_gceac ,_feadf );};};_ccbca +=_cdee ;
};_cddbd ._egffa =nil ;if len (_gfcb )==0{return _cddbd ,nil ,nil ;};return _bcfeg (_cddbd ,_gceac ),_bcfeg (_cddbd ,_gfcb ),nil ;};func _ecdag (_ddcac string ,_bgcfd bool )string {_febda :=_ddcac ;if _febda ==""{return "";};_bfad :=_b .Paragraph {};_ ,_cddf :=_bfad .SetString (_ddcac );
if _cddf !=nil {return _febda ;};_cegc ,_cddf :=_bfad .Order ();if _cddf !=nil {return _febda ;};_cacbd :=_cegc .NumRuns ();_geaaf :=make ([]string ,_cacbd );for _decg :=0;_decg < _cegc .NumRuns ();_decg ++{_aefgc :=_cegc .Run (_decg );_gfeef :=_aefgc .String ();
if _aefgc .Direction ()==_b .RightToLeft {_gfeef =_b .ReverseString (_gfeef );};if _bgcfd {_geaaf [_decg ]=_gfeef ;}else {_geaaf [_cacbd -1]=_gfeef ;};_cacbd --;};if len (_geaaf )!=_cegc .NumRuns (){return _ddcac ;};_febda =_dc .Join (_geaaf ,"");return _febda ;
};

// SetLineOpacity sets the line opacity.
func (_befdg *Polyline )SetLineOpacity (opacity float64 ){_befdg ._ggba =opacity };func (_ggea *Paragraph )getTextLineWidth (_ceaf string )float64 {var _bgce float64 ;for _ ,_febf :=range _ceaf {if _febf =='\u000A'{continue ;};_gfgbe ,_cdgg :=_ggea ._gcedf .GetRuneMetrics (_febf );
if !_cdgg {_eef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_febf ,_febf );
return -1;};_bgce +=_ggea ._cgcbd *_gfgbe .Wx ;};return _bgce ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_dfg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fd :=_de .IdentityMatrix ();_bb ,_gd :=_dfg .Width (),_dfg .Height ();if _dfg ._dcc .IsRelative (){_fd =_fd .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gd );}else {_fd =_fd .Translate (_dfg ._cdf ,ctx .PageHeight -_dfg ._ag -_gd );
};_cee :=_gd ;if _dfg ._eb !=0{_fd =_fd .Translate (_bb /2,_gd /2).Rotate (_dfg ._eb *_ec .Pi /180.0).Translate (-_bb /2,-_gd /2);_ ,_cee =_dfg .RotatedSize ();};if _dfg ._dcc .IsRelative (){ctx .Y +=_cee ;};_bcb :=_bd .NewContentCreator ();_bcb .Add_cm (_fd [0],_fd [1],_fd [3],_fd [4],_fd [6],_fd [7]);
_ded :=_dfg .duplicate ();_dea :=append (*_bcb .Operations (),*_ded ._ffc ...);_dea .WrapIfNeeded ();_ded ._ffc =&_dea ;for _ ,_ebg :=range _dfg ._cc {_ac ,_abg :=_ea .GetArray (_ebg .Rect );if !_abg ||_ac .Len ()!=4{_eef .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_ebg .Rect );
continue ;};_gee ,_cdb :=_fa .NewPdfRectangle (*_ac );if _cdb !=nil {_eef .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_cdb );
continue ;};_gee .Transform (_fd );_ebg .Rect =_gee .ToPdfObject ();};return []*Block {_ded },ctx ,nil ;};func (_efef *Creator )getActivePage ()*_fa .PdfPage {if _efef ._aca ==nil {if len (_efef ._ccgg )==0{return nil ;};return _efef ._ccgg [len (_efef ._ccgg )-1];
};return _efef ._aca ;};

// SetColorLeft sets border color for left.
func (_fba *border )SetColorLeft (col Color ){_fba ._bgfg =col };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_egccg *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_egccg ._bcbf .Left =left ;_egccg ._bcbf .Right =right ;_egccg ._bcbf .Top =top ;_egccg ._bcbf .Bottom =bottom ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_bged *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acead :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcc ,_fcac :=_acead .setOpacity (_bged ._bcfd ,_bged ._eggf );if _fcac !=nil {return nil ,ctx ,_fcac ;
};_bggab :=_bged ._dbag ;_bggab .FillEnabled =_bggab .FillColor !=nil ;_bggab .BorderEnabled =_bggab .BorderColor !=nil &&_bggab .BorderWidth > 0;var (_geff =ctx .PageHeight ;_cggd =_bggab .Rings ;_afed =make ([][]_ce .CubicBezierCurve ,0,len (_bggab .Rings ));
);_edff :=_fa .PdfRectangle {};if len (_cggd )> 0&&len (_cggd [0])> 0{_edfc :=_cggd [0][0];_edfc .P0 .Y =_geff -_edfc .P0 .Y ;_edfc .P1 .Y =_geff -_edfc .P1 .Y ;_edfc .P2 .Y =_geff -_edfc .P2 .Y ;_edfc .P3 .Y =_geff -_edfc .P3 .Y ;_edff =_edfc .GetBounds ();
};for _ ,_fbbf :=range _cggd {_fbfb :=make ([]_ce .CubicBezierCurve ,0,len (_fbbf ));for _ ,_gcae :=range _fbbf {_aad :=_gcae ;_aad .P0 .Y =_geff -_aad .P0 .Y ;_aad .P1 .Y =_geff -_aad .P1 .Y ;_aad .P2 .Y =_geff -_aad .P2 .Y ;_aad .P3 .Y =_geff -_aad .P3 .Y ;
_fbfb =append (_fbfb ,_aad );_dcfeg :=_aad .GetBounds ();_edff .Llx =_ec .Min (_edff .Llx ,_dcfeg .Llx );_edff .Lly =_ec .Min (_edff .Lly ,_dcfeg .Lly );_edff .Urx =_ec .Max (_edff .Urx ,_dcfeg .Urx );_edff .Ury =_ec .Max (_edff .Ury ,_dcfeg .Ury );};_afed =append (_afed ,_fbfb );
};_bggab .Rings =_afed ;defer func (){_bggab .Rings =_cggd }();if _bggab .FillEnabled {_gbde :=_ddcd (_acead ,_bged ._dbag .FillColor ,_bged ._ddbg ,func ()Rectangle {return Rectangle {_dfbc :_edff .Llx ,_gbfgg :_edff .Lly ,_faaa :_edff .Width (),_baag :_edff .Height ()};
});if _gbde !=nil {return nil ,ctx ,_gbde ;};};_agba ,_ ,_fcac :=_bggab .Draw (_fcc );if _fcac !=nil {return nil ,ctx ,_fcac ;};if _fcac =_acead .addContentsByString (string (_agba ));_fcac !=nil {return nil ,ctx ,_fcac ;};return []*Block {_acead },ctx ,nil ;
};

// SetSellerAddress sets the seller address of the invoice.
func (_gdfb *Invoice )SetSellerAddress (address *InvoiceAddress ){_gdfb ._aecb =address };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_ccda *Paragraph )SetWidth (width float64 ){_ccda ._gdffb =width ;_ccda .wrapText ()};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_aegab *Image )ScaleToHeight (h float64 ){_fdgb :=_aegab ._gfef /_aegab ._ffab ;_aegab ._ffab =h ;_aegab ._gfef =h *_fdgb ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gffcd *Invoice )SetNoteHeadingStyle (style TextStyle ){_gffcd ._gaga =style };

// Title returns the title of the invoice.
func (_aada *Invoice )Title ()string {return _aada ._afgg };

// SetBackground sets the background properties of the component.
func (_ebfa *Division )SetBackground (background *Background ){_ebfa ._gcde =background };

// GetCoords returns coordinates of border.
func (_dabf *border )GetCoords ()(float64 ,float64 ){return _dabf ._acb ,_dabf ._edb };func _bbed (_egfbg *templateProcessor ,_bfbba *templateNode )(interface{},error ){return _egfbg .parseTextChunk (_bfbba ,nil );};

// Width returns the width of the ellipse.
func (_daga *Ellipse )Width ()float64 {return _daga ._bgea };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cfcc *RadialShading )SetBackgroundColor (backgroundColor Color ){_cfcc ._gcbg .SetBackgroundColor (backgroundColor );};var (_dffeg =_ee .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_abeb =_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_abag =_e .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_cadef =_e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_cfee =_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func _caaff (_aaaa *templateProcessor ,_gebce *templateNode )(interface{},error ){return _aaaa .parseChapter (_gebce );};func (_eedg *List )split (_ggbgc DrawContext )(_dbad ,_gace *List ){var (_cbbf float64 ;_egedf ,_faeed []*listItem ;
);_gecg :=_ggbgc .Width -_eedg ._eead .Horizontal ()-_eedg ._dcdc -_eedg .markerWidth ();_ggag :=_eedg .markerWidth ();for _ebag ,_agfg :=range _eedg ._fbeaf {_eedb :=_agfg .ctxHeight (_gecg );_cbbf +=_eedb ;if _cbbf <=_ggbgc .Height {_egedf =append (_egedf ,_agfg );
}else {switch _bgbe :=_agfg ._edcf .(type ){case *List :_fdgf :=_ggbgc ;_fdgf .Height =_ec .Floor (_eedb -(_cbbf -_ggbgc .Height ));_eceg ,_gceg :=_bgbe .split (_fdgf );if _eceg !=nil {_egf :=_cgege ();_egf ._dbea =_agfg ._dbea ;_egf ._edcf =_eceg ;_egedf =append (_egedf ,_egf );
};if _gceg !=nil {_agcf :=_bgbe ._cgef .Style .FontSize ;_dcfa ,_cfgec :=_bgbe ._cgef .Style .Font .GetRuneMetrics (' ');if _cfgec {_agcf =_bgbe ._cgef .Style .FontSize *_dcfa .Wx *_bgbe ._cgef .Style .horizontalScale ()/1000.0;};_bede :=_dc .Repeat ("\u0020",int (_ggag /_agcf ));
_cgdab :=_cgege ();_cgdab ._dbea =*NewTextChunk (_bede ,_bgbe ._cgef .Style );_cgdab ._edcf =_gceg ;_faeed =append (_faeed ,_cgdab );_faeed =append (_faeed ,_eedg ._fbeaf [_ebag +1:]...);};default:_faeed =_eedg ._fbeaf [_ebag :];};if len (_faeed )> 0{break ;
};};};if len (_egedf )> 0{_dbad =_ddaea (_eedg ._dbca );*_dbad =*_eedg ;_dbad ._fbeaf =_egedf ;};if len (_faeed )> 0{_gace =_ddaea (_eedg ._dbca );*_gace =*_eedg ;_gace ._fbeaf =_faeed ;};return _dbad ,_gace ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_cgda *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_cgda ._dfac .Left =left ;_cgda ._dfac .Right =right ;_cgda ._dfac .Top =top ;_cgda ._dfac .Bottom =bottom ;};func (_bdec *StyledParagraph )getTextWidth ()float64 {var _aggdg float64 ;
_ebbdd :=len (_bdec ._cfbcg );for _fcgac ,_geddd :=range _bdec ._cfbcg {_feba :=&_geddd .Style ;_fbdgd :=len (_geddd .Text );for _bafd ,_bfcc :=range _geddd .Text {if _bfcc =='\u000A'{continue ;};_bbga ,_fcaab :=_feba .Font .GetRuneMetrics (_bfcc );if !_fcaab {_eef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bfcc );
return -1;};_aggdg +=_feba .FontSize *_bbga .Wx *_feba .horizontalScale ();if _bfcc !=' '&&(_fcgac !=_ebbdd -1||_bafd !=_fbdgd -1){_aggdg +=_feba .CharSpacing *1000.0;};};};return _aggdg ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_cbacb Color ;_gegge _ce .LineStyle ;_cbbdb CellBorderStyle ;_cgce Color ;_fceg float64 ;_fafdb CellBorderStyle ;_cfaea Color ;_gegf float64 ;_fbcg CellBorderStyle ;_egddb Color ;_bebbd float64 ;_deaff CellBorderStyle ;_bbcfdd Color ;
_faeaf float64 ;_cceef ,_baceb int ;_badd int ;_gfeb int ;_cead VectorDrawable ;_dedb CellHorizontalAlignment ;_ecbg CellVerticalAlignment ;_ddbeg float64 ;_edfg *Table ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_fab *Ellipse )BorderOpacity ()float64 {return _fab ._acdcf };func (_ddded *templateProcessor )parseFloatArray (_fccce ,_caeg string )[]float64 {_eef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fccce ,_caeg );
_egcga :=_dc .Fields (_caeg );_aefe :=make ([]float64 ,0,len (_egcga ));for _ ,_aagd :=range _egcga {_adade ,_ :=_a .ParseFloat (_aagd ,64);_aefe =append (_aefe ,_adade );};return _aefe ;};

// String implements error interface.
func (_bggf UnsupportedRuneError )Error ()string {return _bggf .Message };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;func _cfce (_bdffa ,_ffae ,_gddc ,_cgff float64 )*Rectangle {return &Rectangle {_dfbc :_bdffa ,_gbfgg :_ffae ,_faaa :_gddc ,_baag :_cgff ,_fdde :PositionAbsolute ,_efgb :1.0,_bada :ColorBlack ,_aebcg :1.0,_gacec :1.0};};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_adbf *Image )ConvertToBinary ()error {return _adbf ._dca .ConvertToBinary ()};

// SetTotal sets the total of the invoice.
func (_begcg *Invoice )SetTotal (value string ){_begcg ._cadf [1].Value =value };func (_agb *Block )setOpacity (_ecg float64 ,_ffg float64 )(string ,error ){if (_ecg < 0||_ecg >=1.0)&&(_ffg < 0||_ffg >=1.0){return "",nil ;};_gba :=0;_age :=_g .Sprintf ("\u0047\u0053\u0025\u0064",_gba );
for _agb ._gae .HasExtGState (_ea .PdfObjectName (_age )){_gba ++;_age =_g .Sprintf ("\u0047\u0053\u0025\u0064",_gba );};_da :=_ea .MakeDict ();if _ecg >=0&&_ecg < 1.0{_da .Set ("\u0063\u0061",_ea .MakeFloat (_ecg ));};if _ffg >=0&&_ffg < 1.0{_da .Set ("\u0043\u0041",_ea .MakeFloat (_ffg ));
};_bf :=_agb ._gae .AddExtGState (_ea .PdfObjectName (_age ),_da );if _bf !=nil {return "",_bf ;};return _age ,nil ;};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_fcbag *Rectangle )SetCoords (x ,y float64 ){_fcbag ._dfbc =x ;_fcbag ._gbfgg =y };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetStyleTop sets border style for top side.
func (_bcg *border )SetStyleTop (style CellBorderStyle ){_bcg ._bdd =style };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_gcdgf *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_gcdgf ._ebebd =textOverflow ;};

// SetStyleLeft sets border style for left side.
func (_aaa *border )SetStyleLeft (style CellBorderStyle ){_aaa ._dcda =style };

// NewPageBreak create a new page break.
func (_edaf *Creator )NewPageBreak ()*PageBreak {return _ddge ()};func _ggbe (_feae *_fa .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_feae ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ebgag *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _ebgag ._cadf [0],_ebgag ._cadf [1]};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _aaada (path )};func (_adfd *templateProcessor )nodeError (_gebcg *templateNode ,_gagge string ,_accc ...interface{})error {return _g .Errorf (_adfd .getNodeErrorLocation (_gebcg ,_gagge ,_accc ...));
};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gdgd *TOCLine )SetStyle (style TextStyle ){_gdgd .Number .Style =style ;_gdgd .Title .Style =style ;_gdgd .Separator .Style =style ;_gdgd .Page .Style =style ;};

// AppendColumn appends a column to the line items table.
func (_dfbe *Invoice )AppendColumn (description string )*InvoiceCell {_ebcbg :=_dfbe .NewColumn (description );_dfbe ._cgcg =append (_dfbe ._cgcg ,_ebcbg );return _ebcbg ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;
TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_cbba *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbba ._bacfa .Left ,_cbba ._bacfa .Right ,_cbba ._bacfa .Top ,_cbba ._bacfa .Bottom ;};func (_abadf cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_aed :=_abadf ._gdad ;
return 1-(_abadf ._cgge *(1-_aed )+_aed ),1-(_abadf ._fbcb *(1-_aed )+_aed ),1-(_abadf ._abad *(1-_aed )+_aed );};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_ecce *Rectangle )SetFillOpacity (opacity float64 ){_ecce ._efgb =opacity };

// IsAbsolute checks if the positioning is absolute.
func (_ggab Positioning )IsAbsolute ()bool {return _ggab ==PositionAbsolute };

// SetTitle sets the title of the invoice.
func (_ecda *Invoice )SetTitle (title string ){_ecda ._afgg =title };func (_ddag *StyledParagraph )getTextLineWidth (_deca []*TextChunk )float64 {var _fdeec float64 ;_fefff :=len (_deca );for _gffdd ,_ffdbg :=range _deca {_ccedf :=&_ffdbg .Style ;_aacb :=len (_ffdbg .Text );
for _gcaaa ,_fefe :=range _ffdbg .Text {if _fefe =='\u000A'{continue ;};_agfda ,_edafb :=_ccedf .Font .GetRuneMetrics (_fefe );if !_edafb {_eef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fefe );
return -1;};_fdeec +=_ccedf .FontSize *_agfda .Wx *_ccedf .horizontalScale ();if _fefe !=' '&&(_gffdd !=_fefff -1||_gcaaa !=_aacb -1){_fdeec +=_ccedf .CharSpacing *1000.0;};};};return _fdeec ;};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);

// DrawFooter sets a function to draw a footer on created output pages.
func (_cfgf *Creator )DrawFooter (drawFooterFunc func (_adgc *Block ,_gefd FooterFunctionArgs )){_cfgf ._ddb =drawFooterFunc ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_abdc *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _gbgf (number ,title ,page ,level ,_abdc .NewTextStyle ());};

// SetBorderOpacity sets the border opacity.
func (_gagd *CurvePolygon )SetBorderOpacity (opacity float64 ){_gagd ._eggf =opacity };

// SetPositioning sets the positioning of the line (absolute or relative).
func (_ccbf *Line )SetPositioning (positioning Positioning ){_ccbf ._gfdb =positioning };func (_ffge *StyledParagraph )getTextHeight ()float64 {var _fcaec float64 ;for _ ,_edecc :=range _ffge ._cfbcg {_cbbb :=_edecc .Style .FontSize *_ffge ._gbcb ;if _cbbb > _fcaec {_fcaec =_cbbb ;
};};return _fcaec ;};

// Vertical returns total vertical (top + bottom) margin.
func (_adfg *Margins )Vertical ()float64 {return _adfg .Bottom +_adfg .Top };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_dfebf *RadialShading )AddPatternResource (block *Block )(_cbdd _ea .PdfObjectName ,_bfcb error ){_aegb :=1;_cace :=_ea .PdfObjectName ("\u0050"+_a .Itoa (_aegb ));for block ._gae .HasPatternByName (_cace ){_aegb ++;_cace =_ea .PdfObjectName ("\u0050"+_a .Itoa (_aegb ));
};if _ggagc :=block ._gae .SetPatternByName (_cace ,_dfebf .ToPdfShadingPattern ().ToPdfObject ());_ggagc !=nil {return "",_ggagc ;};return _cace ,nil ;};

// SetHeight sets the Image's document height to specified h.
func (_dbd *Image )SetHeight (h float64 ){_dbd ._ffab =h };

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_bcece *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_afea []*Block ;_aggg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_agfe =ctx ;_egca ,_gcag =_bcece ._dfbf ,ctx .PageHeight -_bcece ._aeecg ;_ebfdg ,_fedc =_bcece ._gagg ,ctx .PageHeight -_bcece ._cbaff ;
);_aade :=_bcece ._gfdb .IsRelative ();if _aade {ctx .X +=_bcece ._dcdb .Left ;ctx .Y +=_bcece ._dcdb .Top ;ctx .Width -=_bcece ._dcdb .Left +_bcece ._dcdb .Right ;ctx .Height -=_bcece ._dcdb .Top +_bcece ._dcdb .Bottom ;_egca ,_gcag ,_ebfdg ,_fedc =_bcece .computeCoords (ctx );
if _bcece .Height ()> ctx .Height {_afea =append (_afea ,_aggg );_aggg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ecea :=ctx ;_ecea .Y =ctx .Margins .Top +_bcece ._dcdb .Top ;_ecea .X =ctx .Margins .Left +_bcece ._dcdb .Left ;_ecea .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bcece ._dcdb .Top -_bcece ._dcdb .Bottom ;
_ecea .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bcece ._dcdb .Left -_bcece ._dcdb .Right ;ctx =_ecea ;_egca ,_gcag ,_ebfdg ,_fedc =_bcece .computeCoords (ctx );};};_gggd :=_ce .BasicLine {X1 :_egca ,Y1 :_gcag ,X2 :_ebfdg ,Y2 :_fedc ,LineColor :_gdfa (_bcece ._cabf ),Opacity :_bcece ._gcaa ,LineWidth :_bcece ._baec ,LineStyle :_bcece ._ddca ,DashArray :_bcece ._efgeg ,DashPhase :_bcece ._gfee };
_bdadf ,_gdbag :=_aggg .setOpacity (1.0,_bcece ._gcaa );if _gdbag !=nil {return nil ,ctx ,_gdbag ;};_cgfc ,_ ,_gdbag :=_gggd .Draw (_bdadf );if _gdbag !=nil {return nil ,ctx ,_gdbag ;};if _gdbag =_aggg .addContentsByString (string (_cgfc ));_gdbag !=nil {return nil ,ctx ,_gdbag ;
};if _aade {ctx .X =_agfe .X ;ctx .Width =_agfe .Width ;_gcagc :=_bcece .Height ();ctx .Y +=_gcagc +_bcece ._dcdb .Bottom ;ctx .Height -=_gcagc ;}else {ctx =_agfe ;};_afea =append (_afea ,_aggg );return _afea ,ctx ,nil ;};func (_deff *TableCell )width (_ffgcd []float64 ,_gadcf float64 )float64 {_bgeggg :=float64 (0.0);
for _befaf :=0;_befaf < _deff ._gfeb ;_befaf ++{_bgeggg +=_ffgcd [_deff ._baceb +_befaf -1];};return _bgeggg *_gadcf ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_aece *Invoice )NoteStyle ()TextStyle {return _aece ._bgeac };func _faaeb (_afeg *templateProcessor ,_ccbea *templateNode )(interface{},error ){return _afeg .parseEllipse (_ccbea );};func _gacc (_fdfg string ,_fgga TextStyle )*Paragraph {_bbcf :=&Paragraph {_babfa :_fdfg ,_gcedf :_fgga .Font ,_cgcbd :_fgga .FontSize ,_ecegc :1.0,_fade :true ,_gade :true ,_fbgf :TextAlignmentLeft ,_dgdea :0,_bdefc :1,_efdb :1,_aacf :PositionRelative };
_bbcf .SetColor (_fgga .Color );return _bbcf ;};var _gegg =_ee .MustCompile ("\u005c\u0064\u002b");func _dbdf (_fcgg *templateProcessor ,_cfggc *templateNode )(interface{},error ){return _fcgg .parseListItem (_cfggc );};func (_bdf *Block )addContents (_aaf *_bd .ContentStreamOperations ){_bdf ._ffc .WrapIfNeeded ();
_aaf .WrapIfNeeded ();*_bdf ._ffc =append (*_bdf ._ffc ,*_aaf ...);};func (_bcggf *templateProcessor )parseRadialGradientAttr (creator *Creator ,_bgaaa string )Color {_fffb :=ColorBlack ;if _bgaaa ==""{return _fffb ;};var (_cfca error ;_bddbf =0.0;_fgcde =0.0;
_eafg =-1.0;_ffce =_dc .Split (_bgaaa [16:len (_bgaaa )-1],"\u002c"););_cgedb :=_dc .Fields (_ffce [0]);if len (_cgedb )==2&&_dc .TrimSpace (_cgedb [0])[0]!='#'{_bddbf ,_cfca =_a .ParseFloat (_cgedb [0],64);if _cfca !=nil {_eef .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cfca );
};_fgcde ,_cfca =_a .ParseFloat (_cgedb [1],64);if _cfca !=nil {_eef .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cfca );
};_ffce =_ffce [1:];};_ggfc :=_dc .TrimSpace (_ffce [0]);if _ggfc [0]!='#'{_eafg ,_cfca =_a .ParseFloat (_ggfc ,64);if _cfca !=nil {_eef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_cfca );
};_ffce =_ffce [1:];};_gcbaa ,_eecca :=_bcggf .processGradientColorPair (_ffce );if _gcbaa ==nil ||_eecca ==nil {return _fffb ;};_cabb :=creator .NewRadialGradientColor (_bddbf ,_fgcde ,0,_eafg ,[]*ColorPoint {});for _acef :=0;_acef < len (_gcbaa );_acef ++{_cabb .AddColorStop (_gcbaa [_acef ],_eecca [_acef ]);
};return _cabb ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gcccc *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afbgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffgcb ,_adag :=_afbgb .setOpacity (_gcccc ._ggba ,_gcccc ._ggba );if _adag !=nil {return nil ,ctx ,_adag ;
};_abgab :=_gcccc ._dfgf .Points ;for _geee :=range _abgab {_bbddf :=&_abgab [_geee ];_bbddf .Y =ctx .PageHeight -_bbddf .Y ;};_dcgb ,_ ,_adag :=_gcccc ._dfgf .Draw (_ffgcb );if _adag !=nil {return nil ,ctx ,_adag ;};if _adag =_afbgb .addContentsByString (string (_dcgb ));
_adag !=nil {return nil ,ctx ,_adag ;};return []*Block {_afbgb },ctx ,nil ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cebfe *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_cebfe ._beaeb =&_fa .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func (_fefc *Invoice )newColumn (_acdbg string ,_deb CellHorizontalAlignment )*InvoiceCell {_daeb :=&InvoiceCell {_fefc ._abef ,_acdbg };
_daeb .Alignment =_deb ;return _daeb ;};

// Width returns the width of the Paragraph.
func (_gedd *StyledParagraph )Width ()float64 {if _gedd ._dgba &&int (_gedd ._fdfbb )> 0{return _gedd ._fdfbb ;};return _gedd .getTextWidth ()/1000.0;};func _bgfa (_geac int )*Table {_effg :=&Table {_beege :_geac ,_efbgd :10.0,_gaecf :[]float64 {},_cddcg :[]float64 {},_bdfef :[]*TableCell {},_cgbff :make ([]int ,_geac ),_cbca :true };
_effg .resetColumnWidths ();return _effg ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_gageb *shading )SetAntiAlias (enable bool ){_gageb ._eadef =enable };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_acg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _eafbg (number ,title ,page ,level ,style );};

// SetAngle sets the rotation angle of the text.
func (_aebcb *StyledParagraph )SetAngle (angle float64 ){_aebcb ._cefe =angle };

// SetOpacity sets opacity for Image.
func (_bded *Image )SetOpacity (opacity float64 ){_bded ._ddddf =opacity };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fbfea *Paragraph )SetTextAlignment (align TextAlignment ){_fbfea ._fbgf =align };func _gbgf (_afffa ,_fagd ,_dacacc string ,_ccgcd uint ,_gddad TextStyle )*TOCLine {return _eafbg (TextChunk {Text :_afffa ,Style :_gddad },TextChunk {Text :_fagd ,Style :_gddad },TextChunk {Text :_dacacc ,Style :_gddad },_ccgcd ,_gddad );
};func (_cbag *templateProcessor )renderNode (_fbgca *templateNode )error {_ccgbe :=_fbgca ._ccfeb ;if _ccgbe ==nil {return nil ;};_addb :=_fbgca ._facfb .Name .Local ;_cfgadf ,_abegg :=_gecc [_addb ];if !_abegg {_cbag .nodeLogDebug (_fbgca ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_addb );
return nil ;};var _efee interface{};if _fbgca ._bgba !=nil &&_fbgca ._bgba ._ccfeb !=nil {_egedc :=_fbgca ._bgba ._facfb .Name .Local ;if _ ,_abegg =_cfgadf ._faaf [_egedc ];!_abegg {_cbag .nodeLogDebug (_fbgca ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_egedc ,_addb );
return _abag ;};_efee =_fbgca ._bgba ._ccfeb ;}else {_cdbff :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _cbag ._fcaeg .(type ){case *Block :_cdbff ="\u0062\u006c\u006fc\u006b";};if _ ,_abegg =_cfgadf ._faaf [_cdbff ];!_abegg {_cbag .nodeLogDebug (_fbgca ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_cdbff ,_addb );
return _abag ;};_efee =_cbag ._fcaeg ;};switch _cdcadd :=_efee .(type ){case componentRenderer :_egcff ,_fcdgg :=_ccgbe .(Drawable );if !_fcdgg {_cbag .nodeLogError (_fbgca ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_addb ,_ccgbe );
return _cadef ;};_gdffc :=_cdcadd .Draw (_egcff );if _gdffc !=nil {return _cbag .nodeError (_fbgca ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_addb ,_ccgbe ,_gdffc );
};case *Division :switch _ebddb :=_ccgbe .(type ){case *Background :_cdcadd .SetBackground (_ebddb );case VectorDrawable :_bebgf :=_cdcadd .Add (_ebddb );if _bebgf !=nil {return _cbag .nodeError (_fbgca ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_addb ,_ccgbe ,_bebgf );
};};case *TableCell :_fgegc ,_dabc :=_ccgbe .(VectorDrawable );if !_dabc {_cbag .nodeLogError (_fbgca ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_addb ,_ccgbe );
return _cadef ;};_bgef :=_cdcadd .SetContent (_fgegc );if _bgef !=nil {return _cbag .nodeError (_fbgca ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_addb ,_ccgbe ,_bgef );
};case *StyledParagraph :_geecd ,_gfda :=_ccgbe .(*TextChunk );if !_gfda {_cbag .nodeLogError (_fbgca ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_addb ,_ccgbe );
return _cadef ;};_cdcadd .appendChunk (_geecd );case *Chapter :switch _cfacc :=_ccgbe .(type ){case *Chapter :return nil ;case *Paragraph :if _fbgca ._facfb .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_edfca :=_cdcadd .Add (_cfacc );if _edfca !=nil {return _cbag .nodeError (_fbgca ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_addb ,_ccgbe ,_edfca );
};case Drawable :_egfd :=_cdcadd .Add (_cfacc );if _egfd !=nil {return _cbag .nodeError (_fbgca ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_addb ,_ccgbe ,_egfd );
};};case *List :switch _eegedf :=_ccgbe .(type ){case *TextChunk :case *listItem :_cdcadd ._fbeaf =append (_cdcadd ._fbeaf ,_eegedf );default:_cbag .nodeLogError (_fbgca ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_addb ,_ccgbe );
};case *listItem :switch _gcdgeac :=_ccgbe .(type ){case *TextChunk :case *StyledParagraph :_cdcadd ._edcf =_gcdgeac ;case *List :if _gcdgeac ._ecfac {_gcdgeac ._dcdc =15;};_cdcadd ._edcf =_gcdgeac ;case *Image :_cdcadd ._edcf =_gcdgeac ;case *Division :_cdcadd ._edcf =_gcdgeac ;
case *Table :_cdcadd ._edcf =_gcdgeac ;default:_cbag .nodeLogError (_fbgca ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_addb ,_ccgbe );
return _cadef ;};};return nil ;};func (_ccfgfe *templateProcessor )parseListItem (_ccaa *templateNode )(interface{},error ){if _ccaa ._bgba ==nil {_ccfgfe .nodeLogError (_ccaa ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_abag ;};_ggeb ,_edccc :=_ccaa ._bgba ._ccfeb .(*List );if !_edccc {_ccfgfe .nodeLogError (_ccaa ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_abag ;};_adbda :=_cgege ();_adbda ._dbea =_ggeb ._cgef ;return _adbda ,nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_ebed *TableCell )SetBorderLineStyle (style _ce .LineStyle ){_ebed ._gegge =style };type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// Width returns the width of the graphic svg.
func (_dcdd *GraphicSVG )Width ()float64 {return _dcdd ._baea .Width };

// The Image type is used to draw an image onto PDF.
type Image struct{_eadbf *_fa .XObjectImage ;_dca *_fa .Image ;_dgb float64 ;_gfef ,_ffab float64 ;_ccgea ,_gcdc float64 ;_fdad Positioning ;_gege HorizontalAlignment ;_fcfa float64 ;_gefa float64 ;_ddddf float64 ;_gbba Margins ;_faef ,_bcfc float64 ;_fbfd _ea .StreamEncoder ;
_bdbe FitMode ;};

// IsRelative checks if the positioning is relative.
func (_adca Positioning )IsRelative ()bool {return _adca ==PositionRelative };

// SetTitleStyle sets the style properties of the invoice title.
func (_degb *Invoice )SetTitleStyle (style TextStyle ){_degb ._gbfbc =style };func _feab (_bgceg [][]_ce .Point )*Polygon {return &Polygon {_cgecf :&_ce .Polygon {Points :_bgceg },_bege :1.0,_dgcea :1.0};};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_ccf _ff .ChartRenderable ;_gbdd Positioning ;_ggf float64 ;_gfe float64 ;_ebga Margins ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_ecaf *RadialShading )AddShadingResource (block *Block )(_cbfd _ea .PdfObjectName ,_ccfe error ){_cfbc :=1;_cbfd =_ea .PdfObjectName ("\u0053\u0068"+_a .Itoa (_cfbc ));for block ._gae .HasShadingByName (_cbfd ){_cfbc ++;_cbfd =_ea .PdfObjectName ("\u0053\u0068"+_a .Itoa (_cfbc ));
};if _afbeb :=block ._gae .SetShadingByName (_cbfd ,_ecaf .shadingModel ().ToPdfObject ());_afbeb !=nil {return "",_afbeb ;};return _cbfd ,nil ;};

// GetOptimizer returns current PDF optimizer.
func (_egcc *Creator )GetOptimizer ()_fa .Optimizer {return _egcc ._effb };func (_abfc *StyledParagraph )getLineMetrics (_edga int )(_deae ,_aeeb ,_ccffg float64 ){if _abfc ._egffa ==nil ||len (_abfc ._egffa )==0{_abfc .wrapText ();};if _edga < 0||_edga > len (_abfc ._egffa )-1{_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_edga );
return 0,0,0;};_cgdag :=_abfc ._egffa [_edga ];for _ ,_bgeaa :=range _cgdag {_agfd :=_feada (_bgeaa .Style .Font ,_bgeaa .Style .FontSize );if _agfd ._cbaab > _deae {_deae =_agfd ._cbaab ;};if _agfd ._dgad < _ccffg {_ccffg =_agfd ._dgad ;};if _bgegg :=_bgeaa .Style .FontSize ;
_bgegg > _aeeb {_aeeb =_bgegg ;};};return _deae ,_aeeb ,_ccffg ;};func _gcgbc (_gfdbc *templateProcessor ,_abeaa *templateNode )(interface{},error ){return _gfdbc .parsePageBreak (_abeaa );};

// Level returns the indentation level of the TOC line.
func (_ddcgf *TOCLine )Level ()uint {return _ddcgf ._dabge };

// Width returns the width of the Paragraph.
func (_dcgc *Paragraph )Width ()float64 {if _dcgc ._fade &&int (_dcgc ._gdffb )> 0{return _dcgc ._gdffb ;};return _dcgc .getTextWidth ()/1000.0;};func _abgb (_fadb *Block ,_fdfd *Image ,_cagg DrawContext )(DrawContext ,error ){_bffg :=_cagg ;_fbff :=1;
_dfeb :=_ea .PdfObjectName (_g .Sprintf ("\u0049\u006d\u0067%\u0064",_fbff ));for _fadb ._gae .HasXObjectByName (_dfeb ){_fbff ++;_dfeb =_ea .PdfObjectName (_g .Sprintf ("\u0049\u006d\u0067%\u0064",_fbff ));};_abaf :=_fadb ._gae .SetXObjectImageByName (_dfeb ,_fdfd ._eadbf );
if _abaf !=nil {return _cagg ,_abaf ;};_dddf :=0;_bgdad :=_ea .PdfObjectName (_g .Sprintf ("\u0047\u0053\u0025\u0064",_dddf ));for _fadb ._gae .HasExtGState (_bgdad ){_dddf ++;_bgdad =_ea .PdfObjectName (_g .Sprintf ("\u0047\u0053\u0025\u0064",_dddf ));
};_fdd :=_ea .MakeDict ();_fdd .Set ("\u0042\u004d",_ea .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _fdfd ._ddddf < 1.0{_fdd .Set ("\u0043\u0041",_ea .MakeFloat (_fdfd ._ddddf ));_fdd .Set ("\u0063\u0061",_ea .MakeFloat (_fdfd ._ddddf ));};_abaf =_fadb ._gae .AddExtGState (_bgdad ,_ea .MakeIndirectObject (_fdd ));
if _abaf !=nil {return _cagg ,_abaf ;};_bcfcg :=_fdfd .Width ();_fgecbf :=_fdfd .Height ();_ ,_gfad :=_fdfd .rotatedSize ();_bfde :=_cagg .X ;_babb :=_cagg .PageHeight -_cagg .Y -_fgecbf ;if _fdfd ._fdad .IsRelative (){_babb -=(_gfad -_fgecbf )/2;switch _fdfd ._gege {case HorizontalAlignmentCenter :_bfde +=(_cagg .Width -_bcfcg )/2;
case HorizontalAlignmentRight :_bfde =_cagg .PageWidth -_cagg .Margins .Right -_fdfd ._gbba .Right -_bcfcg ;};};_bbaa :=_fdfd ._dgb ;_eggc :=_bd .NewContentCreator ();_eggc .Add_gs (_bgdad );_eggc .Translate (_bfde ,_babb );if _bbaa !=0{_eggc .Translate (_bcfcg /2,_fgecbf /2);
_eggc .RotateDeg (_bbaa );_eggc .Translate (-_bcfcg /2,-_fgecbf /2);};_eggc .Scale (_bcfcg ,_fgecbf ).Add_Do (_dfeb );_eedc :=_eggc .Operations ();_eedc .WrapIfNeeded ();_fadb .addContents (_eedc );if _fdfd ._fdad .IsRelative (){_cagg .Y +=_gfad ;_cagg .Height -=_gfad ;
return _cagg ,nil ;};return _bffg ,nil ;};

// Scale scales Image by a constant factor, both width and height.
func (_gdcbb *Image )Scale (xFactor ,yFactor float64 ){_gdcbb ._gfef =xFactor *_gdcbb ._gfef ;_gdcbb ._ffab =yFactor *_gdcbb ._ffab ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_efdc *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efdc ._eefa .Left ,_efdc ._eefa .Right ,_efdc ._eefa .Top ,_efdc ._eefa .Bottom ;};

// BorderColor returns the border color of the ellipse.
func (_agbb *Ellipse )BorderColor ()Color {return _agbb ._edcd };func (_ebge *Block )translate (_bfd ,_eeb float64 ){_cbc :=_bd .NewContentCreator ().Translate (_bfd ,-_eeb ).Operations ();*_ebge ._ffc =append (*_cbc ,*_ebge ._ffc ...);_ebge ._ffc .WrapIfNeeded ();
};

// NewImage create a new image from a unidoc image (model.Image).
func (_cebb *Creator )NewImage (img *_fa .Image )(*Image ,error ){return _aagg (img )};

// FitMode returns the fit mode of the rectangle.
func (_bagga *Rectangle )FitMode ()FitMode {return _bagga ._gcdg };func (_fead *Line )computeCoords (_aeca DrawContext )(_gfab ,_abafg ,_ggae ,_dddec float64 ){_gfab =_aeca .X ;_ggae =_gfab +_fead ._gagg -_fead ._dfbf ;_dgdf :=_fead ._baec ;if _fead ._dfbf ==_fead ._gagg {_dgdf /=2;
};if _fead ._aeecg < _fead ._cbaff {_abafg =_aeca .PageHeight -_aeca .Y -_dgdf ;_dddec =_abafg -_fead ._cbaff +_fead ._aeecg ;}else {_dddec =_aeca .PageHeight -_aeca .Y -_dgdf ;_abafg =_dddec -_fead ._aeecg +_fead ._cbaff ;};switch _fead ._bfeb {case FitModeFillWidth :_ggae =_gfab +_aeca .Width ;
};return _gfab ,_abafg ,_ggae ,_dddec ;};func (_fbea *Invoice )setCellBorder (_fcga *TableCell ,_befdb *InvoiceCell ){for _ ,_babg :=range _befdb .BorderSides {_fcga .SetBorder (_babg ,CellBorderStyleSingle ,_befdb .BorderWidth );};_fcga .SetBorderColor (_befdb .BorderColor );
};

// SetLineWidth sets the line width.
func (_gbefa *Line )SetLineWidth (width float64 ){_gbefa ._baec =width };

// NewCurvePolygon creates a new curve polygon.
func (_fef *Creator )NewCurvePolygon (rings [][]_ce .CubicBezierCurve )*CurvePolygon {return _fbagb (rings );};func (_gabb *Invoice )generateNoteBlocks (_eeda DrawContext )([]*Block ,DrawContext ,error ){_daag :=_cecg ();_bgca :=append ([][2]string {_gabb ._ebcg ,_gabb ._befe },_gabb ._gdag ...);
for _ ,_edfa :=range _bgca {if _edfa [1]!=""{_aaea :=_gabb .drawSection (_edfa [0],_edfa [1]);for _ ,_cggb :=range _aaea {_daag .Add (_cggb );};_gggb :=_defdc (_gabb ._ggac );_gggb .SetMargins (0,0,10,0);_daag .Add (_gggb );};};return _daag .GeneratePageBlocks (_eeda );
};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_ceeab *Paragraph )Height ()float64 {_ceeab .wrapText ();return float64 (len (_ceeab ._gbdea ))*_ceeab ._ecegc *_ceeab ._cgcbd ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_decbd *Line )Width ()float64 {return _ec .Abs (_decbd ._gagg -_decbd ._dfbf )};func (_gbbgff *Paragraph )wrapText ()error {if !_gbbgff ._fade ||int (_gbbgff ._gdffb )<=0{_gbbgff ._gbdea =[]string {_gbbgff ._babfa };return nil ;};_cggba :=NewTextChunk (_gbbgff ._babfa ,TextStyle {Font :_gbbgff ._gcedf ,FontSize :_gbbgff ._cgcbd });
_defe ,_cacfa :=_cggba .Wrap (_gbbgff ._gdffb );if _cacfa !=nil {return _cacfa ;};if _gbbgff ._ebfbg > 0&&len (_defe )> _gbbgff ._ebfbg {_defe =_defe [:_gbbgff ._ebfbg ];};_gbbgff ._gbdea =_defe ;return nil ;};

// NewCell returns a new invoice table cell.
func (_eddd *Invoice )NewCell (value string )*InvoiceCell {return _eddd .newCell (value ,_eddd .NewCellProps ());};

// SetLineHeight sets the line height (1.0 default).
func (_gfbb *StyledParagraph )SetLineHeight (lineheight float64 ){_gfbb ._gbcb =lineheight };

// NewTOC creates a new table of contents.
func (_ged *Creator )NewTOC (title string )*TOC {_gfg :=_ged .NewTextStyle ();_gfg .Font =_ged ._gaba ;return _babadc (title ,_ged .NewTextStyle (),_gfg );};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_dgfd *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _daa (xc ,yc ,width ,height );};

// SellerAddress returns the seller address used in the invoice template.
func (_fdfc *Invoice )SellerAddress ()*InvoiceAddress {return _fdfc ._aecb };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_cadfg *_ce .PolyBezierCurve ;_egff float64 ;_dagfe float64 ;_bafc Color ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_affag *Table )MultiCell (rowspan ,colspan int )*TableCell {_affag ._aeba ++;_cbgb :=(_affag .moveToNextAvailableCell ()-1)%(_affag ._beege )+1;_dgbfg :=(_affag ._aeba -1)/_affag ._beege +1;for _dgbfg > _affag ._cccb {_affag ._cccb ++;_affag ._cddcg =append (_affag ._cddcg ,_affag ._efbgd );
};_ceec :=&TableCell {};_ceec ._cceef =_dgbfg ;_ceec ._baceb =_cbgb ;_ceec ._ddbeg =5;_ceec ._cbbdb =CellBorderStyleNone ;_ceec ._gegge =_ce .LineStyleSolid ;_ceec ._dedb =CellHorizontalAlignmentLeft ;_ceec ._ecbg =CellVerticalAlignmentTop ;_ceec ._fceg =0;
_ceec ._gegf =0;_ceec ._bebbd =0;_ceec ._faeaf =0;_edgdf :=ColorBlack ;_ceec ._cgce =_edgdf ;_ceec ._cfaea =_edgdf ;_ceec ._egddb =_edgdf ;_ceec ._bbcfdd =_edgdf ;if rowspan < 1{_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_afac :=_affag ._cccb -(_ceec ._cceef -1);if rowspan > _afac {_eef .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_afac );
_affag ._cccb +=rowspan -1;for _fccd :=0;_fccd <=rowspan -_afac ;_fccd ++{_affag ._cddcg =append (_affag ._cddcg ,_affag ._efbgd );};};for _baad :=0;_baad < colspan &&_cbgb +_baad -1< len (_affag ._cgbff );_baad ++{_affag ._cgbff [_cbgb +_baad -1]=rowspan -1;
};_ceec ._badd =rowspan ;if colspan < 1{_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_fcabe :=_affag ._beege -(_ceec ._baceb -1);if colspan > _fcabe {_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_fcabe );
colspan =_fcabe ;};_ceec ._gfeb =colspan ;_affag ._aeba +=colspan -1;_affag ._bdfef =append (_affag ._bdfef ,_ceec );_ceec ._edfg =_affag ;return _ceec ;};

// Width returns the cell's width based on the input draw context.
func (_fdaad *TableCell )Width (ctx DrawContext )float64 {_fbgc :=float64 (0.0);for _agff :=0;_agff < _fdaad ._gfeb ;_agff ++{_fbgc +=_fdaad ._edfg ._gaecf [_fdaad ._baceb +_agff -1];};_fegb :=ctx .Width *_fbgc ;return _fegb ;};

// NewImageFromFile creates an Image from a file.
func (_bcbfg *Creator )NewImageFromFile (path string )(*Image ,error ){return _acgfb (path )};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dda *Creator )NewStyledParagraph ()*StyledParagraph {return _defdc (_dda .NewTextStyle ())};

// Length calculates and returns the length of the line.
func (_bdad *Line )Length ()float64 {return _ec .Sqrt (_ec .Pow (_bdad ._gagg -_bdad ._dfbf ,2.0)+_ec .Pow (_bdad ._cbaff -_bdad ._aeecg ,2.0));};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_dfgf *_ce .Polyline ;_ggba float64 ;};func (_cdga *Table )clone ()*Table {_cgccg :=*_cdga ;_cgccg ._cddcg =make ([]float64 ,len (_cdga ._cddcg ));copy (_cgccg ._cddcg ,_cdga ._cddcg );_cgccg ._gaecf =make ([]float64 ,len (_cdga ._gaecf ));
copy (_cgccg ._gaecf ,_cdga ._gaecf );_cgccg ._bdfef =make ([]*TableCell ,0,len (_cdga ._bdfef ));for _ ,_cfdc :=range _cdga ._bdfef {_egfaa :=*_cfdc ;_egfaa ._edfg =&_cgccg ;_cgccg ._bdfef =append (_cgccg ._bdfef ,&_egfaa );};return &_cgccg ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_cccb int ;_beege int ;_aeba int ;_gaecf []float64 ;_cddcg []float64 ;_efbgd float64 ;_bdfef []*TableCell ;_cgbff []int ;_dbgb Positioning ;_dcbdd ,_dfdc float64 ;_fefca Margins ;_acgfbd bool ;_adaae int ;_begg int ;_dbac bool ;_cbca bool ;
};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_ddae Drawable )(Drawable ,error );};

// SetText replaces all the text of the paragraph with the specified one.
func (_ebagf *StyledParagraph )SetText (text string )*TextChunk {_ebagf .Reset ();return _ebagf .Append (text );};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_adge *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _e .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_adge ._acgfbd =true ;_adge ._adaae =startRow ;_adge ._begg =endRow ;return nil ;};func (_ccdc *templateProcessor )parseColor (_agdge string )Color {if _agdge ==""{return nil ;};_egbg ,_gfae :=_ccdc ._cbdga .ColorMap [_agdge ];if _gfae {return _egbg ;
};if _agdge [0]=='#'{return ColorRGBFromHex (_agdge );};return nil ;};func _dbdee (_cdgf *Block ,_ebfbb *Paragraph ,_efbae DrawContext )(DrawContext ,error ){_bcgab :=1;_cadc :=_ea .PdfObjectName ("\u0046\u006f\u006e\u0074"+_a .Itoa (_bcgab ));for _cdgf ._gae .HasFontByName (_cadc ){_bcgab ++;
_cadc =_ea .PdfObjectName ("\u0046\u006f\u006e\u0074"+_a .Itoa (_bcgab ));};_gebec :=_cdgf ._gae .SetFontByName (_cadc ,_ebfbb ._gcedf .ToPdfObject ());if _gebec !=nil {return _efbae ,_gebec ;};_ebfbb .wrapText ();_ddcc :=_bd .NewContentCreator ();_ddcc .Add_q ();
_dgac :=_efbae .PageHeight -_efbae .Y -_ebfbb ._cgcbd *_ebfbb ._ecegc ;_ddcc .Translate (_efbae .X ,_dgac );if _ebfbb ._dgdea !=0{_ddcc .RotateDeg (_ebfbb ._dgdea );};_acaca :=_gdfa (_ebfbb ._beaa );_gebec =_ddcd (_cdgf ,_acaca ,_ebfbb ._beaa ,func ()Rectangle {return Rectangle {_dfbc :_efbae .X ,_gbfgg :_dgac ,_faaa :_ebfbb .getMaxLineWidth ()/1000.0,_baag :_ebfbb .Height ()};
});if _gebec !=nil {return _efbae ,_gebec ;};_ddcc .Add_BT ().SetNonStrokingColor (_acaca ).Add_Tf (_cadc ,_ebfbb ._cgcbd ).Add_TL (_ebfbb ._cgcbd *_ebfbb ._ecegc );for _bbbe ,_abfb :=range _ebfbb ._gbdea {if _bbbe !=0{_ddcc .Add_Tstar ();};_cddb :=[]rune (_abfb );
_dfbag :=0.0;_daceb :=0;for _gbaa ,_dbga :=range _cddb {if _dbga ==' '{_daceb ++;continue ;};if _dbga =='\u000A'{continue ;};_fbage ,_bbca :=_ebfbb ._gcedf .GetRuneMetrics (_dbga );if !_bbca {_eef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_gbaa ,_dbga ,_dbga ,_ebfbb ._gcedf .BaseFont (),_ebfbb ._gcedf .Subtype ());
return _efbae ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dfbag +=_ebfbb ._cgcbd *_fbage .Wx ;};var _cdbf []_ea .PdfObject ;_ggace ,_ceee :=_ebfbb ._gcedf .GetRuneMetrics (' ');
if !_ceee {return _efbae ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ffaf :=_ggace .Wx ;switch _ebfbb ._fbgf {case TextAlignmentJustify :if _daceb > 0&&_bbbe < len (_ebfbb ._gbdea )-1{_ffaf =(_ebfbb ._gdffb *1000.0-_dfbag )/float64 (_daceb )/_ebfbb ._cgcbd ;
};case TextAlignmentCenter :_faed :=_dfbag +float64 (_daceb )*_ffaf *_ebfbb ._cgcbd ;_afeef :=(_ebfbb ._gdffb *1000.0-_faed )/2/_ebfbb ._cgcbd ;_cdbf =append (_cdbf ,_ea .MakeFloat (-_afeef ));case TextAlignmentRight :_add :=_dfbag +float64 (_daceb )*_ffaf *_ebfbb ._cgcbd ;
_edcc :=(_ebfbb ._gdffb *1000.0-_add )/_ebfbb ._cgcbd ;_cdbf =append (_cdbf ,_ea .MakeFloat (-_edcc ));};_ecee :=_ebfbb ._gcedf .Encoder ();var _gfgba []byte ;for _ ,_daggc :=range _cddb {if _daggc =='\u000A'{continue ;};if _daggc ==' '{if len (_gfgba )> 0{_cdbf =append (_cdbf ,_ea .MakeStringFromBytes (_gfgba ));
_gfgba =nil ;};_cdbf =append (_cdbf ,_ea .MakeFloat (-_ffaf ));}else {if _ ,_gega :=_ecee .RuneToCharcode (_daggc );!_gega {_gebec =UnsupportedRuneError {Message :_g .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_daggc ,_daggc ),Rune :_daggc };
_efbae ._bdfb =append (_efbae ._bdfb ,_gebec );_eef .Log .Debug (_gebec .Error ());if _efbae ._bfdb <=0{continue ;};_daggc =_efbae ._bfdb ;};_gfgba =append (_gfgba ,_ecee .Encode (string (_daggc ))...);};};if len (_gfgba )> 0{_cdbf =append (_cdbf ,_ea .MakeStringFromBytes (_gfgba ));
};_ddcc .Add_TJ (_cdbf ...);};_ddcc .Add_ET ();_ddcc .Add_Q ();_cebf :=_ddcc .Operations ();_cebf .WrapIfNeeded ();_cdgf .addContents (_cebf );if _ebfbb ._aacf .IsRelative (){_befa :=_ebfbb .Height ();_efbae .Y +=_befa ;_efbae .Height -=_befa ;if _efbae .Inline {_efbae .X +=_ebfbb .Width ()+_ebfbb ._fbba .Right ;
};};return _efbae ,nil ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_fcgc *Division )EnablePageWrap (enable bool ){_fcgc ._gfbg =enable };func (_dbc *Block )duplicate ()*Block {_dg :=&Block {};*_dg =*_dbc ;_gc :=_bd .ContentStreamOperations {};_gc =append (_gc ,*_dbc ._ffc ...);_dg ._ffc =&_gc ;return _dg ;};func (_aedfe *templateProcessor )parseFitModeAttr (_beega ,_agdb string )FitMode {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_beega ,_agdb );
_ffcfge :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_agdb ];return _ffcfge ;};func (_dacbd *TOCLine )getLineLink ()*_fa .PdfAnnotation {if _dacbd ._gdda <=0{return nil ;
};return _ccbeg (_dacbd ._gdda -1,_dacbd ._faga ,_dacbd ._eeaa ,0);};

// GeneratePageBlocks draw graphic svg into block.
func (_caaf *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_baba :=ctx ;_gabf :=_caaf ._gacf .IsRelative ();var _bafg []*Block ;if _gabf {_dddg :=1.0;_abga :=_caaf ._eefa .Top ;if _caaf ._baea .Height > ctx .Height -_caaf ._eefa .Top {_bafg =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _dgce error ;if _ ,ctx ,_dgce =_ddge ().GeneratePageBlocks (ctx );_dgce !=nil {return nil ,ctx ,_dgce ;};_abga =0;};ctx .X +=_caaf ._eefa .Left +_dddg ;ctx .Y +=_abga ;ctx .Width -=_caaf ._eefa .Left +_caaf ._eefa .Right +2*_dddg ;ctx .Height -=_abga ;
}else {ctx .X =_caaf ._gfgc ;ctx .Y =_caaf ._dffe ;};_aefd :=_bd .NewContentCreator ();_aefd .Translate (0,ctx .PageHeight );_aefd .Scale (1,-1);_aefd .Translate (ctx .X ,ctx .Y );_agecf :=_caaf ._baea .Width /_caaf ._baea .ViewBox .W ;_efad :=_caaf ._baea .Height /_caaf ._baea .ViewBox .H ;
_afd :=_caaf ._gfgc -(_caaf ._baea .ViewBox .X *_ec .Max (_agecf ,_efad ));_faf :=_caaf ._dffe -(_caaf ._baea .ViewBox .Y *_ec .Max (_agecf ,_efad ));_caaf ._baea .ToContentCreator (_aefd ,_agecf ,_efad ,_afd ,_faf );_ecfed :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _eddg :=_ecfed .addContentsByString (_aefd .String ());_eddg !=nil {return nil ,ctx ,_eddg ;};if _gabf {_cgeg :=_caaf .Height ()+_caaf ._eefa .Bottom ;ctx .Y +=_cgeg ;ctx .Height -=_cgeg ;}else {ctx =_baba ;};_bafg =append (_bafg ,_ecfed );return _bafg ,ctx ,nil ;
};

// SetMargins sets the margins of the paragraph.
func (_dbbbad *List )SetMargins (left ,right ,top ,bottom float64 ){_dbbbad ._eead .Left =left ;_dbbbad ._eead .Right =right ;_dbbbad ._eead .Top =top ;_dbbbad ._eead .Bottom =bottom ;};

// AddColorStop add color stop info for rendering gradient color.
func (_cgbc *RadialShading )AddColorStop (color Color ,point float64 ){_cgbc ._gcbg .AddColorStop (color ,point );};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_efgeb *Creator )MoveRight (dx float64 ){_efgeb ._gbb .X +=dx };

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _ecgd (svgStr )};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_fgab *Division )Add (d VectorDrawable )error {switch _afbe :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_geed ,_dffa :=_afbe .ContainerComponent (_fgab );
if _dffa !=nil {return _dffa ;};_abfea ,_acgg :=_geed .(VectorDrawable );if !_acgg {return _g .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_geed );
};d =_abfea ;default:return _e .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_fgab ._cga =append (_fgab ._cga ,d );return nil ;};func _egcg (_bfgf _cd .Image )(*Image ,error ){_eedf ,_cce :=_fa .ImageHandling .NewImageFromGoImage (_bfgf );
if _cce !=nil {return nil ,_cce ;};return _aagg (_eedf );};

// Text sets the text content of the Paragraph.
func (_bffd *Paragraph )Text ()string {return _bffd ._babfa };

// SetAnnotation sets a annotation on a TextChunk.
func (_gecga *TextChunk )SetAnnotation (annotation *_fa .PdfAnnotation ){_gecga ._gbgga =annotation };func (_bgb *Chapter )headingText ()string {_baf :=_bgb ._ebfe ;if _dad :=_bgb .headingNumber ();_dad !=""{_baf =_g .Sprintf ("\u0025\u0073\u0020%\u0073",_dad ,_baf );
};return _baf ;};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_cbff Color ;_deee float64 ;};func _gdb (_bga *_bd .ContentStreamOperations ,_fda *_fa .PdfPageResources ,_ebf *_bd .ContentStreamOperations ,_eff *_fa .PdfPageResources )error {_dac :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};
_cbf :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};_bde :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};_bfe :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};_ade :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};_fae :=map[_ea .PdfObjectName ]_ea .PdfObjectName {};
for _ ,_agd :=range *_ebf {switch _agd .Operand {case "\u0044\u006f":if len (_agd .Params )==1{if _dd ,_dge :=_agd .Params [0].(*_ea .PdfObjectName );_dge {if _ ,_bbcg :=_dac [*_dd ];!_bbcg {var _dbcf _ea .PdfObjectName ;_geba ,_ :=_eff .GetXObjectByName (*_dd );
if _geba !=nil {_dbcf =*_dd ;for {_bbd ,_ :=_fda .GetXObjectByName (_dbcf );if _bbd ==nil ||_bbd ==_geba {break ;};_dbcf =*_ea .MakeName (_ebgb (_dbcf .String ()));};};_fda .SetXObjectByName (_dbcf ,_geba );_dac [*_dd ]=_dbcf ;};_dbeg :=_dac [*_dd ];_agd .Params [0]=&_dbeg ;
};};case "\u0054\u0066":if len (_agd .Params )==2{if _cdae ,_eebd :=_agd .Params [0].(*_ea .PdfObjectName );_eebd {if _ ,_gcf :=_cbf [*_cdae ];!_gcf {_bbcd ,_fged :=_eff .GetFontByName (*_cdae );_gag :=*_cdae ;if _fged &&_bbcd !=nil {_gag =_fca (_cdae .String (),_bbcd ,_fda );
};_fda .SetFontByName (_gag ,_bbcd );_cbf [*_cdae ]=_gag ;};_cdc :=_cbf [*_cdae ];_agd .Params [0]=&_cdc ;};};case "\u0043\u0053","\u0063\u0073":if len (_agd .Params )==1{if _gbc ,_fce :=_agd .Params [0].(*_ea .PdfObjectName );_fce {if _ ,_fgc :=_bde [*_gbc ];
!_fgc {var _ecf _ea .PdfObjectName ;_cfbg ,_efg :=_eff .GetColorspaceByName (*_gbc );if _efg {_ecf =*_gbc ;for {_ffcc ,_adc :=_fda .GetColorspaceByName (_ecf );if !_adc ||_cfbg ==_ffcc {break ;};_ecf =*_ea .MakeName (_ebgb (_ecf .String ()));};_fda .SetColorspaceByName (_ecf ,_cfbg );
_bde [*_gbc ]=_ecf ;}else {_eef .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _gdf ,_ageb :=_bde [*_gbc ];_ageb {_agd .Params [0]=&_gdf ;}else {_eef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gbc );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_agd .Params )==1{if _afc ,_eae :=_agd .Params [0].(*_ea .PdfObjectName );_eae {if _ ,_eed :=_bfe [*_afc ];!_eed {var _aeg _ea .PdfObjectName ;_fdg ,_agec :=_eff .GetPatternByName (*_afc );if _agec {_aeg =*_afc ;
for {_adb ,_dgg :=_fda .GetPatternByName (_aeg );if !_dgg ||_adb ==_fdg {break ;};_aeg =*_ea .MakeName (_ebgb (_aeg .String ()));};_bfg :=_fda .SetPatternByName (_aeg ,_fdg .ToPdfObject ());if _bfg !=nil {return _bfg ;};_bfe [*_afc ]=_aeg ;};};if _aeb ,_abgd :=_bfe [*_afc ];
_abgd {_agd .Params [0]=&_aeb ;};};};case "\u0073\u0068":if len (_agd .Params )==1{if _bdc ,_dbff :=_agd .Params [0].(*_ea .PdfObjectName );_dbff {if _ ,_bdg :=_ade [*_bdc ];!_bdg {var _gdbe _ea .PdfObjectName ;_cgcc ,_acc :=_eff .GetShadingByName (*_bdc );
if _acc {_gdbe =*_bdc ;for {_fdc ,_aga :=_fda .GetShadingByName (_gdbe );if !_aga ||_cgcc ==_fdc {break ;};_gdbe =*_ea .MakeName (_ebgb (_gdbe .String ()));};_egc :=_fda .SetShadingByName (_gdbe ,_cgcc .ToPdfObject ());if _egc !=nil {_eef .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_egc );
return _egc ;};_ade [*_bdc ]=_gdbe ;}else {_eef .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cbfa ,_cac :=_ade [*_bdc ];_cac {_agd .Params [0]=&_cbfa ;}else {_eef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_bdc );
};};};case "\u0067\u0073":if len (_agd .Params )==1{if _ed ,_gda :=_agd .Params [0].(*_ea .PdfObjectName );_gda {if _ ,_befca :=_fae [*_ed ];!_befca {var _gfd _ea .PdfObjectName ;_ece ,_cba :=_eff .GetExtGState (*_ed );if _cba {_gfd =*_ed ;for {_ace ,_dfe :=_fda .GetExtGState (_gfd );
if !_dfe ||_ece ==_ace {break ;};_gfd =*_ea .MakeName (_ebgb (_gfd .String ()));};};_fda .AddExtGState (_gfd ,_ece );_fae [*_ed ]=_gfd ;};_gbdc :=_fae [*_ed ];_agd .Params [0]=&_gbdc ;};};};*_bga =append (*_bga ,_agd );};return nil ;};func (_gbag *Table )sortCells (){_d .Slice (_gbag ._bdfef ,func (_fbace ,_fgdae int )bool {_dedca :=_gbag ._bdfef [_fbace ]._cceef ;
_dcec :=_gbag ._bdfef [_fgdae ]._cceef ;if _dedca < _dcec {return true ;};if _dedca > _dcec {return false ;};return _gbag ._bdfef [_fbace ]._baceb < _gbag ._bdfef [_fgdae ]._baceb ;});};func _befgd (_cfcad *_df .File )([]*_fa .PdfPage ,error ){_daea ,_eacbe :=_fa .NewPdfReader (_cfcad );
if _eacbe !=nil {return nil ,_eacbe ;};_ffgge ,_eacbe :=_daea .GetNumPages ();if _eacbe !=nil {return nil ,_eacbe ;};var _faccd []*_fa .PdfPage ;for _aegf :=0;_aegf < _ffgge ;_aegf ++{_dcdgc ,_fcgca :=_daea .GetPage (_aegf +1);if _fcgca !=nil {return nil ,_fcgca ;
};_faccd =append (_faccd ,_dcdgc );};return _faccd ,nil ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetFillColor sets the fill color of the ellipse.
func (_dadg *Ellipse )SetFillColor (col Color ){_dadg ._cbeb =col };

// SetBorderRadius sets the radius of the rectangle corners.
func (_bgecd *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_bgecd ._efcb =topLeft ;_bgecd ._caab =topRight ;_bgecd ._ebagc =bottomLeft ;_bgecd ._bafe =bottomRight ;};func (_bbea *Creator )setActivePage (_dgde *_fa .PdfPage ){_bbea ._aca =_dgde };
const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetWidth sets line width.
func (_eadec *Curve )SetWidth (width float64 ){_eadec ._geeb =width };

// BuyerAddress returns the buyer address used in the invoice template.
func (_dfba *Invoice )BuyerAddress ()*InvoiceAddress {return _dfba ._gcfe };func (_gfeg *StyledParagraph )getMaxLineWidth ()float64 {if _gfeg ._egffa ==nil ||len (_gfeg ._egffa )==0{_gfeg .wrapText ();};var _deeeg float64 ;for _ ,_ecdge :=range _gfeg ._egffa {_acbf :=_gfeg .getTextLineWidth (_ecdge );
if _acbf > _deeeg {_deeeg =_acbf ;};};return _deeeg ;};

// Horizontal returns total horizontal (left + right) margin.
func (_edde *Margins )Horizontal ()float64 {return _edde .Left +_edde .Right };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_gaefa *LinearShading )AddPatternResource (block *Block )(_bffad _ea .PdfObjectName ,_afbec error ){_eag :=1;_dafd :=_ea .PdfObjectName ("\u0050"+_a .Itoa (_eag ));for block ._gae .HasPatternByName (_dafd ){_eag ++;_dafd =_ea .PdfObjectName ("\u0050"+_a .Itoa (_eag ));
};if _ccff :=block ._gae .SetPatternByName (_dafd ,_gaefa .ToPdfShadingPattern ().ToPdfObject ());_ccff !=nil {return "",_ccff ;};return _dafd ,nil ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gaea *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gaea ._eadbf ==nil {if _fefa :=_gaea .makeXObject ();_fefa !=nil {return nil ,ctx ,_fefa ;};};var _dgag []*Block ;_gcbc :=ctx ;_eac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gaea ._fdad .IsRelative (){_gaea .applyFitMode (ctx .Width );ctx .X +=_gaea ._gbba .Left ;ctx .Y +=_gaea ._gbba .Top ;ctx .Width -=_gaea ._gbba .Left +_gaea ._gbba .Right ;ctx .Height -=_gaea ._gbba .Top +_gaea ._gbba .Bottom ;if _gaea ._ffab > ctx .Height {_dgag =append (_dgag ,_eac );
_eac =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cbfg :=ctx ;_cbfg .Y =ctx .Margins .Top +_gaea ._gbba .Top ;_cbfg .X =ctx .Margins .Left +_gaea ._gbba .Left ;_cbfg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gaea ._gbba .Top -_gaea ._gbba .Bottom ;
_cbfg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gaea ._gbba .Left -_gaea ._gbba .Right ;ctx =_cbfg ;};}else {ctx .X =_gaea ._fcfa ;ctx .Y =_gaea ._gefa ;};ctx ,_ebcb :=_abgb (_eac ,_gaea ,ctx );if _ebcb !=nil {return nil ,ctx ,_ebcb ;
};_dgag =append (_dgag ,_eac );if _gaea ._fdad .IsAbsolute (){ctx =_gcbc ;}else {ctx .X =_gcbc .X ;ctx .Width =_gcbc .Width ;ctx .Y +=_gaea ._gbba .Bottom ;};return _dgag ,ctx ,nil ;};func (_adfed *StyledParagraph )wrapChunks (_bddb bool )error {if !_adfed ._dgba ||int (_adfed ._fdfbb )<=0{_adfed ._egffa =[][]*TextChunk {_adfed ._cfbcg };
return nil ;};if _adfed ._ebgbe {_adfed .wrapWordChunks ();};_adfed ._egffa =[][]*TextChunk {};var _acab []*TextChunk ;var _bafb float64 ;_fcfe :=_efe .IsSpace ;if !_bddb {_fcfe =func (rune )bool {return false };};_dafdf :=_dgaf (_adfed ._fdfbb *1000.0,0.000001);
for _ ,_afcea :=range _adfed ._cfbcg {_bdgae :=_afcea .Style ;_bffac :=_afcea ._gbgga ;_dgced :=_afcea .VerticalAlignment ;var (_gcfg []rune ;_fgcbe []float64 ;);_deaea :=_bfed (_afcea .Text );for _ ,_cgged :=range _afcea .Text {if _cgged =='\u000A'{if !_bddb {_gcfg =append (_gcfg ,_cgged );
};_acab =append (_acab ,&TextChunk {Text :_dc .TrimRightFunc (string (_gcfg ),_fcfe ),Style :_bdgae ,_gbgga :_bdfgc (_bffac ),VerticalAlignment :_dgced });_adfed ._egffa =append (_adfed ._egffa ,_acab );_acab =nil ;_bafb =0;_gcfg =nil ;_fgcbe =nil ;continue ;
};_cbbg :=_cgged ==' ';_cgccd ,_bgcegb :=_bdgae .Font .GetRuneMetrics (_cgged );if !_bgcegb {_eef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cgged );
return _e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_gfece :=_bdgae .FontSize *_cgccd .Wx *_bdgae .horizontalScale ();_gfba :=_gfece ;if !_cbbg {_gfba =_gfece +_bdgae .CharSpacing *1000.0;
};if _bafb +_gfece > _dafdf {_acgad :=-1;if !_cbbg {for _eccb :=len (_gcfg )-1;_eccb >=0;_eccb --{if _gcfg [_eccb ]==' '{_acgad =_eccb ;break ;};};};if _adfed ._ebgbe {_gfac :=len (_acab );if _gfac > 0{_acab [_gfac -1].Text =_dc .TrimRightFunc (_acab [_gfac -1].Text ,_fcfe );
_adfed ._egffa =append (_adfed ._egffa ,_acab );_acab =[]*TextChunk {};};_gcfg =append (_gcfg ,_cgged );_fgcbe =append (_fgcbe ,_gfba );if _acgad >=0{_gcfg =_gcfg [_acgad +1:];_fgcbe =_fgcbe [_acgad +1:];};_bafb =0;for _ ,_beea :=range _fgcbe {_bafb +=_beea ;
};if _bafb > _dafdf {_feac :=string (_gcfg [:len (_gcfg )-1]);_feac =_ecdag (_feac ,_deaea );if !_bddb &&_cbbg {_feac +="\u0020";};_acab =append (_acab ,&TextChunk {Text :_dc .TrimRightFunc (_feac ,_fcfe ),Style :_bdgae ,_gbgga :_bdfgc (_bffac ),VerticalAlignment :_dgced });
_adfed ._egffa =append (_adfed ._egffa ,_acab );_acab =[]*TextChunk {};_gcfg =[]rune {_cgged };_fgcbe =[]float64 {_gfba };_bafb =_gfba ;};continue ;};_defdcg :=string (_gcfg );if _acgad >=0{_defdcg =string (_gcfg [0:_acgad +1]);_gcfg =_gcfg [_acgad +1:];
_gcfg =append (_gcfg ,_cgged );_fgcbe =_fgcbe [_acgad +1:];_fgcbe =append (_fgcbe ,_gfba );_bafb =0;for _ ,_aegbd :=range _fgcbe {_bafb +=_aegbd ;};}else {if _cbbg {_bafb =0;_gcfg =[]rune {};_fgcbe =[]float64 {};}else {_bafb =_gfba ;_gcfg =[]rune {_cgged };
_fgcbe =[]float64 {_gfba };};};_defdcg =_ecdag (_defdcg ,_deaea );if !_bddb &&_cbbg {_defdcg +="\u0020";};_acab =append (_acab ,&TextChunk {Text :_dc .TrimRightFunc (_defdcg ,_fcfe ),Style :_bdgae ,_gbgga :_bdfgc (_bffac ),VerticalAlignment :_dgced });
_adfed ._egffa =append (_adfed ._egffa ,_acab );_acab =[]*TextChunk {};}else {_bafb +=_gfba ;_gcfg =append (_gcfg ,_cgged );_fgcbe =append (_fgcbe ,_gfba );};};if len (_gcfg )> 0{_cceeb :=_ecdag (string (_gcfg ),_deaea );_acab =append (_acab ,&TextChunk {Text :_cceeb ,Style :_bdgae ,_gbgga :_bdfgc (_bffac ),VerticalAlignment :_dgced });
};};if len (_acab )> 0{_adfed ._egffa =append (_adfed ._egffa ,_acab );};return nil ;};func (_gbfgb *templateProcessor )parseCellAlignmentAttr (_bgbed ,_cabde string )CellHorizontalAlignment {_eef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bgbed ,_cabde );
_bfcca :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_cabde ];return _bfcca ;
};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_ccce *Image )SetPos (x ,y float64 ){_ccce ._fdad =PositionAbsolute ;_ccce ._fcfa =x ;_ccce ._gefa =y ;};const (DefaultHorizontalScaling =100;);

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_cgag *Ellipse )FillOpacity ()float64 {return _cgag ._facc };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_fcg *Creator )SetForms (form *_fa .PdfAcroForm )error {_fcg ._adea =form ;return nil };

// Padding returns the padding of the component.
func (_dbbg *Division )Padding ()(_cggcad ,_gfga ,_bgdg ,_efggc float64 ){return _dbbg ._dgfg .Left ,_dbbg ._dgfg .Right ,_dbbg ._dgfg .Top ,_dbbg ._dgfg .Bottom ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_acce *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _cfcbe (colorPoints );};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetBorderColor sets the border color for the path.
func (_gcac *FilledCurve )SetBorderColor (color Color ){_gcac ._baed =color };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_bcfb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ebde *_fa .PdfWriter )error ){_bcfb ._gbgd =pdfWriterAccessFunc ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_geaa *Creator )MoveTo (x ,y float64 ){_geaa ._gbb .X =x ;_geaa ._gbb .Y =y };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_dgecg *shading )SetBackgroundColor (backgroundColor Color ){_dgecg ._cfcbc =backgroundColor };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_aae *Creator )Finalize ()error {if _aae ._beb {return nil ;};_fffc :=len (_aae ._ccgg );_dagd :=0;if _aae ._fcaa !=nil {_edded :=*_aae ;_aae ._ccgg =nil ;_aae ._aca =nil ;_aae .initContext ();_dcb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fffc };
_aae ._fcaa (_dcb );_dagd +=len (_aae ._ccgg );_aae ._ccgg =_edded ._ccgg ;_aae ._aca =_edded ._aca ;};if _aae .AddTOC {_aae .initContext ();_aae ._gbb .Page =_dagd +1;if _aae .CustomTOC &&_aae ._eccg !=nil {_fcgd :=*_aae ;_aae ._ccgg =nil ;_aae ._aca =nil ;
if _bgd :=_aae ._eccg (_aae ._bbgg );_bgd !=nil {return _bgd ;};_dagd +=len (_aae ._ccgg );_aae ._ccgg =_fcgd ._ccgg ;_aae ._aca =_fcgd ._aca ;}else {if _aae ._eccg !=nil {if _cacf :=_aae ._eccg (_aae ._bbgg );_cacf !=nil {return _cacf ;};};_gaa ,_ ,_fcd :=_aae ._bbgg .GeneratePageBlocks (_aae ._gbb );
if _fcd !=nil {_eef .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_fcd );return _fcd ;};_dagd +=len (_gaa );};_dedc :=_aae ._bbgg .Lines ();
for _ ,_gdfd :=range _dedc {_fbd ,_cdaec :=_a .Atoi (_gdfd .Page .Text );if _cdaec !=nil {continue ;};_gdfd .Page .Text =_a .Itoa (_fbd +_dagd );_gdfd ._gdda +=int64 (_dagd );};};_gabc :=false ;var _adgf []*_fa .PdfPage ;if _aae ._fcaa !=nil {_dfc :=*_aae ;
_aae ._ccgg =nil ;_aae ._aca =nil ;_edbg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fffc };_aae ._fcaa (_edbg );_fffc +=len (_aae ._ccgg );_adgf =_aae ._ccgg ;_aae ._ccgg =append (_aae ._ccgg ,_dfc ._ccgg ...);_aae ._aca =_dfc ._aca ;_gabc =true ;
};var _gfa []*_fa .PdfPage ;if _aae .AddTOC {_aae .initContext ();if _aae .CustomTOC &&_aae ._eccg !=nil {_accb :=*_aae ;_aae ._ccgg =nil ;_aae ._aca =nil ;if _eeged :=_aae ._eccg (_aae ._bbgg );_eeged !=nil {_eef .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_eeged );
return _eeged ;};_gfa =_aae ._ccgg ;_fffc +=len (_gfa );_aae ._ccgg =_accb ._ccgg ;_aae ._aca =_accb ._aca ;}else {if _aae ._eccg !=nil {if _dgea :=_aae ._eccg (_aae ._bbgg );_dgea !=nil {_eef .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_dgea );
return _dgea ;};};_fcb ,_ ,_ :=_aae ._bbgg .GeneratePageBlocks (_aae ._gbb );for _ ,_cfac :=range _fcb {_cfac .SetPos (0,0);_fffc ++;_fad :=_aae .newPage ();_gfa =append (_gfa ,_fad );_aae .setActivePage (_fad );_aae .Draw (_cfac );};};if _gabc {_cbb :=_adgf ;
_eceb :=_aae ._ccgg [len (_adgf ):];_aae ._ccgg =append ([]*_fa .PdfPage {},_cbb ...);_aae ._ccgg =append (_aae ._ccgg ,_gfa ...);_aae ._ccgg =append (_aae ._ccgg ,_eceb ...);}else {_aae ._ccgg =append (_gfa ,_aae ._ccgg ...);};};if _aae ._ffgcf !=nil &&_aae .AddOutlines {var _fbfe func (_cddc *_fa .OutlineItem );
_fbfe =func (_facf *_fa .OutlineItem ){_facf .Dest .Page +=int64 (_dagd );if _fdfb :=int (_facf .Dest .Page );_fdfb >=0&&_fdfb < len (_aae ._ccgg ){_facf .Dest .PageObj =_aae ._ccgg [_fdfb ].GetPageAsIndirectObject ();}else {_eef .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fdfb );
};_facf .Dest .Y =_aae ._bbdg -_facf .Dest .Y ;_befd :=_facf .Items ();for _ ,_aec :=range _befd {_fbfe (_aec );};};_gdba :=_aae ._ffgcf .Items ();for _ ,_aecd :=range _gdba {_fbfe (_aecd );};if _aae .AddTOC {var _cedg int ;if _gabc {_cedg =len (_adgf );
};_efggg :=_fa .NewOutlineDest (int64 (_cedg ),0,_aae ._bbdg );if _cedg >=0&&_cedg < len (_aae ._ccgg ){_efggg .PageObj =_aae ._ccgg [_cedg ].GetPageAsIndirectObject ();}else {_eef .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cedg );
};_aae ._ffgcf .Insert (0,_fa .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_efggg ));};};for _cef ,_edg :=range _aae ._ccgg {_aae .setActivePage (_edg );if _aae ._geab !=nil {_edf ,_aecde ,_gaf :=_edg .Size ();
if _gaf !=nil {return _gaf ;};_gdce :=PageFinalizeFunctionArgs {PageNum :_cef +1,PageWidth :_edf ,PageHeight :_aecde ,TOCPages :len (_gfa ),TotalPages :_fffc };if _gdgb :=_aae ._geab (_gdce );_gdgb !=nil {_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_gdgb );
return _gdgb ;};};if _aae ._feef !=nil {_bda :=NewBlock (_aae ._ggfe ,_aae ._bcbf .Top );_gcbb :=HeaderFunctionArgs {PageNum :_cef +1,TotalPages :_fffc };_aae ._feef (_bda ,_gcbb );_bda .SetPos (0,0);if _egeb :=_aae .Draw (_bda );_egeb !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_egeb );
return _egeb ;};};if _aae ._ddb !=nil {_bbgf :=NewBlock (_aae ._ggfe ,_aae ._bcbf .Bottom );_gfcg :=FooterFunctionArgs {PageNum :_cef +1,TotalPages :_fffc };_aae ._ddb (_bbgf ,_gfcg );_bbgf .SetPos (0,_aae ._bbdg -_bbgf ._dec );if _dga :=_aae .Draw (_bbgf );
_dga !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dga );return _dga ;};};_cebd ,_eaaa :=_aae ._fgec [_edg ];if _fdbb ,_ebeb :=_aae ._ecd [_edg ];_ebeb {if _eaaa {_cebd .transformBlock (_fdbb );
};if _ggbg :=_fdbb .drawToPage (_edg );_ggbg !=nil {_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cef +1,_ggbg );
return _ggbg ;};};if _eaaa {if _edgf :=_cebd .transformPage (_edg );_edgf !=nil {_eef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_edgf );
return _edgf ;};};};_aae ._beb =true ;return nil ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_bcec *GraphicSVG )ScaleToHeight (h float64 ){_gcab :=_bcec ._baea .Width /_bcec ._baea .Height ;_bcec ._baea .Height =h ;_bcec ._baea .Width =h *_gcab ;_bcec ._baea .SetScaling (_gcab ,_gcab );};

// DashPattern returns the dash pattern of the line.
func (_ecca *Line )DashPattern ()(_ageg []int64 ,_bfbd int64 ){return _ecca ._efgeg ,_ecca ._gfee };func (_bafab *templateProcessor )parseInt64Array (_cagd ,_gcge string )[]int64 {_eef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cagd ,_gcge );
_dcea :=_dc .Fields (_gcge );_bcbff :=make ([]int64 ,0,len (_dcea ));for _ ,_eggb :=range _dcea {_cdgef ,_ :=_a .ParseInt (_eggb ,10,64);_bcbff =append (_bcbff ,_cdgef );};return _bcbff ;};

// SetFillColor sets the fill color.
func (_gddd *Polygon )SetFillColor (color Color ){_gddd ._beba =color ;_gddd ._cgecf .FillColor =_gdfa (color );};func _ddbgb (_bfdc *templateProcessor ,_ebdee *templateNode )(interface{},error ){return _bfdc .parseTableCell (_ebdee );};

// SetBorderOpacity sets the border opacity.
func (_gbfbca *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_gbfbca ._dagfe =opacity };

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_dcdec *RadialShading )ToPdfShadingPattern ()*_fa .PdfShadingPatternType3 {_abfbd ,_dbcg ,_aefa :=_dcdec ._gcbg ._cfcbc .ToRGB ();_eeca :=_dcdec .shadingModel ();_eeca .PdfShading .Background =_ea .MakeArrayFromFloats ([]float64 {_abfbd ,_dbcg ,_aefa });
_feee :=_fa .NewPdfShadingPatternType3 ();_feee .Shading =_eeca ;return _feee ;};

// Width returns the Block's width.
func (_fb *Block )Width ()float64 {return _fb ._bc };

// Context returns the current drawing context.
func (_fdcfg *Creator )Context ()DrawContext {return _fdcfg ._gbb };

// SetWidth sets the width of the ellipse.
func (_gcaf *Ellipse )SetWidth (width float64 ){_gcaf ._bgea =width };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_bg :=&Block {};_bg ._ffc =&_bd .ContentStreamOperations {};_bg ._gae =_fa .NewPdfPageResources ();_bg ._bc =width ;_bg ._dec =height ;return _bg ;};

// SetBorderColor sets the border color.
func (_bdbg *PolyBezierCurve )SetBorderColor (color Color ){_bdbg ._cadfg .BorderColor =_gdfa (color )};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_cfbaf *Table )EnablePageWrap (enable bool ){_cfbaf ._cbca =enable };

// SetNotes sets the notes section of the invoice.
func (_dggae *Invoice )SetNotes (title ,content string ){_dggae ._ebcg =[2]string {title ,content }};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_dbag *_ce .CurvePolygon ;_bcfd float64 ;_eggf float64 ;_ddbg Color ;};func _gdga (_fefb VectorDrawable ,_ecebe float64 )float64 {switch _ccgb :=_fefb .(type ){case *Paragraph :if _ccgb ._fade {_ccgb .SetWidth (_ecebe -_ccgb ._fbba .Left -_ccgb ._fbba .Right );
};return _ccgb .Height ()+_ccgb ._fbba .Top +_ccgb ._fbba .Bottom ;case *StyledParagraph :if _ccgb ._dgba {_ccgb .SetWidth (_ecebe -_ccgb ._faaba .Left -_ccgb ._faaba .Right );};return _ccgb .Height ()+_ccgb ._faaba .Top +_ccgb ._faaba .Bottom ;case *Image :_ccgb .applyFitMode (_ecebe );
return _ccgb .Height ()+_ccgb ._gbba .Top +_ccgb ._gbba .Bottom ;case *Rectangle :_ccgb .applyFitMode (_ecebe );return _ccgb .Height ()+_ccgb ._bacfa .Top +_ccgb ._bacfa .Bottom +_ccgb ._aebcg ;case *Ellipse :_ccgb .applyFitMode (_ecebe );return _ccgb .Height ()+_ccgb ._dfac .Top +_ccgb ._dfac .Bottom ;
case *Division :return _ccgb .ctxHeight (_ecebe )+_ccgb ._cdef .Top +_ccgb ._cdef .Bottom +_ccgb ._dgfg .Top +_ccgb ._dgfg .Bottom ;case *Table :_ccgb .updateRowHeights (_ecebe -_ccgb ._fefca .Left -_ccgb ._fefca .Right );return _ccgb .Height ()+_ccgb ._fefca .Top +_ccgb ._fefca .Bottom ;
case *List :return _ccgb .ctxHeight (_ecebe )+_ccgb ._eead .Top +_ccgb ._eead .Bottom ;case marginDrawable :_ ,_ ,_fcba ,_cfbgc :=_ccgb .GetMargins ();return _ccgb .Height ()+_fcba +_cfbgc ;default:return _ccgb .Height ();};};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gbgga *_fa .PdfAnnotation ;_gdffd bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// Margins returns the margins of the component.
func (_bdeg *Division )Margins ()(_bcda ,_bdbb ,_dgfa ,_bfgc float64 ){return _bdeg ._cdef .Left ,_bdeg ._cdef .Right ,_bdeg ._cdef .Top ,_bdeg ._cdef .Bottom ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_fgg *Creator )RotateDeg (angleDeg int64 )error {_ebgd :=_fgg .getActivePage ();if _ebgd ==nil {_eef .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_eef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gca int64 ;if _ebgd .Rotate !=nil {_gca =*(_ebgd .Rotate );};_gca +=angleDeg ;_ebgd .Rotate =&_gca ;return nil ;};func (_ggdag *shading )generatePdfFunctions ()[]_fa .PdfFunction {if len (_ggdag ._fbdg )==0{return nil ;
}else if len (_ggdag ._fbdg )<=2{_bfbb ,_ebdd ,_ffff :=_ggdag ._fbdg [0]._cbff .ToRGB ();_gdadc ,_ccad ,_bbeac :=_ggdag ._fbdg [len (_ggdag ._fbdg )-1]._cbff .ToRGB ();return []_fa .PdfFunction {&_fa .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_bfbb ,_ebdd ,_ffff },C1 :[]float64 {_gdadc ,_ccad ,_bbeac }}};
}else {_dfgd :=[]_fa .PdfFunction {};_cbfge :=[]float64 {};for _ddeae :=0;_ddeae < len (_ggdag ._fbdg )-1;_ddeae ++{_dead ,_dded ,_aedf :=_ggdag ._fbdg [_ddeae ]._cbff .ToRGB ();_afcc ,_gfge ,_ffdb :=_ggdag ._fbdg [_ddeae +1]._cbff .ToRGB ();_gdbf :=&_fa .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_dead ,_dded ,_aedf },C1 :[]float64 {_afcc ,_gfge ,_ffdb }};
_dfgd =append (_dfgd ,_gdbf );if _ddeae > 0{_cbfge =append (_cbfge ,_ggdag ._fbdg [_ddeae ]._deee );};};_ggbb :=[]float64 {};for range _dfgd {_ggbb =append (_ggbb ,[]float64 {0.0,1.0}...);};return []_fa .PdfFunction {&_fa .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_dfgd ,Bounds :_cbfge ,Encode :_ggbb }};
};};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// SetBorderWidth sets the border width of the ellipse.
func (_aag *Ellipse )SetBorderWidth (bw float64 ){_aag ._cadd =bw };func _fbac (_abccg Color ,_afag float64 )*ColorPoint {return &ColorPoint {_cbff :_abccg ,_deee :_afag }};

// AddColorStop add color stop information for rendering gradient.
func (_ddddb *shading )AddColorStop (color Color ,point float64 ){_ddddb ._fbdg =append (_ddddb ._fbdg ,_fbac (color ,point ));};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cbfgeg *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cbfgeg ._dedb =halign ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_ffda *Creator )Draw (d Drawable )error {if _ffda .getActivePage ()==nil {_ffda .NewPage ();};_fbfee ,_gcfb ,_ggfa :=d .GeneratePageBlocks (_ffda ._gbb );if _ggfa !=nil {return _ggfa ;};if len (_gcfb ._bdfb )> 0{_ffda .Errors =append (_ffda .Errors ,_gcfb ._bdfb ...);
};for _dbgg ,_fcgb :=range _fbfee {if _dbgg > 0{_ffda .NewPage ();};_bfa :=_ffda .getActivePage ();if _fcf ,_cgf :=_ffda ._ecd [_bfa ];_cgf {if _aebf :=_fcf .mergeBlocks (_fcgb );_aebf !=nil {return _aebf ;};if _bcfg :=_eebf (_fcgb ._gae ,_fcf ._gae );
_bcfg !=nil {return _bcfg ;};}else {_ffda ._ecd [_bfa ]=_fcgb ;};};_ffda ._gbb .X =_gcfb .X ;_ffda ._gbb .Y =_gcfb .Y ;_ffda ._gbb .Height =_gcfb .PageHeight -_gcfb .Y -_gcfb .Margins .Bottom ;return nil ;};func (_ddce *templateProcessor )parseBackground (_abggc *templateNode )(interface{},error ){_defcb :=&Background {};
for _ ,_ceff :=range _abggc ._facfb .Attr {_eddef :=_ceff .Value ;switch _gdfaa :=_ceff .Name .Local ;_gdfaa {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_defcb .FillColor =_ddce .parseColorAttr (_gdfaa ,_eddef );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_defcb .BorderColor =_ddce .parseColorAttr (_gdfaa ,_eddef );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_defcb .BorderSize =_ddce .parseFloatAttr (_gdfaa ,_eddef );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ffed ,_fbafe ,_ccbed ,_feeef :=_ddce .parseBorderRadiusAttr (_gdfaa ,_eddef );
_defcb .SetBorderRadius (_ffed ,_fbafe ,_feeef ,_ccbed );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_defcb .BorderRadiusTopLeft =_ddce .parseFloatAttr (_gdfaa ,_eddef );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_defcb .BorderRadiusTopRight =_ddce .parseFloatAttr (_gdfaa ,_eddef );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_defcb .BorderRadiusBottomLeft =_ddce .parseFloatAttr (_gdfaa ,_eddef );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_defcb .BorderRadiusBottomRight =_ddce .parseFloatAttr (_gdfaa ,_eddef );
default:_ddce .nodeLogDebug (_abggc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gdfaa );
};};return _defcb ,nil ;};

// SetLogo sets the logo of the invoice.
func (_acgd *Invoice )SetLogo (logo *Image ){_acgd ._fabc =logo };func (_bdag *Table )wrapContent (_afggf DrawContext )error {if _bdag ._dbac {return nil ;};_bdag .sortCells ();_eafad :=func (_ddcb *TableCell ,_bbega int ,_gfgf int ,_fcdb int )(_bfaea int ){if _fcdb < 1{return -1;
};_egea :=0;for _abcgd :=_gfgf +1;_abcgd < len (_bdag ._bdfef )-1;_abcgd ++{_fbee :=_bdag ._bdfef [_abcgd ];if _fbee ._cceef ==_fcdb &&_egea !=_gfgf {_egea =_abcgd ;if (_fbee ._baceb < _ddcb ._baceb &&_bdag ._beege > _fbee ._baceb )||_ddcb ._baceb < _bdag ._beege {continue ;
};break ;};};_aabg :=float64 (0.0);for _dafc :=0;_dafc < _ddcb ._badd ;_dafc ++{_aabg +=_bdag ._cddcg [_ddcb ._cceef +_dafc -1];};_afff :=_ddcb .width (_bdag ._gaecf ,_afggf .Width );var (_ebab VectorDrawable ;_fbacc =false ;);switch _gcfec :=_ddcb ._cead .(type ){case *StyledParagraph :_fcgef :=_afggf ;
_fcgef .Height =_ec .Floor (_aabg -_gcfec ._faaba .Top -_gcfec ._faaba .Bottom -0.5*_gcfec .getTextHeight ());_fcgef .Width =_afff ;_gbddf ,_decf ,_gfeag :=_gcfec .split (_fcgef );if _gfeag !=nil {_eef .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_gfeag .Error ());
};if _gbddf !=nil &&_decf !=nil {_bdag ._bdfef [_gfgf ]._cead =_gbddf ;_ebab =_decf ;_fbacc =true ;};};_bdag ._bdfef [_gfgf ]._badd =_ddcb ._badd ;_afggf .Height =_afggf .PageHeight -_afggf .Margins .Top -_afggf .Margins .Bottom ;_eaagf :=_ddcb .cloneProps (nil );
if _fbacc {_eaagf ._cead =_ebab ;};_eaagf ._badd =_bbega ;_eaagf ._cceef =_fcdb +1;_eaagf ._baceb =_ddcb ._baceb ;if _eaagf ._cceef +_eaagf ._badd -1> _bdag ._cccb {for _egfb :=_bdag ._cccb ;_egfb < _eaagf ._cceef +_eaagf ._badd -1;_egfb ++{_bdag ._cccb ++;
_bdag ._cddcg =append (_bdag ._cddcg ,_bdag ._efbgd );};};_bdag ._bdfef =append (_bdag ._bdfef [:_egea +1],append ([]*TableCell {_eaagf },_bdag ._bdfef [_egea +1:]...)...);return _egea +1;};_baff :=func (_gggdd *TableCell ,_bfbbb int ,_agfc int ,_agagf float64 )(_ddeafe int ){_feccg :=_gggdd .width (_bdag ._gaecf ,_afggf .Width );
_fcec :=_agagf ;_feggc :=1;_dfgg :=_afggf .Height ;if _dfgg > 0{for _fcec > _dfgg {_fcec -=_afggf .Height ;_dfgg =_afggf .PageHeight -_afggf .Margins .Top -_afggf .Margins .Bottom ;_feggc ++;};};var (_gdec VectorDrawable ;_aedd =false ;);switch _fage :=_gggdd ._cead .(type ){case *StyledParagraph :_bbge :=_afggf ;
_bbge .Height =_ec .Floor (_afggf .Height -_fage ._faaba .Top -_fage ._faaba .Bottom -0.5*_fage .getTextHeight ());_bbge .Width =_feccg ;_eedbf ,_cbaa ,_dgaca :=_fage .split (_bbge );if _dgaca !=nil {_eef .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_dgaca .Error ());
};if _eedbf !=nil &&_cbaa !=nil {_bdag ._bdfef [_bfbbb ]._cead =_eedbf ;_gdec =_cbaa ;_aedd =true ;};};if _feggc < 2{return -1;};if _bdag ._bdfef [_bfbbb ]._cceef +_feggc -1> _bdag ._cccb {for _bbfe :=0;_bbfe < _feggc ;_bbfe ++{_bdag ._cccb ++;_bdag ._cddcg =append (_bdag ._cddcg ,_bdag ._efbgd );
};};_ddffb :=_agagf /float64 (_feggc );for _aedfb :=0;_aedfb < _feggc ;_aedfb ++{_bdag ._cddcg [_agfc +_aedfb -1]=_ddffb ;};_afggf .Height =_afggf .PageHeight -_afggf .Margins .Top -_afggf .Margins .Bottom ;_gdadf :=_gggdd .cloneProps (nil );if _aedd {_gdadf ._cead =_gdec ;
};_gdadf ._badd =1;_gdadf ._cceef =_agfc +_feggc -1;_gdadf ._baceb =_gggdd ._baceb ;_bdag ._bdfef =append (_bdag ._bdfef ,_gdadf );return len (_bdag ._bdfef );};_ddcbf :=1;_gabfa :=-1;for _accab :=0;_accab < len (_bdag ._bdfef );_accab ++{_badb :=_bdag ._bdfef [_accab ];
if _gabfa ==_accab {_ddcbf =_badb ._cceef ;};if _badb ._badd < 2{if _aeceb :=_bdag ._cddcg [_badb ._cceef -1];_aeceb > _afggf .Height {_gabfa =_baff (_badb ,_accab ,_badb ._cceef ,_aeceb );continue ;};continue ;};_gcbga :=float64 (0);for _abcac :=0;_abcac < _badb ._badd ;
_abcac ++{_gcbga +=_bdag ._cddcg [_badb ._cceef +_abcac -1];};_edgg :=float64 (0);for _gfaf :=_ddcbf -1;_gfaf < _badb ._cceef -1;_gfaf ++{_edgg +=_bdag ._cddcg [_gfaf ];};if _gcbga <=(_afggf .Height -_edgg ){continue ;};_ccgbg :=float64 (0.0);_cefa :=_badb ._badd ;
_dgfgd :=-1;_afccc :=1;for _eaead :=1;_eaead <=_badb ._badd ;_eaead ++{if (_ccgbg +_bdag ._cddcg [_badb ._cceef +_eaead -2])> (_afggf .Height -_edgg ){_afccc --;break ;};_dgfgd =_badb ._cceef +_eaead -1;_cefa =_badb ._badd -_eaead ;_ccgbg +=_bdag ._cddcg [_badb ._cceef +_eaead -2];
_afccc ++;};if _badb ._badd ==_cefa {_afggf .Height =_afggf .PageHeight -_afggf .Margins .Top -_afggf .Margins .Bottom ;_ddcbf =_badb ._cceef ;_accab --;continue ;};if _cefa > 0&&_badb ._badd > _afccc {_badb ._badd =_afccc ;_gabfa =_eafad (_badb ,_cefa ,_accab ,_dgfgd );
if _accab +1==_gabfa {_accab --;};};_ddcbf =_badb ._cceef ;};_bdag .sortCells ();return nil ;};func (_cbga *templateProcessor )parseRectangle (_afceac *templateNode )(interface{},error ){_decd :=_cbga .creator .NewRectangle (0,0,0,0);for _ ,_egbc :=range _afceac ._facfb .Attr {_efea :=_egbc .Value ;
switch _gdbb :=_egbc .Name .Local ;_gdbb {case "\u0078":_decd ._dfbc =_cbga .parseFloatAttr (_gdbb ,_efea );case "\u0079":_decd ._gbfgg =_cbga .parseFloatAttr (_gdbb ,_efea );case "\u0077\u0069\u0064t\u0068":_decd .SetWidth (_cbga .parseFloatAttr (_gdbb ,_efea ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_decd .SetHeight (_cbga .parseFloatAttr (_gdbb ,_efea ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_decd .SetFillColor (_cbga .parseColorAttr (_gdbb ,_efea ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_decd .SetFillOpacity (_cbga .parseFloatAttr (_gdbb ,_efea ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_decd .SetBorderColor (_cbga .parseColorAttr (_gdbb ,_efea ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_decd .SetBorderOpacity (_cbga .parseFloatAttr (_gdbb ,_efea ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_decd .SetBorderWidth (_cbga .parseFloatAttr (_gdbb ,_efea ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dbbgd ,_ceegc ,_fbeg ,_bcbg :=_cbga .parseBorderRadiusAttr (_gdbb ,_efea );
_decd .SetBorderRadius (_dbbgd ,_ceegc ,_bcbg ,_fbeg );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_decd ._efcb =_cbga .parseFloatAttr (_gdbb ,_efea );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_decd ._caab =_cbga .parseFloatAttr (_gdbb ,_efea );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_decd ._ebagc =_cbga .parseFloatAttr (_gdbb ,_efea );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_decd ._bafe =_cbga .parseFloatAttr (_gdbb ,_efea );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_decd .SetPositioning (_cbga .parsePositioningAttr (_gdbb ,_efea ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_decd .SetFitMode (_cbga .parseFitModeAttr (_gdbb ,_efea ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bage :=_cbga .parseMarginAttr (_gdbb ,_efea );
_decd .SetMargins (_bage .Left ,_bage .Right ,_bage .Top ,_bage .Bottom );default:_cbga .nodeLogDebug (_afceac ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_gdbb );
};};return _decd ,nil ;};func (_ddfbb *templateProcessor )parseChart (_afcb *templateNode )(interface{},error ){var _fbgga string ;for _ ,_fdgge :=range _afcb ._facfb .Attr {_fcdbe :=_fdgge .Value ;switch _cdfce :=_fdgge .Name .Local ;_cdfce {case "\u0073\u0072\u0063":_fbgga =_fcdbe ;
};};if _fbgga ==""{_ddfbb .nodeLogError (_afcb ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_cfee ;};_cdbac ,_acceb :=_ddfbb ._cbdga .ChartMap [_fbgga ];if !_acceb {_ddfbb .nodeLogError (_afcb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_fbgga );
return nil ,_cfee ;};_dcgbb :=NewChart (_cdbac );for _ ,_afcg :=range _afcb ._facfb .Attr {_ccab :=_afcg .Value ;switch _facce :=_afcg .Name .Local ;_facce {case "\u0078":_dcgbb .SetPos (_ddfbb .parseFloatAttr (_facce ,_ccab ),_dcgbb ._gfe );case "\u0079":_dcgbb .SetPos (_dcgbb ._ggf ,_ddfbb .parseFloatAttr (_facce ,_ccab ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dgcg :=_ddfbb .parseMarginAttr (_facce ,_ccab );_dcgbb .SetMargins (_dgcg .Left ,_dgcg .Right ,_dgcg .Top ,_dgcg .Bottom );case "\u0077\u0069\u0064t\u0068":_dcgbb ._ccf .SetWidth (int (_ddfbb .parseFloatAttr (_facce ,_ccab )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dcgbb ._ccf .SetHeight (int (_ddfbb .parseFloatAttr (_facce ,_ccab )));case "\u0073\u0072\u0063":break ;default:_ddfbb .nodeLogDebug (_afcb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_facce );
};};return _dcgbb ,nil ;};

// NewTable create a new Table with a specified number of columns.
func (_ccdb *Creator )NewTable (cols int )*Table {return _bgfa (cols )};

// Inline returns whether the inline mode of the division is active.
func (_bffa *Division )Inline ()bool {return _bffa ._dacf };

// SetMargins sets the Paragraph's margins.
func (_gabg *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gabg ._faaba .Left =left ;_gabg ._faaba .Right =right ;_gabg ._faaba .Top =top ;_gabg ._faaba .Bottom =bottom ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_cg *Block )SetMargins (left ,right ,top ,bottom float64 ){_cg ._fe .Left =left ;_cg ._fe .Right =right ;_cg ._fe .Top =top ;_cg ._fe .Bottom =bottom ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_fgb int ;_ebfe string ;_abd *Paragraph ;_cdde []Drawable ;_cdcc int ;_faea bool ;_abee bool ;_bcgd Positioning ;_dcfe ,_aeef float64 ;_dee Margins ;_eda *Chapter ;_gdaf *TOC ;_eaa *_fa .Outline ;_efcd *_fa .OutlineItem ;_feed uint ;
};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_edbe *StyledParagraph ;_agfbb []*TOCLine ;_fdfac TextStyle ;_agde TextStyle ;_dbfad TextStyle ;_dbdbc TextStyle ;_abgga string ;_gafab float64 ;_adgec Margins ;_cafed Positioning ;_bcgff TextStyle ;_cfgge bool ;};func (_caac *templateProcessor )parseImage (_aaab *templateNode )(interface{},error ){var _dcgd string ;
for _ ,_gaaf :=range _aaab ._facfb .Attr {_bagb :=_gaaf .Value ;switch _gcead :=_gaaf .Name .Local ;_gcead {case "\u0073\u0072\u0063":_dcgd =_bagb ;};};_ddgbe ,_ffcaf :=_caac .loadImageFromSrc (_dcgd );if _ffcaf !=nil {return nil ,_ffcaf ;};for _ ,_cddcc :=range _aaab ._facfb .Attr {_daab :=_cddcc .Value ;
switch _cddcb :=_cddcc .Name .Local ;_cddcb {case "\u0061\u006c\u0069g\u006e":_ddgbe .SetHorizontalAlignment (_caac .parseHorizontalAlignmentAttr (_cddcb ,_daab ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_ddgbe .SetOpacity (_caac .parseFloatAttr (_cddcb ,_daab ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_eece :=_caac .parseMarginAttr (_cddcb ,_daab );_ddgbe .SetMargins (_eece .Left ,_eece .Right ,_eece .Top ,_eece .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ddgbe .SetFitMode (_caac .parseFitModeAttr (_cddcb ,_daab ));
case "\u0078":_ddgbe .SetPos (_caac .parseFloatAttr (_cddcb ,_daab ),_ddgbe ._gefa );case "\u0079":_ddgbe .SetPos (_ddgbe ._fcfa ,_caac .parseFloatAttr (_cddcb ,_daab ));case "\u0077\u0069\u0064t\u0068":_ddgbe .SetWidth (_caac .parseFloatAttr (_cddcb ,_daab ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ddgbe .SetHeight (_caac .parseFloatAttr (_cddcb ,_daab ));case "\u0061\u006e\u0067l\u0065":_ddgbe .SetAngle (_caac .parseFloatAttr (_cddcb ,_daab ));case "\u0073\u0072\u0063":break ;default:_caac .nodeLogDebug (_aaab ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_cddcb );
};};return _ddgbe ,nil ;};func _eddb (_abggcd string )([]string ,error ){var (_cgfeb []string ;_agcff []rune ;);for _ ,_dfbcc :=range _abggcd {if _dfbcc =='\u000A'{if len (_agcff )> 0{_cgfeb =append (_cgfeb ,string (_agcff ));};_cgfeb =append (_cgfeb ,string (_dfbcc ));
_agcff =nil ;continue ;};_agcff =append (_agcff ,_dfbcc );};if len (_agcff )> 0{_cgfeb =append (_cgfeb ,string (_agcff ));};var _ebfba []string ;for _ ,_acegf :=range _cgfeb {_ebdf :=[]rune (_acegf );_afeddb :=_ab .NewScanner (_ebdf );var _aeag []rune ;
for _babcc :=0;_babcc < len (_ebdf );_babcc ++{_ ,_dabgc ,_ffeb :=_afeddb .Next ();if _ffeb !=nil {return nil ,_ffeb ;};if _dabgc ==_ab .BreakProhibited ||_efe .IsSpace (_ebdf [_babcc ]){_aeag =append (_aeag ,_ebdf [_babcc ]);if _efe .IsSpace (_ebdf [_babcc ]){_ebfba =append (_ebfba ,string (_aeag ));
_aeag =[]rune {};};continue ;}else {if len (_aeag )> 0{_ebfba =append (_ebfba ,string (_aeag ));};_aeag =[]rune {_ebdf [_babcc ]};};};if len (_aeag )> 0{_ebfba =append (_ebfba ,string (_aeag ));};};return _ebfba ,nil ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_fde *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_fge ,_ ,_dcf :=d .GeneratePageBlocks (ctx );if _dcf !=nil {return _dcf ;};if len (_fge )!=1{return _e .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
};for _ ,_dbe :=range _fge {if _dfa :=_fde .mergeBlocks (_dbe );_dfa !=nil {return _dfa ;};};return nil ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_gcbg *shading ;_beaeb *_fa .PdfRectangle ;_egce AnchorPoint ;_eebg float64 ;_dged float64 ;_ffdcgf float64 ;_cbbaf float64 ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_gebaa *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dddba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edeaf ,_fegc :=_dddba .setOpacity (_gebaa ._bege ,_gebaa ._dgcea );if _fegc !=nil {return nil ,ctx ,_fegc ;
};_cbeg :=_gebaa ._cgecf ;_cbeg .FillEnabled =_cbeg .FillColor !=nil ;_cbeg .BorderEnabled =_cbeg .BorderColor !=nil &&_cbeg .BorderWidth > 0;_faedc :=_cbeg .Points ;_fbaga :=_fa .PdfRectangle {};_efcc :=false ;for _gefc :=range _faedc {for _cfbd :=range _faedc [_gefc ]{_dcff :=&_faedc [_gefc ][_cfbd ];
_dcff .Y =ctx .PageHeight -_dcff .Y ;if !_efcc {_fbaga .Llx =_dcff .X ;_fbaga .Lly =_dcff .Y ;_fbaga .Urx =_dcff .X ;_fbaga .Ury =_dcff .Y ;_efcc =true ;}else {_fbaga .Llx =_ec .Min (_fbaga .Llx ,_dcff .X );_fbaga .Lly =_ec .Min (_fbaga .Lly ,_dcff .Y );
_fbaga .Urx =_ec .Max (_fbaga .Urx ,_dcff .X );_fbaga .Ury =_ec .Max (_fbaga .Ury ,_dcff .Y );};};};if _cbeg .FillEnabled {_bedef :=_ddcd (_dddba ,_gebaa ._cgecf .FillColor ,_gebaa ._beba ,func ()Rectangle {return Rectangle {_dfbc :_fbaga .Llx ,_gbfgg :_fbaga .Lly ,_faaa :_fbaga .Width (),_baag :_fbaga .Height ()};
});if _bedef !=nil {return nil ,ctx ,_bedef ;};};_fdbc ,_ ,_fegc :=_cbeg .Draw (_edeaf );if _fegc !=nil {return nil ,ctx ,_fegc ;};if _fegc =_dddba .addContentsByString (string (_fdbc ));_fegc !=nil {return nil ,ctx ,_fegc ;};return []*Block {_dddba },ctx ,nil ;
};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;func _aagg (_ebeac *_fa .Image )(*Image ,error ){_ggadb :=float64 (_ebeac .Width );_ecfg :=float64 (_ebeac .Height );return &Image {_dca :_ebeac ,_ccgea :_ggadb ,_gcdc :_ecfg ,_gfef :_ggadb ,_ffab :_ecfg ,_dgb :0,_ddddf :1.0,_fdad :PositionRelative },nil ;
};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_fceb *Creator )NewPolyBezierCurve (curves []_ce .CubicBezierCurve )*PolyBezierCurve {return _fedcg (curves );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_edc DrawContext )([]*Block ,DrawContext ,error );};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_abec :float64 (r )/255.0,_eafb :float64 (g )/255.0,_baa :float64 (b )/255.0};};type componentRenderer interface{Draw (_ggfbc Drawable )error ;};func (_cca *Invoice )drawSection (_ddc ,_deabe string )[]*StyledParagraph {var _fbfbb []*StyledParagraph ;
if _ddc !=""{_ddgac :=_defdc (_cca ._gaga );_ddgac .SetMargins (0,0,0,5);_ddgac .Append (_ddc );_fbfbb =append (_fbfbb ,_ddgac );};if _deabe !=""{_cgde :=_defdc (_cca ._bgeac );_cgde .Append (_deabe );_fbfbb =append (_fbfbb ,_cgde );};return _fbfbb ;};


// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_fcgcf *StyledParagraph )Height ()float64 {_fcgcf .wrapText ();var _abfbe float64 ;for _ ,_feabb :=range _fcgcf ._egffa {var _ffde float64 ;for _ ,_acfc :=range _feabb {_aadff :=_fcgcf ._gbcb *_acfc .Style .FontSize ;if _aadff > _ffde {_ffde =_aadff ;
};};_abfbe +=_ffde ;};return _abfbe ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_fgecb *FilledCurve )AppendCurve (curve _ce .CubicBezierCurve )*FilledCurve {_fgecb ._edeb =append (_fgecb ._edeb ,curve );return _fgecb ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bgfc *Block )Draw (d Drawable )error {_eca :=DrawContext {};_eca .Width =_bgfc ._bc ;_eca .Height =_bgfc ._dec ;_eca .PageWidth =_bgfc ._bc ;_eca .PageHeight =_bgfc ._dec ;_eca .X =0;_eca .Y =0;_dgd ,_ ,_geg :=d .GeneratePageBlocks (_eca );if _geg !=nil {return _geg ;
};if len (_dgd )!=1{return _e .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
};for _ ,_fbf :=range _dgd {if _fc :=_bgfc .mergeBlocks (_fbf );_fc !=nil {return _fc ;};};return nil ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dddb *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dddb ._gdcc [0],_dddb ._gdcc [1]};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_gdac *Creator )SetOutlineTree (outlineTree *_fa .PdfOutlineTreeNode ){_gdac ._abfe =outlineTree };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_dae *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_dae ._gege =alignment };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _cde ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_eafa :=&Creator {};_eafa ._ccgg =[]*_fa .PdfPage {};_eafa ._ecd =map[*_fa .PdfPage ]*Block {};_eafa ._fgec =map[*_fa .PdfPage ]*pageTransformations {};_eafa .SetPageSize (PageSizeLetter );
_dcde :=0.1*_eafa ._ggfe ;_eafa ._bcbf .Left =_dcde ;_eafa ._bcbf .Right =_dcde ;_eafa ._bcbf .Top =_dcde ;_eafa ._bcbf .Bottom =_dcde ;var _efd error ;_eafa ._aebd ,_efd =_fa .NewStandard14Font (_fa .HelveticaName );if _efd !=nil {_eafa ._aebd =_fa .DefaultFont ();
};_eafa ._gaba ,_efd =_fa .NewStandard14Font (_fa .HelveticaBoldName );if _efd !=nil {_eafa ._aebd =_fa .DefaultFont ();};_eafa ._bbgg =_eafa .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_eafa .AddOutlines =true ;_eafa ._ffgcf =_fa .NewOutline ();_ae .TrackUse (_cde );return _eafa ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_aacc *GraphicSVG )Scale (xFactor ,yFactor float64 ){_aacc ._baea .Width =xFactor *_aacc ._baea .Width ;_aacc ._baea .Height =yFactor *_aacc ._baea .Height ;_aacc ._baea .SetScaling (xFactor ,yFactor );};

// SetAngle sets Image rotation angle in degrees.
func (_caba *Image )SetAngle (angle float64 ){_caba ._dgb =angle };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ffcca *Ellipse )SetFitMode (fitMode FitMode ){_ffcca ._facg =fitMode };func _ccbeg (_bffc int64 ,_fabgd ,_dcdg ,_dgfdd float64 )*_fa .PdfAnnotation {_begf :=_fa .NewPdfAnnotationLink ();_bcadd :=_fa .NewBorderStyle ();_bcadd .SetBorderWidth (0);
_begf .BS =_bcadd .ToPdfObject ();if _bffc < 0{_bffc =0;};_begf .Dest =_ea .MakeArray (_ea .MakeInteger (_bffc ),_ea .MakeName ("\u0058\u0059\u005a"),_ea .MakeFloat (_fabgd ),_ea .MakeFloat (_dcdg ),_ea .MakeFloat (_dgfdd ));return _begf .PdfAnnotation ;
};

// CreateTableOfContents sets a function to generate table of contents.
func (_bae *Creator )CreateTableOfContents (genTOCFunc func (_abac *TOC )error ){_bae ._eccg =genTOCFunc ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_bbcc *Chart )Width ()float64 {return float64 (_bbcc ._ccf .Width ())};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);func (_edgc *templateProcessor )parseTextOverflowAttr (_gggbb ,_eacd string )TextOverflow {_eef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_gggbb ,_eacd );
_cfbac :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_eacd ];return _cfbac ;};type templateProcessor struct{creator *Creator ;_bbfa []byte ;_cbdga *TemplateOptions ;
_fcaeg componentRenderer ;_cdgag string ;};func _bdced (_bgfbb *templateProcessor ,_affaa *templateNode )(interface{},error ){return _bgfbb .parseListMarker (_affaa );};func (_aab *Image )applyFitMode (_bac float64 ){_bac -=_aab ._gbba .Left +_aab ._gbba .Right ;
switch _aab ._bdbe {case FitModeFillWidth :_aab .ScaleToWidth (_bac );};};func (_efac *Invoice )generateLineBlocks (_ddbe DrawContext )([]*Block ,DrawContext ,error ){_dcbb :=_bgfa (len (_efac ._cgcg ));_dcbb .SetMargins (0,0,25,0);for _ ,_efab :=range _efac ._cgcg {_efag :=_defdc (_efab .TextStyle );
_efag .SetMargins (0,0,1,0);_efag .Append (_efab .Value );_cgcba :=_dcbb .NewCell ();_cgcba .SetHorizontalAlignment (_efab .Alignment );_cgcba .SetBackgroundColor (_efab .BackgroundColor );_efac .setCellBorder (_cgcba ,_efab );_cgcba .SetContent (_efag );
};for _ ,_cagcg :=range _efac ._cgec {for _ ,_gfag :=range _cagcg {_agaab :=_defdc (_gfag .TextStyle );_agaab .SetMargins (0,0,3,2);_agaab .Append (_gfag .Value );_ebcd :=_dcbb .NewCell ();_ebcd .SetHorizontalAlignment (_gfag .Alignment );_ebcd .SetBackgroundColor (_gfag .BackgroundColor );
_efac .setCellBorder (_ebcd ,_gfag );_ebcd .SetContent (_agaab );};};return _dcbb .GeneratePageBlocks (_ddbe );};

// GetIndent get the cell's left indent.
func (_ebadd *TableCell )GetIndent ()float64 {return _ebadd ._ddbeg };

// Heading returns the heading component of the table of contents.
func (_ffdfb *TOC )Heading ()*StyledParagraph {return _ffdfb ._edbe };func (_fbafd *templateProcessor )parseBoolAttr (_eggda ,_affe string )bool {_eef .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_eggda ,_affe );
_ceafc ,_ :=_a .ParseBool (_affe );return _affe ==""||_ceafc ;};func (_beda *StyledParagraph )wrapText ()error {return _beda .wrapChunks (true )};func _acgfb (_afdf string )(*Image ,error ){_dabg ,_bbeg :=_df .Open (_afdf );if _bbeg !=nil {return nil ,_bbeg ;
};defer _dabg .Close ();_dedd ,_bbeg :=_fa .ImageHandling .Read (_dabg );if _bbeg !=nil {_eef .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bbeg );return nil ,_bbeg ;
};return _aagg (_dedd );};func _fbab (_gbgad *_f .Decoder )(int ,int ){return 0,0};

// Link returns link information for this line.
func (_abebd *TOCLine )Link ()(_dacg int64 ,_fbbec ,_ccedfa float64 ){return _abebd ._gdda ,_abebd ._faga ,_abebd ._eeaa ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_cbbfa *LinearShading )AddShadingResource (block *Block )(_ceae _ea .PdfObjectName ,_fbgb error ){_daebg :=1;_ceae =_ea .PdfObjectName ("\u0053\u0068"+_a .Itoa (_daebg ));for block ._gae .HasShadingByName (_ceae ){_daebg ++;_ceae =_ea .PdfObjectName ("\u0053\u0068"+_a .Itoa (_daebg ));
};if _cced :=block ._gae .SetShadingByName (_ceae ,_cbbfa .shadingModel ().ToPdfObject ());_cced !=nil {return "",_cced ;};return _ceae ,nil ;};func _fedcg (_daca []_ce .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cadfg :&_ce .PolyBezierCurve {Curves :_daca ,BorderColor :_fa .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_egff :1.0,_dagfe :1.0};
};

// NewList creates a new list.
func (_egge *Creator )NewList ()*List {return _ddaea (_egge .NewTextStyle ())};func (_caafa *templateProcessor )parseTextVerticalAlignmentAttr (_afcf ,_efadg string )TextVerticalAlignment {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_afcf ,_efadg );
_edccg :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_efadg ];return _edccg ;};

// Height returns the height of the chart.
func (_ebd *Chart )Height ()float64 {return float64 (_ebd ._ccf .Height ())};func (_cdag *LinearShading )shadingModel ()*_fa .PdfShadingType2 {_dbdb :=_ce .NewPoint (_cdag ._defa .Llx +_cdag ._defa .Width ()/2,_cdag ._defa .Lly +_cdag ._defa .Height ()/2);
_baeda :=_ce .NewPoint (_cdag ._defa .Llx ,_cdag ._defa .Lly +_cdag ._defa .Height ()/2).Add (-_dbdb .X ,-_dbdb .Y ).Rotate (_cdag ._gfgaf ).Add (_dbdb .X ,_dbdb .Y );_baeda =_ce .NewPoint (_ec .Max (_ec .Min (_baeda .X ,_cdag ._defa .Urx ),_cdag ._defa .Llx ),_ec .Max (_ec .Min (_baeda .Y ,_cdag ._defa .Ury ),_cdag ._defa .Lly ));
_fedd :=_ce .NewPoint (_cdag ._defa .Urx ,_cdag ._defa .Lly +_cdag ._defa .Height ()/2).Add (-_dbdb .X ,-_dbdb .Y ).Rotate (_cdag ._gfgaf ).Add (_dbdb .X ,_dbdb .Y );_fedd =_ce .NewPoint (_ec .Min (_ec .Max (_fedd .X ,_cdag ._defa .Llx ),_cdag ._defa .Urx ),_ec .Min (_ec .Max (_fedd .Y ,_cdag ._defa .Lly ),_cdag ._defa .Ury ));
_cgcgc :=_fa .NewPdfShadingType2 ();_cgcgc .PdfShading .ShadingType =_ea .MakeInteger (2);_cgcgc .PdfShading .ColorSpace =_fa .NewPdfColorspaceDeviceRGB ();_cgcgc .PdfShading .AntiAlias =_ea .MakeBool (_cdag ._dgbd ._eadef );_cgcgc .Coords =_ea .MakeArrayFromFloats ([]float64 {_baeda .X ,_baeda .Y ,_fedd .X ,_fedd .Y });
_cgcgc .Extend =_ea .MakeArray (_ea .MakeBool (_cdag ._dgbd ._ffcf [0]),_ea .MakeBool (_cdag ._dgbd ._ffcf [1]));_cgcgc .Function =_cdag ._dgbd .generatePdfFunctions ();return _cgcgc ;};func (_agbc *Invoice )generateInformationBlocks (_cff DrawContext )([]*Block ,DrawContext ,error ){_cffc :=_defdc (_agbc ._ggac );
_cffc .SetMargins (0,0,0,20);_ceccg :=_agbc .drawAddress (_agbc ._aecb );_ceccg =append (_ceccg ,_cffc );_ceccg =append (_ceccg ,_agbc .drawAddress (_agbc ._gcfe )...);_agaa :=_cecg ();for _ ,_bfaf :=range _ceccg {_agaa .Add (_bfaf );};_befef :=_agbc .drawInformation ();
_dffb :=_bgfa (2);_dffb .SetMargins (0,0,25,0);_cfdf :=_dffb .NewCell ();_cfdf .SetIndent (0);_cfdf .SetContent (_agaa );_cfdf =_dffb .NewCell ();_cfdf .SetContent (_befef );return _dffb .GeneratePageBlocks (_cff );};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_eee *Chapter )GetHeading ()*Paragraph {return _eee ._abd };

// Columns returns all the columns in the invoice line items table.
func (_edad *Invoice )Columns ()[]*InvoiceCell {return _edad ._cgcg };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_dgecb *Invoice )AddressHeadingStyle ()TextStyle {return _dgecb ._acaa };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_gbcbc *Table )MultiColCell (colspan int )*TableCell {return _gbcbc .MultiCell (1,colspan )};

// AddLine adds a new line with the provided style to the table of contents.
func (_gdcfc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_gdcfc ._agfbb =append (_gdcfc ._agfbb ,line );return line ;};

// GetRowHeight returns the height of the specified row.
func (_gfggd *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gfggd ._cddcg ){return 0,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gfggd ._cddcg [row -1],nil ;
};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_affg *Rectangle )Height ()float64 {return _affg ._baag };var PPI float64 =72;func _aaada (_ffeg string )(*GraphicSVG ,error ){_fbbe ,_gagbec :=_ga .ParseFromFile (_ffeg );if _gagbec !=nil {return nil ,_gagbec ;};return _dbcb (_fbbe );};func _daffb (_bdfd string )*_fa .PdfAnnotation {_fcaaf :=_fa .NewPdfAnnotationLink ();
_ddbcd :=_fa .NewBorderStyle ();_ddbcd .SetBorderWidth (0);_fcaaf .BS =_ddbcd .ToPdfObject ();_gffed :=_fa .NewPdfActionURI ();_gffed .URI =_ea .MakeString (_bdfd );_fcaaf .SetAction (_gffed .PdfAction );return _fcaaf .PdfAnnotation ;};

// SetWidthLeft sets border width for left.
func (_bcf *border )SetWidthLeft (bw float64 ){_bcf ._feg =bw };

// Lines returns all the rows of the invoice line items table.
func (_cdaebg *Invoice )Lines ()[][]*InvoiceCell {return _cdaebg ._cgec };

// SetRowHeight sets the height for a specified row.
func (_gbcdf *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_gbcdf ._cddcg ){return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gbcdf ._cddcg [row -1]=h ;return nil ;
};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_cadgf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_egac []*Block ;_cgfg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_agbbg =ctx ;_bfae =_cadgf ._aebcg /2;);_eabd :=_cadgf ._fdde .IsRelative ();if _eabd {_cadgf .applyFitMode (ctx .Width );
ctx .X +=_cadgf ._bacfa .Left +_bfae ;ctx .Y +=_cadgf ._bacfa .Top +_bfae ;ctx .Width -=_cadgf ._bacfa .Left +_cadgf ._bacfa .Right ;ctx .Height -=_cadgf ._bacfa .Top +_cadgf ._bacfa .Bottom ;if _cadgf ._baag > ctx .Height {_egac =append (_egac ,_cgfg );
_cgfg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ebcgc :=ctx ;_ebcgc .Y =ctx .Margins .Top +_cadgf ._bacfa .Top +_bfae ;_ebcgc .X =ctx .Margins .Left +_cadgf ._bacfa .Left +_bfae ;_ebcgc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cadgf ._bacfa .Top -_cadgf ._bacfa .Bottom ;
_ebcgc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cadgf ._bacfa .Left -_cadgf ._bacfa .Right ;ctx =_ebcgc ;};}else {ctx .X =_cadgf ._dfbc ;ctx .Y =_cadgf ._gbfgg ;};_dbcag :=_ce .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cadgf ._baag ,Width :_cadgf ._faaa ,Height :_cadgf ._baag ,BorderRadiusTopLeft :_cadgf ._efcb ,BorderRadiusTopRight :_cadgf ._caab ,BorderRadiusBottomLeft :_cadgf ._ebagc ,BorderRadiusBottomRight :_cadgf ._bafe ,Opacity :1.0};
if _cadgf ._abbg !=nil {_dbcag .FillEnabled =true ;_fdef :=_gdfa (_cadgf ._abbg );_acggd :=_ddcd (_cgfg ,_fdef ,_cadgf ._abbg ,func ()Rectangle {return Rectangle {_dfbc :_dbcag .X ,_gbfgg :_dbcag .Y ,_faaa :_dbcag .Width ,_baag :_dbcag .Height };});if _acggd !=nil {return nil ,ctx ,_acggd ;
};_dbcag .FillColor =_fdef ;};if _cadgf ._bada !=nil &&_cadgf ._aebcg > 0{_dbcag .BorderEnabled =true ;_dbcag .BorderColor =_gdfa (_cadgf ._bada );_dbcag .BorderWidth =_cadgf ._aebcg ;};_ggeag ,_eeff :=_cgfg .setOpacity (_cadgf ._efgb ,_cadgf ._gacec );
if _eeff !=nil {return nil ,ctx ,_eeff ;};_efeb ,_ ,_eeff :=_dbcag .Draw (_ggeag );if _eeff !=nil {return nil ,ctx ,_eeff ;};if _eeff =_cgfg .addContentsByString (string (_efeb ));_eeff !=nil {return nil ,ctx ,_eeff ;};if _eabd {ctx .X =_agbbg .X ;ctx .Width =_agbbg .Width ;
_fcaf :=_cadgf ._baag +_bfae ;ctx .Y +=_fcaf +_cadgf ._bacfa .Bottom ;ctx .Height -=_fcaf ;}else {ctx =_agbbg ;};_egac =append (_egac ,_cgfg );return _egac ,ctx ,nil ;};func _gggc (_gage _ff .ChartRenderable )*Chart {return &Chart {_ccf :_gage ,_gbdd :PositionRelative ,_ebga :Margins {Top :10,Bottom :10}};
};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_bagf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_fdbdf float64 ;_dabge uint ;_ddccb float64 ;_ecfb Positioning ;_faga float64 ;_eeaa float64 ;_gdda int64 ;};func _ebgcc (_gagebb *templateProcessor ,_bcgf *templateNode )(interface{},error ){return _gagebb .parseBackground (_bcgf );};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_cbdc *Invoice )Terms ()(string ,string ){return _cbdc ._befe [0],_cbdc ._befe [1]};

// SetStyle sets the style of the line (solid or dashed).
func (_dbagb *Line )SetStyle (style _ce .LineStyle ){_dbagb ._ddca =style };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_fceae *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_efdcb :=NewTextChunk (text ,_fceae ._ggee );_efdcb ._gbgga =_ccbeg (page -1,x ,y ,zoom );return _fceae .appendChunk (_efdcb );};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;
CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ffdf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _ffdf ._aeggf [0],_ffdf ._aeggf [1];};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_cbaf *Creator )SetPageLabels (pageLabels _ea .PdfObject ){_cbaf ._aded =pageLabels };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gbfb *Chapter )SetShowNumbering (show bool ){_gbfb ._faea =show ;_gbfb ._abd .SetText (_gbfb .headingText ());};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_bdege *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_aeeg :=[2]*InvoiceCell {_bdege .newCell (description ,_bdege ._cebef ),_bdege .newCell (value ,_bdege ._cebef )};_bdege ._dgec =append (_bdege ._dgec ,_aeeg );return _aeeg [0],_aeeg [1];
};

// SetAngle sets the rotation angle of the text.
func (_aecaa *Paragraph )SetAngle (angle float64 ){_aecaa ._dgdea =angle };type border struct{_acb float64 ;_edb float64 ;_dgga float64 ;_fbce float64 ;_eede Color ;_bgfg Color ;_feg float64 ;_ada Color ;_bbdf float64 ;_fdaa Color ;_gea float64 ;_dcd Color ;
_ead float64 ;LineStyle _ce .LineStyle ;_dcda CellBorderStyle ;_adg CellBorderStyle ;_bdd CellBorderStyle ;_befg CellBorderStyle ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_dfacc *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afbf :=ctx ;var _geae []*Block ;_bacb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dfacc ._defc .IsRelative (){ctx .X +=_dfacc ._faaba .Left ;ctx .Y +=_dfacc ._faaba .Top ;
ctx .Width -=_dfacc ._faaba .Left +_dfacc ._faaba .Right ;ctx .Height -=_dfacc ._faaba .Top ;_dfacc .SetWidth (ctx .Width );}else {if int (_dfacc ._fdfbb )<=0{_dfacc .SetWidth (_dfacc .getTextWidth ()/1000.0);};ctx .X =_dfacc ._gbdbe ;ctx .Y =_dfacc ._cgcgca ;
};if _dfacc ._cddca !=nil {_dfacc ._cddca (_dfacc ,ctx );};if _dggf :=_dfacc .wrapText ();_dggf !=nil {return nil ,ctx ,_dggf ;};_fdeae :=_dfacc ._egffa ;for {_dacbag ,_cbfgb ,_gebb :=_gddcg (_bacb ,_dfacc ,_fdeae ,ctx );if _gebb !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gebb );
return nil ,ctx ,_gebb ;};ctx =_dacbag ;_geae =append (_geae ,_bacb );if _fdeae =_cbfgb ;len (_cbfgb )==0{break ;};_bacb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dacbag =ctx ;_dacbag .Y =ctx .Margins .Top ;_dacbag .X =ctx .Margins .Left +_dfacc ._faaba .Left ;
_dacbag .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dacbag .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dfacc ._faaba .Left -_dfacc ._faaba .Right ;ctx =_dacbag ;};if _dfacc ._defc .IsRelative (){ctx .Y +=_dfacc ._faaba .Bottom ;
ctx .Height -=_dfacc ._faaba .Bottom ;if !ctx .Inline {ctx .X =_afbf .X ;ctx .Width =_afbf .Width ;};return _geae ,ctx ,nil ;};return _geae ,_afbf ,nil ;};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _cb .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_dfd .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_fa .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_fa .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ff .ChartRenderable ;};

// Opacity returns the opacity of the line.
func (_bebg *Line )Opacity ()float64 {return _bebg ._gcaa };func (_egeg *Division )ctxHeight (_fggc float64 )float64 {_fggc -=_egeg ._cdef .Left +_egeg ._cdef .Right +_egeg ._dgfg .Left +_egeg ._dgfg .Right ;var _fgaf float64 ;for _ ,_agbe :=range _egeg ._cga {_fgaf +=_gdga (_agbe ,_fggc );
};return _fgaf ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_dfbf float64 ;_aeecg float64 ;_gagg float64 ;_cbaff float64 ;_cabf Color ;_ddca _ce .LineStyle ;_gcaa float64 ;_efgeg []int64 ;_gfee int64 ;_baec float64 ;_gfdb Positioning ;_bfeb FitMode ;_dcdb Margins ;};func _ddaea (_ebgaga TextStyle )*List {return &List {_cgef :TextChunk {Text :"\u2022\u0020",Style :_ebgaga },_dcdc :0,_ecfac :true ,_caea :PositionRelative ,_dbca :_ebgaga };
};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bggd *Invoice )SetColumns (cols []*InvoiceCell ){_bggd ._cgcg =cols };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ddff *LinearShading )SetExtends (start bool ,end bool ){_ddff ._dgbd .SetExtends (start ,end )};

// SetBorderWidth sets the border width.
func (_ddfb *Polygon )SetBorderWidth (borderWidth float64 ){_ddfb ._cgecf .BorderWidth =borderWidth };

// Add adds a new line with the default style to the table of contents.
func (_abccgc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_dfbbe :=_abccgc .AddLine (_eafbg (TextChunk {Text :number ,Style :_abccgc ._fdfac },TextChunk {Text :title ,Style :_abccgc ._agde },TextChunk {Text :page ,Style :_abccgc ._dbdbc },level ,_abccgc ._bcgff ));
if _dfbbe ==nil {return nil ;};_faeag :=&_abccgc ._adgec ;_dfbbe .SetMargins (_faeag .Left ,_faeag .Right ,_faeag .Top ,_faeag .Bottom );_dfbbe .SetLevelOffset (_abccgc ._gafab );_dfbbe .Separator .Text =_abccgc ._abgga ;_dfbbe .Separator .Style =_abccgc ._dbfad ;
return _dfbbe ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_gfeeg *StyledParagraph )SetWidth (width float64 ){_gfeeg ._fdfbb =width ;_gfeeg .wrapText ()};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_gde *Block )DrawTemplate (c *Creator ,r _dfd .Reader ,data interface{},options *TemplateOptions )error {return _efccg (c ,r ,data ,options ,_gde );};

// Style returns the style of the line.
func (_dgca *Line )Style ()_ce .LineStyle {return _dgca ._ddca };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_gbfdf *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_gbfdf ._ecbg =valign };

// SetLineWidth sets the line width.
func (_cgab *Polyline )SetLineWidth (lineWidth float64 ){_cgab ._dfgf .LineWidth =lineWidth };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_fdag *Creator )EnableFontSubsetting (font *_fa .PdfFont ){_fdag ._gfc =append (_fdag ._gfc ,font )};func (_ggfg *Table )updateRowHeights (_dcgbe float64 ){for _ ,_baca :=range _ggfg ._bdfef {_defad :=_baca .width (_ggfg ._gaecf ,_dcgbe );_efega :=_baca .height (_defad );
_cbcbc :=_ggfg ._cddcg [_baca ._cceef +_baca ._badd -2];if _baca ._badd > 1{_effe :=0.0;_ecaa :=_ggfg ._cddcg [_baca ._cceef -1:(_baca ._cceef +_baca ._badd -1)];for _ ,_agebe :=range _ecaa {_effe +=_agebe ;};if _efega <=_effe {continue ;};};if _efega > _cbcbc {_bgcg :=_efega /float64 (_baca ._badd );
if _bgcg > _cbcbc {for _faabf :=1;_faabf <=_baca ._badd ;_faabf ++{if _bgcg > _ggfg ._cddcg [_baca ._cceef +_faabf -2]{_ggfg ._cddcg [_baca ._cceef +_faabf -2]=_bgcg ;};};};};};};func _fca (_gbga string ,_aafe _ea .PdfObject ,_ccb *_fa .PdfPageResources )_ea .PdfObjectName {_efgg :=_dc .TrimRightFunc (_dc .TrimSpace (_gbga ),func (_dab rune )bool {return _efe .IsNumber (_dab )});
if _efgg ==""{_efgg ="\u0046\u006f\u006e\u0074";};_aceg :=0;_cgcb :=_ea .PdfObjectName (_gbga );for {_bdff ,_cag :=_ccb .GetFontByName (_cgcb );if !_cag ||_bdff ==_aafe {break ;};_aceg ++;_cgcb =_ea .PdfObjectName (_g .Sprintf ("\u0025\u0073\u0025\u0064",_efgg ,_aceg ));
};return _cgcb ;};func _eaage (_fcab ,_ccge ,_fdggf ,_gbad ,_ebgc ,_gaff float64 )*Curve {_gadc :=&Curve {};_gadc ._cfd =_fcab ;_gadc ._cdbb =_ccge ;_gadc ._bcga =_fdggf ;_gadc ._affa =_gbad ;_gadc ._bcca =_ebgc ;_gadc ._acdbc =_gaff ;_gadc ._adfb =ColorBlack ;
_gadc ._geeb =1.0;return _gadc ;};func (_ececf *templateProcessor )parseListMarker (_ceab *templateNode )(interface{},error ){if _ceab ._bgba ==nil {_ececf .nodeLogError (_ceab ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_abag ;};var _aegdb *TextChunk ;switch _eefc :=_ceab ._bgba ._ccfeb .(type ){case *List :_aegdb =&_eefc ._cgef ;case *listItem :_aegdb =&_eefc ._dbea ;default:_ececf .nodeLogError (_ceab ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_eefc );
return nil ,_abag ;};if _ ,_agfdac :=_ececf .parseTextChunk (_ceab ,_aegdb );_agfdac !=nil {_ececf .nodeLogError (_ceab ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_agfdac );
return nil ,nil ;};return _aegdb ,nil ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_cece *Line )SetFitMode (fitMode FitMode ){_cece ._bfeb =fitMode };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_afeeff *LinearShading )SetAntiAlias (enable bool ){_afeeff ._dgbd .SetAntiAlias (enable )};

// SetFillColor sets the fill color of the rectangle.
func (_cdgc *Rectangle )SetFillColor (col Color ){_cdgc ._abbg =col };

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_bddc *LinearShading )ToPdfShadingPattern ()*_fa .PdfShadingPatternType2 {_ggege ,_fgbf ,_dbda :=_bddc ._dgbd ._cfcbc .ToRGB ();_ggfaaf :=_bddc .shadingModel ();_ggfaaf .PdfShading .Background =_ea .MakeArrayFromFloats ([]float64 {_ggege ,_fgbf ,_dbda });
_acga :=_fa .NewPdfShadingPatternType2 ();_acga .Shading =_ggfaaf ;return _acga ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// CurCol returns the currently active cell's column number.
func (_aebed *Table )CurCol ()int {_egfa :=(_aebed ._aeba -1)%(_aebed ._beege )+1;return _egfa };func _gdadab (_fbbc *templateProcessor ,_baada *templateNode )(interface{},error ){return _fbbc .parseTable (_baada );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_fbgee *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bffde :=&_fbgee ._adgec ;_bffde .Left =left ;_bffde .Right =right ;_bffde .Top =top ;_bffde .Bottom =bottom ;};func (_eaaf *templateProcessor )parseTextAlignmentAttr (_ebce ,_bebgc string )TextAlignment {_eef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ebce ,_bebgc );
_eeaf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_bebgc ];
return _eeaf ;};func (_bgfcf *templateProcessor )parseLinearGradientAttr (creator *Creator ,_adgcg string )Color {_cbdgb :=ColorBlack ;if _adgcg ==""{return _cbdgb ;};_dfec :=creator .NewLinearGradientColor ([]*ColorPoint {});_dfec .SetExtends (true ,true );
var (_agefc =_dc .Split (_adgcg [16:len (_adgcg )-1],"\u002c");_gegdg =_dc .TrimSpace (_agefc [0]););if _dc .HasSuffix (_gegdg ,"\u0064\u0065\u0067"){_aabe ,_bebgbf :=_a .ParseFloat (_gegdg [:len (_gegdg )-3],64);if _bebgbf !=nil {_eef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_bebgbf );
}else {_dfec .SetAngle (_aabe );};_agefc =_agefc [1:];};_gccfd ,_agdde :=_bgfcf .processGradientColorPair (_agefc );if _gccfd ==nil ||_agdde ==nil {return _cbdgb ;};for _dagag :=0;_dagag < len (_gccfd );_dagag ++{_dfec .AddColorStop (_gccfd [_dagag ],_agdde [_dagag ]);
};return _dfec ;};func (_acda *pageTransformations )applyFlip (_gccg *_fa .PdfPage )error {_cbcc ,_cacb :=_acda ._gdbeg ,_acda ._bag ;if !_cbcc &&!_cacb {return nil ;};if _gccg ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_cfcd ,_bccd :=_gccg .GetMediaBox ();if _bccd !=nil {return _bccd ;};_cgd ,_fed :=_cfcd .Width (),_cfcd .Height ();_cgb ,_bccd :=_gccg .GetRotate ();if _bccd !=nil {_eef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bccd .Error ());
};if _fdgg :=_cgb %360!=0&&_cgb %90==0;_fdgg {if _fgag :=(360+_cgb %360)%360;_fgag ==90||_fgag ==270{_cbcc ,_cacb =_cacb ,_cbcc ;};};_dba ,_dag :=1.0,0.0;if _cbcc {_dba ,_dag =-1.0,-_cgd ;};_cdg ,_gaee :=1.0,0.0;if _cacb {_cdg ,_gaee =-1.0,-_fed ;};_abae :=_bd .NewContentCreator ().Scale (_dba ,_cdg ).Translate (_dag ,_gaee );
_agdd ,_bccd :=_ea .MakeStream (_abae .Bytes (),_ea .NewFlateEncoder ());if _bccd !=nil {return _bccd ;};_aafc :=_ea .MakeArray (_agdd );_aafc .Append (_gccg .GetContentStreamObjs ()...);_gccg .Contents =_aafc ;return nil ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_ccfg *Rectangle )Width ()float64 {return _ccfg ._faaa };type fontMetrics struct{_cbaab float64 ;_gbffe float64 ;_aebcd float64 ;_dgad float64 ;};func _ceef (_ggdb ,_aebda TextStyle )*Invoice {_dbde :=&Invoice {_afgg :"\u0049N\u0056\u004f\u0049\u0043\u0045",_edec :"\u002c\u0020",_ggac :_ggdb ,_acaa :_aebda };
_dbde ._aecb =&InvoiceAddress {Separator :_dbde ._edec };_dbde ._gcfe =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_dbde ._edec };_ccgc :=ColorRGBFrom8bit (245,245,245);_aafb :=ColorRGBFrom8bit (155,155,155);_dbde ._gbfbc =_aebda ;
_dbde ._gbfbc .Color =_aafb ;_dbde ._gbfbc .FontSize =20;_dbde ._gbgdd =_ggdb ;_dbde ._cecc =_aebda ;_dbde ._bgeac =_ggdb ;_dbde ._gaga =_aebda ;_dbde ._cebef =_dbde .NewCellProps ();_dbde ._cebef .BackgroundColor =_ccgc ;_dbde ._cebef .TextStyle =_aebda ;
_dbde ._abef =_dbde .NewCellProps ();_dbde ._abef .TextStyle =_aebda ;_dbde ._abef .BackgroundColor =_ccgc ;_dbde ._abef .BorderColor =_ccgc ;_dbde ._cdab =_dbde .NewCellProps ();_dbde ._cdab .BorderColor =_ccgc ;_dbde ._cdab .BorderSides =[]CellBorderSide {CellBorderSideBottom };
_dbde ._cdab .Alignment =CellHorizontalAlignmentRight ;_dbde ._defd =_dbde .NewCellProps ();_dbde ._defd .Alignment =CellHorizontalAlignmentRight ;_dbde ._cgga =[2]*InvoiceCell {_dbde .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_dbde ._cebef ),_dbde .newCell ("",_dbde ._cebef )};
_dbde ._bacd =[2]*InvoiceCell {_dbde .newCell ("\u0044\u0061\u0074\u0065",_dbde ._cebef ),_dbde .newCell ("",_dbde ._cebef )};_dbde ._gdcc =[2]*InvoiceCell {_dbde .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_dbde ._cebef ),_dbde .newCell ("",_dbde ._cebef )};
_dbde ._aeggf =[2]*InvoiceCell {_dbde .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_dbde ._defd ),_dbde .newCell ("",_dbde ._defd )};_dfbb :=_dbde ._defd ;_dfbb .TextStyle =_aebda ;_dfbb .BackgroundColor =_ccgc ;_dfbb .BorderColor =_ccgc ;
_dbde ._cadf =[2]*InvoiceCell {_dbde .newCell ("\u0054\u006f\u0074a\u006c",_dfbb ),_dbde .newCell ("",_dfbb )};_dbde ._ebcg =[2]string {"\u004e\u006f\u0074e\u0073",""};_dbde ._befe =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_dbde ._cgcg =[]*InvoiceCell {_dbde .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_dbde .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_dbde .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_dbde .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _dbde ;};func (_ggbbe *StyledParagraph )wrapWordChunks (){if !_ggbbe ._ebgbe {return ;};var (_dgeaf []*TextChunk ;_bfba *_fa .PdfFont ;);for _ ,_bafef :=range _ggbbe ._cfbcg {_gefde :=[]rune (_bafef .Text );if _bfba ==nil {_bfba =_bafef .Style .Font ;
};_ebfag :=_bafef ._gbgga ;_aadc :=_bafef .VerticalAlignment ;if len (_dgeaf )> 0{if len (_gefde )==1&&_efe .IsPunct (_gefde [0])&&_bafef .Style .Font ==_bfba {_ceedc :=[]rune (_dgeaf [len (_dgeaf )-1].Text );_dgeaf [len (_dgeaf )-1].Text =string (append (_ceedc ,_gefde [0]));
continue ;}else {_ ,_fddf :=_a .Atoi (_bafef .Text );if _fddf ==nil {_dddbe :=[]rune (_dgeaf [len (_dgeaf )-1].Text );_edcfc :=len (_dddbe );if _edcfc >=2{_ ,_ceeef :=_a .Atoi (string (_dddbe [_edcfc -2]));if _ceeef ==nil &&_efe .IsPunct (_dddbe [_edcfc -1]){_dgeaf [len (_dgeaf )-1].Text =string (append (_dddbe ,_gefde ...));
continue ;};};};};};_fefd ,_ebgae :=_eddb (_bafef .Text );if _ebgae !=nil {_eef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_ebgae );
_fefd =[]string {_bafef .Text };};for _ ,_ebbde :=range _fefd {_gccbg :=NewTextChunk (_ebbde ,_bafef .Style );_gccbg ._gbgga =_bdfgc (_ebfag );_gccbg .VerticalAlignment =_aadc ;_dgeaf =append (_dgeaf ,_gccbg );};_bfba =_bafef .Style .Font ;};if len (_dgeaf )> 0{_ggbbe ._cfbcg =_dgeaf ;
};};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_daaa *Ellipse )SetPositioning (position Positioning ){_daaa ._dada =position };

// SetWidthBottom sets border width for bottom.
func (_gbf *border )SetWidthBottom (bw float64 ){_gbf ._bbdf =bw };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_adgfa *LinearShading )SetBackgroundColor (backgroundColor Color ){_adgfa ._dgbd .SetBackgroundColor (backgroundColor );};

// SetTerms sets the terms and conditions section of the invoice.
func (_gafe *Invoice )SetTerms (title ,content string ){_gafe ._befe =[2]string {title ,content }};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_fgd *Image )SetMargins (left ,right ,top ,bottom float64 ){_fgd ._gbba .Left =left ;_fgd ._gbba .Right =right ;_fgd ._gbba .Top =top ;_fgd ._gbba .Bottom =bottom ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetBackgroundColor sets the cell's background color.
func (_aecdd *TableCell )SetBackgroundColor (col Color ){_aecdd ._cbacb =col };

// SetBuyerAddress sets the buyer address of the invoice.
func (_dfda *Invoice )SetBuyerAddress (address *InvoiceAddress ){_dfda ._gcfe =address };

// SetEnableWrap sets the line wrapping enabled flag.
func (_gdaa *StyledParagraph )SetEnableWrap (enableWrap bool ){_gdaa ._dgba =enableWrap ;_gdaa ._gadge =false ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_efbbg *Rectangle )GetCoords ()(float64 ,float64 ){return _efbbg ._dfbc ,_efbbg ._gbfgg };func (_fgaa *templateProcessor )processGradientColorPair (_bggc []string )(_ccbfc []Color ,_aceadg []float64 ){for _ ,_gfaga :=range _bggc {var (_ffcd =_dc .Fields (_gfaga );
_fded =len (_ffcd ););if _fded ==0{continue ;};_eaggg :="";if _fded > 1{_eaggg =_dc .TrimSpace (_ffcd [1]);};_dcaf :=-1.0;if _dc .HasSuffix (_eaggg ,"\u0025"){_gfbfe ,_fege :=_a .ParseFloat (_eaggg [:len (_eaggg )-1],64);if _fege !=nil {_eef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fege );
};_dcaf =_gfbfe /100.0;};_cfdeg :=_fgaa .parseColor (_dc .TrimSpace (_ffcd [0]));if _cfdeg !=nil {_ccbfc =append (_ccbfc ,_cfdeg );_aceadg =append (_aceadg ,_dcaf );};};if len (_ccbfc )!=len (_aceadg ){_eef .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_ggcc :=-1;_gaaa :=0.0;for _fegf ,_cbef :=range _aceadg {if _cbef ==-1.0{if _fegf ==0{_cbef =0.0;_aceadg [_fegf ]=0.0;continue ;};_ggcc ++;if _fegf < len (_aceadg )-1{continue ;}else {_cbef =1.0;_aceadg [_fegf ]=1.0;};};_cfcce :=_ggcc +1;
for _bcef :=_fegf -_ggcc ;_bcef < _fegf ;_bcef ++{_aceadg [_bcef ]=_gaaa +(float64 (_bcef )*(_cbef -_gaaa )/float64 (_cfcce ));};_gaaa =_cbef ;_ggcc =-1;};return _ccbfc ,_aceadg ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_agad *GraphicSVG )ScaleToWidth (w float64 ){_cea :=_agad ._baea .Height /_agad ._baea .Width ;_agad ._baea .Width =w ;_agad ._baea .Height =w *_cea ;_agad ._baea .SetScaling (_cea ,_cea );};func (_ebadb *templateProcessor )parseTextChunk (_gbadd *templateNode ,_acff *TextChunk )(interface{},error ){if _gbadd ._bgba ==nil {_ebadb .nodeLogError (_gbadd ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_abag ;};var (_gabge =_ebadb .creator .NewTextStyle ();_bbef bool ;);for _ ,_bcgc :=range _gbadd ._facfb .Attr {if _bcgc .Name .Local =="\u006c\u0069\u006e\u006b"{_cbffc ,_efbef :=_gbadd ._bgba ._ccfeb .(*StyledParagraph );if !_efbef {_ebadb .nodeLogError (_gbadd ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_bbef =true ;}else {_gabge =_cbffc ._ggee ;};break ;};};if _acff ==nil {_acff =NewTextChunk ("",_gabge );};for _ ,_efgef :=range _gbadd ._facfb .Attr {_efdfb :=_efgef .Value ;switch _ccfff :=_efgef .Name .Local ;_ccfff {case "\u0063\u006f\u006co\u0072":_acff .Style .Color =_ebadb .parseColorAttr (_ccfff ,_efdfb );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_acff .Style .OutlineColor =_ebadb .parseColorAttr (_ccfff ,_efdfb );case "\u0066\u006f\u006e\u0074":_acff .Style .Font =_ebadb .parseFontAttr (_ccfff ,_efdfb );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_acff .Style .FontSize =_ebadb .parseFloatAttr (_ccfff ,_efdfb );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_acff .Style .OutlineSize =_ebadb .parseFloatAttr (_ccfff ,_efdfb );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_acff .Style .CharSpacing =_ebadb .parseFloatAttr (_ccfff ,_efdfb );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_acff .Style .HorizontalScaling =_ebadb .parseFloatAttr (_ccfff ,_efdfb );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_acff .Style .RenderingMode =_ebadb .parseTextRenderingModeAttr (_ccfff ,_efdfb );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_acff .Style .Underline =_ebadb .parseBoolAttr (_ccfff ,_efdfb );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_acff .Style .UnderlineStyle .Color =_ebadb .parseColorAttr (_ccfff ,_efdfb );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_acff .Style .UnderlineStyle .Offset =_ebadb .parseFloatAttr (_ccfff ,_efdfb );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_acff .Style .UnderlineStyle .Thickness =_ebadb .parseFloatAttr (_ccfff ,_efdfb );
case "\u006c\u0069\u006e\u006b":if !_bbef {_acff ._gbgga =_ebadb .parseLinkAttr (_ccfff ,_efdfb );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_acff .Style .TextRise =_ebadb .parseFloatAttr (_ccfff ,_efdfb );default:_ebadb .nodeLogDebug (_gbadd ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ccfff );
};};return _acff ,nil ;};func (_cbcf *Invoice )drawInformation ()*Table {_gcdf :=_bgfa (2);_cfge :=append ([][2]*InvoiceCell {_cbcf ._cgga ,_cbcf ._bacd ,_cbcf ._gdcc },_cbcf ._dgec ...);for _ ,_adef :=range _cfge {_faee ,_gead :=_adef [0],_adef [1];if _gead .Value ==""{continue ;
};_dede :=_gcdf .NewCell ();_dede .SetBackgroundColor (_faee .BackgroundColor );_cbcf .setCellBorder (_dede ,_faee );_aecdb :=_defdc (_faee .TextStyle );_aecdb .Append (_faee .Value );_aecdb .SetMargins (0,0,2,1);_dede .SetContent (_aecdb );_dede =_gcdf .NewCell ();
_dede .SetBackgroundColor (_gead .BackgroundColor );_cbcf .setCellBorder (_dede ,_gead );_aecdb =_defdc (_gead .TextStyle );_aecdb .Append (_gead .Value );_aecdb .SetMargins (0,0,2,1);_dede .SetContent (_aecdb );};return _gcdf ;};func _ebgb (_gegb string )string {_dbcfc :=_gegg .FindAllString (_gegb ,-1);
if len (_dbcfc )==0{_gegb =_gegb +"\u0030";}else {_fdcf ,_cbcb :=_a .Atoi (_dbcfc [len (_dbcfc )-1]);if _cbcb !=nil {_eef .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_cbcb );
_gegb =_gegb +"\u0030";}else {_fdcf ++;_gadb :=_dc .LastIndex (_gegb ,_dbcfc [len (_dbcfc )-1]);if _gadb ==-1{_gegb =_g .Sprintf ("\u0025\u0073\u0025\u0064",_gegb [:len (_gegb )-1],_fdcf );}else {_gegb =_gegb [:_gadb ]+_a .Itoa (_fdcf );};};};return _gegb ;
};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cfgd *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_cfgd ._defa =&_fa .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// AddColorStop add color stop info for rendering gradient color.
func (_dbbe *LinearShading )AddColorStop (color Color ,point float64 ){_dbbe ._dgbd .AddColorStop (color ,point );};

// SetIndent sets the left offset of the list when nested into another list.
func (_afead *List )SetIndent (indent float64 ){_afead ._dcdc =indent ;_afead ._ecfac =false };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cagb *TOC )SetLineNumberStyle (style TextStyle ){_cagb ._fdfac =style };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_gegcc *Rectangle )SetPositioning (position Positioning ){_gegcc ._fdde =position };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_gfgb *Invoice )Sections ()[][2]string {return _gfgb ._gdag };

// NewCellProps returns the default properties of an invoice cell.
func (_ggfb *Invoice )NewCellProps ()InvoiceCellProps {_acbc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_ggfb ._ggac ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_acbc ,BorderColor :_acbc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// CreateFrontPage sets a function to generate a front Page.
func (_gec *Creator )CreateFrontPage (genFrontPageFunc func (_bgeb FrontpageFunctionArgs )){_gec ._fcaa =genFrontPageFunc ;};

// Height returns the height of the line.
func (_cbad *Line )Height ()float64 {_dfed :=_cbad ._baec ;if _cbad ._dfbf ==_cbad ._gagg {_dfed /=2;};return _ec .Abs (_cbad ._cbaff -_cbad ._aeecg )+_dfed ;};

// SetColor sets the line color.
func (_agage *Curve )SetColor (col Color ){_agage ._adfb =col };

// Height returns the total height of all rows.
func (_cecge *Table )Height ()float64 {_bebac :=float64 (0.0);for _ ,_dcba :=range _cecge ._cddcg {_bebac +=_dcba ;};return _bebac ;};func (_bfbe *templateProcessor )parseChapter (_gbfe *templateNode )(interface{},error ){_eeef :=_bfbe .creator .NewChapter ;
if _gbfe ._bgba !=nil {if _fdbag ,_cdge :=_gbfe ._bgba ._ccfeb .(*Chapter );_cdge {_eeef =_fdbag .NewSubchapter ;};};_beaaa :=_eeef ("");for _ ,_bbee :=range _gbfe ._facfb .Attr {_bedg :=_bbee .Value ;switch _bagc :=_bbee .Name .Local ;_bagc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_beaaa .SetShowNumbering (_bfbe .parseBoolAttr (_bagc ,_bedg ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_beaaa .SetIncludeInTOC (_bfbe .parseBoolAttr (_bagc ,_bedg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gegeb :=_bfbe .parseMarginAttr (_bagc ,_bedg );_beaaa .SetMargins (_gegeb .Left ,_gegeb .Right ,_gegeb .Top ,_gegeb .Bottom );
default:_bfbe .nodeLogDebug (_gbfe ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bagc );
};};return _beaaa ,nil ;};

// Rows returns the total number of rows the table has.
func (_dcdfg *Table )Rows ()int {return _dcdfg ._cccb };func _bdfgc (_gdbef *_fa .PdfAnnotation )*_fa .PdfAnnotation {if _gdbef ==nil {return nil ;};var _ffbfb *_fa .PdfAnnotation ;switch _daebd :=_gdbef .GetContext ().(type ){case *_fa .PdfAnnotationLink :if _ggcf :=_feaaf (_daebd );
_ggcf !=nil {_ffbfb =_ggcf .PdfAnnotation ;};};return _ffbfb ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_dcaaf *RadialShading )SetExtends (start bool ,end bool ){_dcaaf ._gcbg .SetExtends (start ,end )};

// SetFillOpacity sets the fill opacity.
func (_dcad *Polygon )SetFillOpacity (opacity float64 ){_dcad ._bege =opacity };

// SetFontSize sets the font size in document units (points).
func (_bdfbb *Paragraph )SetFontSize (fontSize float64 ){_bdfbb ._cgcbd =fontSize };func _dbgda (_gaffd *_fa .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_gaffd ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fbabc *TOC )SetLineSeparator (separator string ){_fbabc ._abgga =separator };

// SetBorderOpacity sets the border opacity.
func (_bdca *Polygon )SetBorderOpacity (opacity float64 ){_bdca ._dgcea =opacity };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_ffac *StyledParagraph )SetTextAlignment (align TextAlignment ){_ffac ._dgbde =align };

// GeneratePageBlocks generates a page break block.
func (_beec *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gadg :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_eacg :=ctx ;_eacg .Y =ctx .Margins .Top ;
_eacg .X =ctx .Margins .Left ;_eacg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_eacg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_eacg ;return _gadg ,ctx ,nil ;};func _eafbg (_efdbd ,_edgda ,_daade TextChunk ,_bdcc uint ,_ddcg TextStyle )*TOCLine {_cbbed :=_defdc (_ddcg );
_cbbed .SetEnableWrap (true );_cbbed .SetTextAlignment (TextAlignmentLeft );_cbbed .SetMargins (0,0,2,2);_dbbcf :=&TOCLine {_bagf :_cbbed ,Number :_efdbd ,Title :_edgda ,Page :_daade ,Separator :TextChunk {Text :"\u002e",Style :_ddcg },_fdbdf :0,_dabge :_bdcc ,_ddccb :10,_ecfb :PositionRelative };
_cbbed ._faaba .Left =_dbbcf ._fdbdf +float64 (_dbbcf ._dabge -1)*_dbbcf ._ddccb ;_cbbed ._cddca =_dbbcf .prepareParagraph ;return _dbbcf ;};

// Color returns the color of the line.
func (_gcafc *Line )Color ()Color {return _gcafc ._cabf };func _cfcbe (_acbee []*ColorPoint )*LinearShading {return &LinearShading {_dgbd :&shading {_cfcbc :ColorWhite ,_eadef :false ,_ffcf :[]bool {false ,false },_fbdg :_acbee },_defa :&_fa .PdfRectangle {}};
};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_fa .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// Reset removes all the text chunks the paragraph contains.
func (_fccc *StyledParagraph )Reset (){_fccc ._cfbcg =[]*TextChunk {}};func _fbagb (_acgf [][]_ce .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_dbag :&_ce .CurvePolygon {Rings :_acgf },_bcfd :1.0,_eggf :1.0};};func (_cafac *StyledParagraph )appendChunk (_ebfac *TextChunk )*TextChunk {_cafac ._cfbcg =append (_cafac ._cfbcg ,_ebfac );
_cafac .wrapText ();return _ebfac ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_aff *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aff ._ebga .Left ,_aff ._ebga .Right ,_aff ._ebga .Top ,_aff ._ebga .Bottom ;};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dadf *Rectangle )Positioning ()Positioning {return _dadf ._fdde };func _ddcd (_dbadb *Block ,_bcff _fa .PdfColor ,_caaab Color ,_eegc func ()Rectangle )error {switch _gcea :=_bcff .(type ){case *_fa .PdfColorPatternType2 :_cbade ,_eggg :=_caaab .(*LinearShading );
if !_eggg {return _g .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_bgdgc :=_eegc ();_cbade .SetBoundingBox (_bgdgc ._dfbc ,_bgdgc ._gbfgg ,_bgdgc ._faaa ,_bgdgc ._baag );
_dffd ,_dcbd :=_cbade .AddPatternResource (_dbadb );if _dcbd !=nil {return _g .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_dcbd );
};_gcea .PatternName =_dffd ;case *_fa .PdfColorPatternType3 :_fdace ,_caebb :=_caaab .(*RadialShading );if !_caebb {return _g .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_fggb :=_eegc ();_fdace .SetBoundingBox (_fggb ._dfbc ,_fggb ._gbfgg ,_fggb ._faaa ,_fggb ._baag );_fabcb ,_cddbe :=_fdace .AddPatternResource (_dbadb );if _cddbe !=nil {return _g .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_cddbe );
};_gcea .PatternName =_fabcb ;};return nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_fecfd *TOC )SetShowLinks (showLinks bool ){_fecfd ._cfgge =showLinks };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_afae *Table )SetPos (x ,y float64 ){_afae ._dbgb =PositionAbsolute ;_afae ._dcbdd =x ;_afae ._dfdc =y ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bgf *Block )ScaleToWidth (w float64 ){_eg :=w /_bgf ._bc ;_bgf .Scale (_eg ,_eg )};

// AddSection adds a new content section at the end of the invoice.
func (_efbag *Invoice )AddSection (title ,content string ){_efbag ._gdag =append (_efbag ._gdag ,[2]string {title ,content });};func _dagfb (_caeb ,_fafd ,_dbbba ,_gddb float64 )*Line {return &Line {_dfbf :_caeb ,_aeecg :_fafd ,_gagg :_dbbba ,_cbaff :_gddb ,_cabf :ColorBlack ,_gcaa :1.0,_baec :1.0,_efgeg :[]int64 {1,1},_gfdb :PositionAbsolute };
};func _ebad (_gbaca float64 ,_gggaf float64 ,_agdc float64 ,_fcbb float64 ,_cfed []*ColorPoint )*RadialShading {return &RadialShading {_gcbg :&shading {_cfcbc :ColorWhite ,_eadef :false ,_ffcf :[]bool {false ,false },_fbdg :_cfed },_eebg :_gbaca ,_dged :_gggaf ,_ffdcgf :_agdc ,_cbbaf :_fcbb ,_egce :AnchorCenter };
};

// Height returns the Block's height.
func (_bef *Block )Height ()float64 {return _bef ._dec };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_decb *Division )Width ()float64 {return 0};func (_bbc *Block )transform (_cgc _de .Matrix ){_eefgg :=_bd .NewContentCreator ().Add_cm (_cgc [0],_cgc [1],_cgc [3],_cgc [4],_cgc [6],_cgc [7]).Operations ();*_bbc ._ffc =append (*_eefgg ,*_bbc ._ffc ...);
_bbc ._ffc .WrapIfNeeded ();};func (_gbe *Block )drawToPage (_dbb *_fa .PdfPage )error {_bbe :=&_bd .ContentStreamOperations {};if _dbb .Resources ==nil {_dbb .Resources =_fa .NewPdfPageResources ();};_ad :=_gdb (_bbe ,_dbb .Resources ,_gbe ._ffc ,_gbe ._gae );
if _ad !=nil {return _ad ;};if _ad =_eebf (_gbe ._gae ,_dbb .Resources );_ad !=nil {return _ad ;};if _ad =_dbb .AppendContentBytes (_bbe .Bytes (),true );_ad !=nil {return _ad ;};for _ ,_geb :=range _gbe ._cc {_dbb .AddAnnotation (_geb );};return nil ;
};func (_acad *listItem )ctxHeight (_bbgc float64 )float64 {var _gbgcf float64 ;switch _fbgde :=_acad ._edcf .(type ){case *Paragraph :if _fbgde ._fade {_fbgde .SetWidth (_bbgc -_fbgde ._fbba .Horizontal ());};_gbgcf =_fbgde .Height ()+_fbgde ._fbba .Vertical ();
_gbgcf +=0.5*_fbgde ._cgcbd *_fbgde ._ecegc ;case *StyledParagraph :if _fbgde ._dgba {_fbgde .SetWidth (_bbgc -_fbgde ._faaba .Horizontal ());};_gbgcf =_fbgde .Height ()+_fbgde ._faaba .Vertical ();_gbgcf +=0.5*_fbgde .getTextHeight ();case *List :_egdd :=_bbgc -_acad ._dbea .Width ()-_fbgde ._eead .Horizontal ()-_fbgde ._dcdc ;
_gbgcf =_fbgde .ctxHeight (_egdd )+_fbgde ._eead .Vertical ();case *Image :_gbgcf =_fbgde .Height ()+_fbgde ._gbba .Vertical ();case *Division :_afgb :=_bbgc -_acad ._dbea .Width ()-_fbgde ._cdef .Horizontal ();_gbgcf =_fbgde .ctxHeight (_afgb )+_fbgde ._cdef .Vertical ();
case *Table :_dfcc :=_bbgc -_acad ._dbea .Width ()-_fbgde ._fefca .Horizontal ();_fbgde .updateRowHeights (_dfcc );_gbgcf =_fbgde .Height ()+_fbgde ._fefca .Vertical ();default:_gbgcf =_acad ._edcf .Height ();};return _gbgcf ;};

// Height returns the height of the ellipse.
func (_gbbgf *Ellipse )Height ()float64 {return _gbbgf ._dceb };

// Positioning returns the type of positioning the line is set to use.
func (_egde *Line )Positioning ()Positioning {return _egde ._gfdb };func (_ebfd *Invoice )generateHeaderBlocks (_agfb DrawContext )([]*Block ,DrawContext ,error ){_bdfg :=_defdc (_ebfd ._gbfbc );_bdfg .SetEnableWrap (true );_bdfg .Append (_ebfd ._afgg );
_bagg :=_bgfa (2);if _ebfd ._fabc !=nil {_bafa :=_bagg .NewCell ();_bafa .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bafa .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bafa .SetIndent (0);_bafa .SetContent (_ebfd ._fabc );_ebfd ._fabc .ScaleToHeight (_bdfg .Height ()+20);
}else {_bagg .SkipCells (1);};_ggeg :=_bagg .NewCell ();_ggeg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ggeg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ggeg .SetContent (_bdfg );return _bagg .GeneratePageBlocks (_agfb );};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_cfb *Block )SetPos (x ,y float64 ){_cfb ._dcc =PositionAbsolute ;_cfb ._cdf =x ;_cfb ._ag =y };func (_ceegf *templateProcessor )parseLineStyleAttr (_caed ,_dgdcb string )_ce .LineStyle {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_caed ,_dgdcb );
_fggbb :=map[string ]_ce .LineStyle {"\u0073\u006f\u006ci\u0064":_ce .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ce .LineStyleDashed }[_dgdcb ];return _fggbb ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_aefg *Paragraph )SetMaxLines (maxLines int ){_aefg ._ebfbg =maxLines ;_aefg .wrapText ()};func (_dcdbc *templateProcessor )parseAttrPropList (_bade string )map[string ]string {_gggdg :=_dc .Fields (_bade );if len (_gggdg )==0{return nil ;};_fbfbc :=map[string ]string {};
for _ ,_cgcfb :=range _gggdg {_cfdfd :=_dffeg .FindStringSubmatch (_cgcfb );if len (_cfdfd )< 3{continue ;};_fgbb ,_cegd :=_dc .TrimSpace (_cfdfd [1]),_cfdfd [2];if _fgbb ==""{continue ;};_fbfbc [_fgbb ]=_cegd ;};return _fbfbc ;};

// SetColPosition sets cell column position.
func (_ccced *TableCell )SetColPosition (col int ){_ccced ._baceb =col };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ffc *_bd .ContentStreamOperations ;_gae *_fa .PdfPageResources ;_dcc Positioning ;_cdf ,_ag float64 ;_bc float64 ;_dec float64 ;_eb float64 ;_fe Margins ;_cc []*_fa .PdfAnnotation ;};type listItem struct{_edcf VectorDrawable ;_dbea TextChunk ;
};

// MoveX moves the drawing context to absolute position x.
func (_gdbac *Creator )MoveX (x float64 ){_gdbac ._gbb .X =x };func (_ffbc *templateProcessor )parseColorAttr (_gffcc ,_cccfg string )Color {_eef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gffcc ,_cccfg );
_cccfg =_dc .TrimSpace (_cccfg );if _dc .HasPrefix (_cccfg ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_dc .HasSuffix (_cccfg ,"\u0029")&&len (_cccfg )> 17{return _ffbc .parseLinearGradientAttr (_ffbc .creator ,_cccfg );
};if _dc .HasPrefix (_cccfg ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_dc .HasSuffix (_cccfg ,"\u0029")&&len (_cccfg )> 17{return _ffbc .parseRadialGradientAttr (_ffbc .creator ,_cccfg );};if _ceefcg :=_ffbc .parseColor (_cccfg );
_ceefcg !=nil {return _ceefcg ;};return ColorBlack ;};func (_fga *pageTransformations )transformBlock (_dddd *Block ){if _fga ._bff !=nil {_dddd .transform (*_fga ._bff );};};

// SetMargins sets the Paragraph's margins.
func (_fdaaa *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_fdaaa ._fbba .Left =left ;_fdaaa ._fbba .Right =right ;_fdaaa ._fbba .Top =top ;_fdaaa ._fbba .Bottom =bottom ;};func (_gabd *templateProcessor )parsePositioningAttr (_adfcf ,_aagb string )Positioning {_eef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_adfcf ,_aagb );
_gdffa :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_aagb ];return _gdffa ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetColorTop sets border color for top.
func (_ebfg *border )SetColorTop (col Color ){_ebfg ._dcd =col };func (_ebgdb *Paragraph )getTextWidth ()float64 {_fbcag :=0.0;for _ ,_dcfed :=range _ebgdb ._babfa {if _dcfed =='\u000A'{continue ;};_eeba ,_cabgc :=_ebgdb ._gcedf .GetRuneMetrics (_dcfed );
if !_cabgc {_eef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dcfed ,_dcfed );
return -1;};_fbcag +=_ebgdb ._cgcbd *_eeba .Wx ;};return _fbcag ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_gcdfb *TOCLine )SetLevelOffset (levelOffset float64 ){_gcdfb ._ddccb =levelOffset ;_gcdfb ._bagf ._faaba .Left =_gcdfb ._fdbdf +float64 (_gcdfb ._dabge -1)*_gcdfb ._ddccb ;};func (_gfbd *Creator )wrapPageIfNeeded (_agf *_fa .PdfPage )(*_fa .PdfPage ,error ){_acca ,_bdgg :=_agf .GetAllContentStreams ();
if _bdgg !=nil {return nil ,_bdgg ;};_eecb :=_bd .NewContentStreamParser (_acca );_dbg ,_bdgg :=_eecb .Parse ();if _bdgg !=nil {return nil ,_bdgg ;};if !_dbg .HasUnclosedQ (){return nil ,nil ;};_dbg .WrapIfNeeded ();_adeb ,_bdgg :=_ea .MakeStream (_dbg .Bytes (),_ea .NewFlateEncoder ());
if _bdgg !=nil {return nil ,_bdgg ;};_agf .Contents =_ea .MakeArray (_adeb );return _agf ,nil ;};func (_cbae *Ellipse )applyFitMode (_abge float64 ){_abge -=_cbae ._dfac .Left +_cbae ._dfac .Right ;switch _cbae ._facg {case FitModeFillWidth :_cbae .ScaleToWidth (_abge );
};};

// SetSideBorderWidth sets the cell's side border width.
func (_aefcd *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_aefcd ._faeaf =width ;_aefcd ._gegf =width ;_aefcd ._fceg =width ;_aefcd ._bebbd =width ;case CellBorderSideTop :_aefcd ._faeaf =width ;
case CellBorderSideBottom :_aefcd ._gegf =width ;case CellBorderSideLeft :_aefcd ._fceg =width ;case CellBorderSideRight :_aefcd ._bebbd =width ;};};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_dbbdb *Rectangle )FillOpacity ()float64 {return _dbbdb ._efgb };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gcfc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gcfc ._dee .Left =left ;_gcfc ._dee .Right =right ;_gcfc ._dee .Top =top ;_gcfc ._dee .Bottom =bottom ;};

// SetHeight sets the height of the ellipse.
func (_bbbfa *Ellipse )SetHeight (height float64 ){_bbbfa ._dceb =height };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_ddee *Creator )NewImageFromGoImage (goimg _cd .Image )(*Image ,error ){return _egcg (goimg )};type templateTag struct{_faaf map[string ]struct{};_gcee func (*templateProcessor ,*templateNode )(interface{},error );};

// SetLevel sets the indentation level of the TOC line.
func (_fgbd *TOCLine )SetLevel (level uint ){_fgbd ._dabge =level ;_fgbd ._bagf ._faaba .Left =_fgbd ._fdbdf +float64 (_fgbd ._dabge -1)*_fgbd ._ddccb ;};

// GeneratePageBlocks implements drawable interface.
func (_bba *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dggb :=_bba ._acb ;_bbb :=ctx .PageHeight -_bba ._edb ;if _bba ._eede !=nil {_gfbe :=_ce .Rectangle {Opacity :1.0,X :_bba ._acb ,Y :ctx .PageHeight -_bba ._edb -_bba ._fbce ,Height :_bba ._fbce ,Width :_bba ._dgga };
_gfbe .FillEnabled =true ;_ggd :=_gdfa (_bba ._eede );_dcg :=_ddcd (_abf ,_ggd ,_bba ._eede ,func ()Rectangle {return Rectangle {_dfbc :_gfbe .X ,_gbfgg :_gfbe .Y ,_faaa :_gfbe .Width ,_baag :_gfbe .Height };});if _dcg !=nil {return nil ,ctx ,_dcg ;};_gfbe .FillColor =_ggd ;
_gfbe .BorderEnabled =false ;_aba ,_ ,_dcg :=_gfbe .Draw ("");if _dcg !=nil {return nil ,ctx ,_dcg ;};_dcg =_abf .addContentsByString (string (_aba ));if _dcg !=nil {return nil ,ctx ,_dcg ;};};_bdb :=_bba ._ead ;_efff :=_bba ._bbdf ;_eab :=_bba ._feg ;
_dgc :=_bba ._gea ;_afa :=_bba ._ead ;if _bba ._bdd ==CellBorderStyleDouble {_afa +=2*_bdb ;};_adac :=_bba ._bbdf ;if _bba ._befg ==CellBorderStyleDouble {_adac +=2*_efff ;};_agece :=_bba ._feg ;if _bba ._dcda ==CellBorderStyleDouble {_agece +=2*_eab ;
};_ggc :=_bba ._gea ;if _bba ._adg ==CellBorderStyleDouble {_ggc +=2*_dgc ;};_cad :=(_afa -_agece )/2;_abgdc :=(_afa -_ggc )/2;_gaec :=(_adac -_agece )/2;_fegg :=(_adac -_ggc )/2;if _bba ._ead !=0{_agdg :=_dggb ;_gab :=_bbb ;if _bba ._bdd ==CellBorderStyleDouble {_gab -=_bdb ;
_fea :=_ce .BasicLine {LineColor :_gdfa (_bba ._dcd ),Opacity :1.0,LineWidth :_bba ._ead ,LineStyle :_bba .LineStyle ,X1 :_agdg -_afa /2+_cad ,Y1 :_gab +2*_bdb ,X2 :_agdg +_afa /2-_abgdc +_bba ._dgga ,Y2 :_gab +2*_bdb };_edbb ,_ ,_ddg :=_fea .Draw ("");
if _ddg !=nil {return nil ,ctx ,_ddg ;};_ddg =_abf .addContentsByString (string (_edbb ));if _ddg !=nil {return nil ,ctx ,_ddg ;};};_ebc :=_ce .BasicLine {LineWidth :_bba ._ead ,Opacity :1.0,LineColor :_gdfa (_bba ._dcd ),LineStyle :_bba .LineStyle ,X1 :_agdg -_afa /2+_cad +(_agece -_bba ._feg ),Y1 :_gab ,X2 :_agdg +_afa /2-_abgdc +_bba ._dgga -(_ggc -_bba ._gea ),Y2 :_gab };
_ecb ,_ ,_bbdd :=_ebc .Draw ("");if _bbdd !=nil {return nil ,ctx ,_bbdd ;};_bbdd =_abf .addContentsByString (string (_ecb ));if _bbdd !=nil {return nil ,ctx ,_bbdd ;};};if _bba ._bbdf !=0{_gce :=_dggb ;_ebe :=_bbb -_bba ._fbce ;if _bba ._befg ==CellBorderStyleDouble {_ebe +=_efff ;
_bed :=_ce .BasicLine {LineWidth :_bba ._bbdf ,Opacity :1.0,LineColor :_gdfa (_bba ._ada ),LineStyle :_bba .LineStyle ,X1 :_gce -_adac /2+_gaec ,Y1 :_ebe -2*_efff ,X2 :_gce +_adac /2-_fegg +_bba ._dgga ,Y2 :_ebe -2*_efff };_gagb ,_ ,_eade :=_bed .Draw ("");
if _eade !=nil {return nil ,ctx ,_eade ;};_eade =_abf .addContentsByString (string (_gagb ));if _eade !=nil {return nil ,ctx ,_eade ;};};_gdc :=_ce .BasicLine {LineWidth :_bba ._bbdf ,Opacity :1.0,LineColor :_gdfa (_bba ._ada ),LineStyle :_bba .LineStyle ,X1 :_gce -_adac /2+_gaec +(_agece -_bba ._feg ),Y1 :_ebe ,X2 :_gce +_adac /2-_fegg +_bba ._dgga -(_ggc -_bba ._gea ),Y2 :_ebe };
_gdff ,_ ,_acd :=_gdc .Draw ("");if _acd !=nil {return nil ,ctx ,_acd ;};_acd =_abf .addContentsByString (string (_gdff ));if _acd !=nil {return nil ,ctx ,_acd ;};};if _bba ._feg !=0{_fffa :=_dggb ;_fdea :=_bbb ;if _bba ._dcda ==CellBorderStyleDouble {_fffa +=_eab ;
_egb :=_ce .BasicLine {LineWidth :_bba ._feg ,Opacity :1.0,LineColor :_gdfa (_bba ._bgfg ),LineStyle :_bba .LineStyle ,X1 :_fffa -2*_eab ,Y1 :_fdea +_agece /2+_cad ,X2 :_fffa -2*_eab ,Y2 :_fdea -_agece /2-_gaec -_bba ._fbce };_ggad ,_ ,_fbg :=_egb .Draw ("");
if _fbg !=nil {return nil ,ctx ,_fbg ;};_fbg =_abf .addContentsByString (string (_ggad ));if _fbg !=nil {return nil ,ctx ,_fbg ;};};_gfdc :=_ce .BasicLine {LineWidth :_bba ._feg ,Opacity :1.0,LineColor :_gdfa (_bba ._bgfg ),LineStyle :_bba .LineStyle ,X1 :_fffa ,Y1 :_fdea +_agece /2+_cad -(_afa -_bba ._ead ),X2 :_fffa ,Y2 :_fdea -_agece /2-_gaec -_bba ._fbce +(_adac -_bba ._bbdf )};
_bdgd ,_ ,_bdgf :=_gfdc .Draw ("");if _bdgf !=nil {return nil ,ctx ,_bdgf ;};_bdgf =_abf .addContentsByString (string (_bdgd ));if _bdgf !=nil {return nil ,ctx ,_bdgf ;};};if _bba ._gea !=0{_gdd :=_dggb +_bba ._dgga ;_bcgb :=_bbb ;if _bba ._adg ==CellBorderStyleDouble {_gdd -=_dgc ;
_dcfb :=_ce .BasicLine {LineWidth :_bba ._gea ,Opacity :1.0,LineColor :_gdfa (_bba ._fdaa ),LineStyle :_bba .LineStyle ,X1 :_gdd +2*_dgc ,Y1 :_bcgb +_ggc /2+_abgdc ,X2 :_gdd +2*_dgc ,Y2 :_bcgb -_ggc /2-_fegg -_bba ._fbce };_dcfc ,_ ,_bcc :=_dcfb .Draw ("");
if _bcc !=nil {return nil ,ctx ,_bcc ;};_bcc =_abf .addContentsByString (string (_dcfc ));if _bcc !=nil {return nil ,ctx ,_bcc ;};};_cdbc :=_ce .BasicLine {LineWidth :_bba ._gea ,Opacity :1.0,LineColor :_gdfa (_bba ._fdaa ),LineStyle :_bba .LineStyle ,X1 :_gdd ,Y1 :_bcgb +_ggc /2+_abgdc -(_afa -_bba ._ead ),X2 :_gdd ,Y2 :_bcgb -_ggc /2-_fegg -_bba ._fbce +(_adac -_bba ._bbdf )};
_ggdc ,_ ,_cge :=_cdbc .Draw ("");if _cge !=nil {return nil ,ctx ,_cge ;};_cge =_abf .addContentsByString (string (_ggdc ));if _cge !=nil {return nil ,ctx ,_cge ;};};return []*Block {_abf },ctx ,nil ;};

// FillColor returns the fill color of the ellipse.
func (_gbcf *Ellipse )FillColor ()Color {return _gbcf ._cbeb };type pageTransformations struct{_bff *_de .Matrix ;_gdbeg bool ;_bag bool ;};func (_becfb *templateProcessor )parseBorderRadiusAttr (_dgfab ,_bgbd string )(_bffge ,_bdffc ,_fccea ,_bffb float64 ){_eef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_dgfab ,_bgbd );
switch _ceda :=_dc .Fields (_bgbd );len (_ceda ){case 1:_bffge ,_ =_a .ParseFloat (_ceda [0],64);_bdffc =_bffge ;_fccea =_bffge ;_bffb =_bffge ;case 2:_bffge ,_ =_a .ParseFloat (_ceda [0],64);_fccea =_bffge ;_bdffc ,_ =_a .ParseFloat (_ceda [1],64);_bffb =_bdffc ;
case 3:_bffge ,_ =_a .ParseFloat (_ceda [0],64);_bdffc ,_ =_a .ParseFloat (_ceda [1],64);_bffb =_bdffc ;_fccea ,_ =_a .ParseFloat (_ceda [2],64);case 4:_bffge ,_ =_a .ParseFloat (_ceda [0],64);_bdffc ,_ =_a .ParseFloat (_ceda [1],64);_fccea ,_ =_a .ParseFloat (_ceda [2],64);
_bffb ,_ =_a .ParseFloat (_ceda [3],64);};return _bffge ,_bdffc ,_fccea ,_bffb ;};func (_egba *Division )split (_beae DrawContext )(_fgfa ,_acdc *Division ){var (_dddce float64 ;_ebgcf ,_ddea []VectorDrawable ;);_cbac :=_beae .Width -_egba ._cdef .Left -_egba ._cdef .Right -_egba ._dgfg .Left -_egba ._dgfg .Right ;
for _befda ,_afbg :=range _egba ._cga {_dddce +=_gdga (_afbg ,_cbac );if _dddce < _beae .Height {_ebgcf =append (_ebgcf ,_afbg );}else {_ddea =_egba ._cga [_befda :];break ;};};if len (_ebgcf )> 0{_fgfa =_cecg ();*_fgfa =*_egba ;_fgfa ._cga =_ebgcf ;if _egba ._gcde !=nil {_fgfa ._gcde =&Background {};
*_fgfa ._gcde =*_egba ._gcde ;};};if len (_ddea )> 0{_acdc =_cecg ();*_acdc =*_egba ;_acdc ._cga =_ddea ;if _egba ._gcde !=nil {_acdc ._gcde =&Background {};*_acdc ._gcde =*_egba ._gcde ;};};return _fgfa ,_acdc ;};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_aceab *Division )SetMargins (left ,right ,top ,bottom float64 ){_aceab ._cdef .Left =left ;_aceab ._cdef .Right =right ;_aceab ._cdef .Top =top ;_aceab ._cdef .Bottom =bottom ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_faff *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _faff ._fefca .Left ,_faff ._fefca .Right ,_faff ._fefca .Top ,_faff ._fefca .Bottom ;};

// MoveY moves the drawing context to absolute position y.
func (_bbbfd *Creator )MoveY (y float64 ){_bbbfd ._gbb .Y =y };func (_fcca *TextStyle )horizontalScale ()float64 {return _fcca .HorizontalScaling /100};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ff .ChartRenderable )*Chart {return _gggc (chart )};

// SetEnableWrap sets the line wrapping enabled flag.
func (_feca *Paragraph )SetEnableWrap (enableWrap bool ){_feca ._fade =enableWrap ;_feca ._gade =false };

// Lines returns all the lines the table of contents has.
func (_cdad *TOC )Lines ()[]*TOCLine {return _cdad ._agfbb };

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_cfda *Rectangle )ScaleToHeight (h float64 ){_gddbb :=_cfda ._faaa /_cfda ._baag ;_cfda ._baag =h ;_cfda ._faaa =h *_gddbb ;};func (_affcb *templateProcessor )parseInt64Attr (_ebfge ,_ceedd string )int64 {_eef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ebfge ,_ceedd );
_gcagd ,_ :=_a .ParseInt (_ceedd ,10,64);return _gcagd ;};var PPMM =float64 (72*1.0/25.4);func (_ecfedc *TableCell )height (_gcaef float64 )float64 {var _egeba float64 ;switch _ffafa :=_ecfedc ._cead .(type ){case *Paragraph :if _ffafa ._fade {_ffafa .SetWidth (_gcaef -_ecfedc ._ddbeg -_ffafa ._fbba .Left -_ffafa ._fbba .Right );
};_egeba =_ffafa .Height ()+_ffafa ._fbba .Top +_ffafa ._fbba .Bottom +0.5*_ffafa ._cgcbd *_ffafa ._ecegc ;case *StyledParagraph :if _ffafa ._dgba {_ffafa .SetWidth (_gcaef -_ecfedc ._ddbeg -_ffafa ._faaba .Left -_ffafa ._faaba .Right );};_egeba =_ffafa .Height ()+_ffafa ._faaba .Top +_ffafa ._faaba .Bottom +0.5*_ffafa .getTextHeight ();
case *Image :_ffafa .applyFitMode (_gcaef -_ecfedc ._ddbeg );_egeba =_ffafa .Height ()+_ffafa ._gbba .Top +_ffafa ._gbba .Bottom ;case *Table :_ffafa .updateRowHeights (_gcaef -_ecfedc ._ddbeg -_ffafa ._fefca .Left -_ffafa ._fefca .Right );_egeba =_ffafa .Height ()+_ffafa ._fefca .Top +_ffafa ._fefca .Bottom ;
case *List :_egeba =_ffafa .ctxHeight (_gcaef -_ecfedc ._ddbeg )+_ffafa ._eead .Top +_ffafa ._eead .Bottom ;case *Division :_egeba =_ffafa .ctxHeight (_gcaef -_ecfedc ._ddbeg )+_ffafa ._cdef .Top +_ffafa ._cdef .Bottom +_ffafa ._dgfg .Top +_ffafa ._dgfg .Bottom ;
case *Chart :_egeba =_ffafa .Height ()+_ffafa ._ebga .Top +_ffafa ._ebga .Bottom ;case *Rectangle :_ffafa .applyFitMode (_gcaef -_ecfedc ._ddbeg );_egeba =_ffafa .Height ()+_ffafa ._bacfa .Top +_ffafa ._bacfa .Bottom +_ffafa ._aebcg ;case *Ellipse :_ffafa .applyFitMode (_gcaef -_ecfedc ._ddbeg );
_egeba =_ffafa .Height ()+_ffafa ._dfac .Top +_ffafa ._dfac .Bottom ;case *Line :_egeba =_ffafa .Height ()+_ffafa ._dcdb .Top +_ffafa ._dcdb .Bottom ;};return _egeba ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_fbafc *Invoice )SetAddressStyle (style TextStyle ){_fbafc ._gbgdd =style };

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_aede *Ellipse )GetCoords ()(float64 ,float64 ){return _aede ._fgcb ,_aede ._eadb };

// InsertColumn inserts a column in the line items table at the specified index.
func (_cgcgb *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dbbga :=uint (len (_cgcgb ._cgcg ));if index > _dbbga {index =_dbbga ;};_dgdc :=_cgcgb .NewColumn (description );_cgcgb ._cgcg =append (_cgcgb ._cgcg [:index ],append ([]*InvoiceCell {_dgdc },_cgcgb ._cgcg [index :]...)...);
return _dgdc ;};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_dfde *LinearShading )SetAngle (angle float64 ){_dfde ._gfgaf =angle };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_fbeaf []*listItem ;_eead Margins ;_cgef TextChunk ;_dcdc float64 ;_ecfac bool ;_caea Positioning ;_dbca TextStyle ;};

// SetDate sets the date of the invoice.
func (_gccb *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_gccb ._bacd [1].Value =date ;return _gccb ._bacd [0],_gccb ._bacd [1];};func (_ggcda *Table )moveToNextAvailableCell ()int {_adcc :=(_ggcda ._aeba -1)%(_ggcda ._beege )+1;for {if _adcc -1>=len (_ggcda ._cgbff ){if _ggcda ._cgbff [0]==0{return _adcc ;
};_adcc =1;}else if _ggcda ._cgbff [_adcc -1]==0{return _adcc ;};_ggcda ._aeba ++;_ggcda ._cgbff [_adcc -1]--;_adcc ++;};};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gcedfc *Rectangle )SetFitMode (fitMode FitMode ){_gcedfc ._gcdg =fitMode };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_efbe *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_efbe ._beege {_eef .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_efbe ._gaecf =widths ;return nil ;};

// SkipCells skips over a specified number of cells in the table.
func (_dacac *Table )SkipCells (num int ){if num < 0{_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _fabg :=0;_fabg < num ;_fabg ++{_dacac .NewCell ();};};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_fgcb float64 ;_eadb float64 ;_bgea float64 ;_dceb float64 ;_dada Positioning ;_cbeb Color ;_facc float64 ;_edcd Color ;_cadd float64 ;_acdcf float64 ;_dfac Margins ;_facg FitMode ;};

// Angle returns the block rotation angle in degrees.
func (_gf *Block )Angle ()float64 {return _gf ._eb };func (_agcg *InvoiceAddress )fmtLine (_ecab ,_bbac string ,_eadd bool )string {if _eadd {_bbac ="";};return _g .Sprintf ("\u0025\u0073\u0025s\u000a",_bbac ,_ecab );};func _bfed (_cfbca string )bool {_dgeafd :=func (_cfgcg rune )bool {return _cfgcg =='\u000A'};
_aegad :=_dc .TrimFunc (_cfbca ,_dgeafd );_fffba :=_b .Paragraph {};_ ,_bcfee :=_fffba .SetString (_aegad );if _bcfee !=nil {return true ;};_faafb ,_bcfee :=_fffba .Order ();if _bcfee !=nil {return true ;};if _faafb .NumRuns ()< 1{return true ;};return _fffba .IsLeftToRight ();
};func (_faad *templateProcessor )nodeLogError (_feaaa *templateNode ,_adbd string ,_dddbef ...interface{}){_eef .Log .Error (_faad .getNodeErrorLocation (_feaaa ,_adbd ,_dddbef ...));};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_dfeg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_ccbb :=uint (len (_dfeg ._cfbcg ));if index > _ccbb {index =_ccbb ;};_egcf :=NewTextChunk (text ,_dfeg ._aegbg );_dfeg ._cfbcg =append (_dfeg ._cfbcg [:index ],append ([]*TextChunk {_egcf },_dfeg ._cfbcg [index :]...)...);
_dfeg .wrapText ();return _egcf ;};

// SetWidthTop sets border width for top.
func (_bgc *border )SetWidthTop (bw float64 ){_bgc ._ead =bw };

// NewImageFromData creates an Image from image data.
func (_ebbd *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ggcb (data )};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_ecdg *List )Width ()float64 {return 0};func (_cgbe *templateProcessor )parseCellBorderStyleAttr (_cfcbca ,_ggfbd string )CellBorderStyle {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_cfcbca ,_ggfbd );
_ggef :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_ggfbd ];return _ggef ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_gbdg *Creator )NewPage ()*_fa .PdfPage {_dddc :=_gbdg .newPage ();_gbdg ._ccgg =append (_gbdg ._ccgg ,_dddc );_gbdg ._gbb .Page ++;return _dddc ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_bfdb rune ;_bdfb []error ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_dcbeb *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_addcc :=range subtable ._bdfef {_egab :=&TableCell {};*_egab =*_addcc ;_egab ._edfg =_dcbeb ;_egab ._baceb +=col -1;if _accd :=_dcbeb ._beege -(_egab ._baceb -1);_accd < _egab ._gfeb {_dcbeb ._beege +=_egab ._gfeb -_accd ;
_dcbeb .resetColumnWidths ();_eef .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_dcbeb ._beege );
};_egab ._cceef +=row -1;_bgcf :=subtable ._cddcg [_addcc ._cceef -1];if _egab ._cceef > _dcbeb ._cccb {for _egab ._cceef > _dcbeb ._cccb {_dcbeb ._cccb ++;_dcbeb ._cddcg =append (_dcbeb ._cddcg ,_dcbeb ._efbgd );};_dcbeb ._cddcg [_egab ._cceef -1]=_bgcf ;
}else {_dcbeb ._cddcg [_egab ._cceef -1]=_ec .Max (_dcbeb ._cddcg [_egab ._cceef -1],_bgcf );};_dcbeb ._bdfef =append (_dcbeb ._bdfef ,_egab );};_dcbeb .sortCells ();};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;
AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);func (_gbff *Table )resetColumnWidths (){_gbff ._gaecf =[]float64 {};_cgdad :=float64 (1.0)/float64 (_gbff ._beege );for _eaabb :=0;_eaabb < _gbff ._beege ;_eaabb ++{_gbff ._gaecf =append (_gbff ._gaecf ,_cgdad );
};};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_gcdge *TableCell )SetContent (vd VectorDrawable )error {switch _gdde :=vd .(type ){case *Paragraph :if _gdde ._gade {_gdde ._fade =true ;};_gcdge ._cead =vd ;case *StyledParagraph :if _gdde ._gadge {_gdde ._dgba =true ;};_gcdge ._cead =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_gcdge ._cead =vd ;
default:_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _ea .ErrTypeError ;};return nil ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func _eecf ()*FilledCurve {_dgeb :=FilledCurve {};_dgeb ._edeb =[]_ce .CubicBezierCurve {};return &_dgeb ;};

// SetFillOpacity sets the fill opacity.
func (_edaa *CurvePolygon )SetFillOpacity (opacity float64 ){_edaa ._bcfd =opacity };

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_cgba *Image )SetFitMode (fitMode FitMode ){_cgba ._bdbe =fitMode };

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_aggd *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_geaf []*Block ;_acge =NewBlock (ctx .PageWidth ,ctx .PageHeight );_beac =ctx ;);_cfbgd :=_aggd ._dada .IsRelative ();if _cfbgd {_aggd .applyFitMode (ctx .Width );
ctx .X +=_aggd ._dfac .Left ;ctx .Y +=_aggd ._dfac .Top ;ctx .Width -=_aggd ._dfac .Left +_aggd ._dfac .Right ;ctx .Height -=_aggd ._dfac .Top +_aggd ._dfac .Bottom ;if _aggd ._dceb > ctx .Height {_geaf =append (_geaf ,_acge );_acge =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_efgc :=ctx ;_efgc .Y =ctx .Margins .Top +_aggd ._dfac .Top ;_efgc .X =ctx .Margins .Left +_aggd ._dfac .Left ;_efgc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aggd ._dfac .Top -_aggd ._dfac .Bottom ;_efgc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aggd ._dfac .Left -_aggd ._dfac .Right ;
ctx =_efgc ;};}else {ctx .X =_aggd ._fgcb -_aggd ._bgea /2;ctx .Y =_aggd ._eadb -_aggd ._dceb /2;};_defg :=_ce .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_aggd ._dceb ,Width :_aggd ._bgea ,Height :_aggd ._dceb ,BorderWidth :_aggd ._cadd ,Opacity :1.0};
if _aggd ._cbeb !=nil {_defg .FillEnabled =true ;_bgec :=_gdfa (_aggd ._cbeb );_dgfac :=_ddcd (_acge ,_bgec ,_aggd ._cbeb ,func ()Rectangle {return Rectangle {_dfbc :_defg .X ,_gbfgg :_defg .Y ,_faaa :_defg .Width ,_baag :_defg .Height };});if _dgfac !=nil {return nil ,ctx ,_dgfac ;
};_defg .FillColor =_bgec ;};if _aggd ._edcd !=nil {_defg .BorderEnabled =false ;if _aggd ._cadd > 0{_defg .BorderEnabled =true ;};_defg .BorderColor =_gdfa (_aggd ._edcd );_defg .BorderWidth =_aggd ._cadd ;};_fbdb ,_cggda :=_acge .setOpacity (_aggd ._facc ,_aggd ._acdcf );
if _cggda !=nil {return nil ,ctx ,_cggda ;};_eecbf ,_ ,_cggda :=_defg .Draw (_fbdb );if _cggda !=nil {return nil ,ctx ,_cggda ;};_cggda =_acge .addContentsByString (string (_eecbf ));if _cggda !=nil {return nil ,ctx ,_cggda ;};if _cfbgd {ctx .X =_beac .X ;
ctx .Width =_beac .Width ;ctx .Y +=_aggd ._dceb +_aggd ._dfac .Bottom ;ctx .Height -=_aggd ._dceb ;}else {ctx =_beac ;};_geaf =append (_geaf ,_acge );return _geaf ,ctx ,nil ;};func _gddcg (_becge *Block ,_acgb *StyledParagraph ,_ebgf [][]*TextChunk ,_dbbc DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bbf :=1;
_cafd :=_ea .PdfObjectName (_g .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbf ));for _becge ._gae .HasFontByName (_cafd ){_bbf ++;_cafd =_ea .PdfObjectName (_g .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbf ));};_aagga :=_becge ._gae .SetFontByName (_cafd ,_acgb ._aegbg .Font .ToPdfObject ());
if _aagga !=nil {return _dbbc ,nil ,_aagga ;};_bbf ++;_fbffg :=_cafd ;_daffd :=_acgb ._aegbg .FontSize ;_abbb :=_acgb ._defc .IsRelative ();var _cbfe [][]_ea .PdfObjectName ;var _dbfg [][]*TextChunk ;var _bgdb float64 ;for _cbg ,_ggbc :=range _ebgf {var _gfgg []_ea .PdfObjectName ;
var _egbb float64 ;if len (_ggbc )> 0{_egbb =_ggbc [0].Style .FontSize ;};for _ ,_cdgd :=range _ggbc {_cbbbg :=_cdgd .Style ;if _cdgd .Text !=""&&_cbbbg .FontSize > _egbb {_egbb =_cbbbg .FontSize ;};if _egbb > _dbbc .PageHeight {return _dbbc ,nil ,_e .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_cafd =_ea .PdfObjectName (_g .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbf ));_dfae :=_becge ._gae .SetFontByName (_cafd ,_cbbbg .Font .ToPdfObject ());if _dfae !=nil {return _dbbc ,nil ,_dfae ;};_gfgg =append (_gfgg ,_cafd );_bbf ++;};_egbb *=_acgb ._gbcb ;
if _abbb &&_bgdb +_egbb > _dbbc .Height {_dbfg =_ebgf [_cbg :];_ebgf =_ebgf [:_cbg ];break ;};_bgdb +=_egbb ;_cbfe =append (_cbfe ,_gfgg );};_fcag ,_fgeb ,_fecaa :=_acgb .getLineMetrics (0);_fddec ,_fbfed :=_fcag *_acgb ._gbcb ,_fgeb *_acgb ._gbcb ;if len (_ebgf )==0{return _dbbc ,_dbfg ,nil ;
};_gagaf :=_bd .NewContentCreator ();_gagaf .Add_q ();_gcdb :=_fbfed ;if _acgb ._ggdf ==TextVerticalAlignmentCenter {_gcdb =_fgeb +(_fcag +_fecaa -_fgeb )/2+(_fbfed -_fgeb )/2;};_agbg :=_dbbc .PageHeight -_dbbc .Y -_gcdb ;_gagaf .Translate (_dbbc .X ,_agbg );
_gacfa :=_agbg ;if _acgb ._cefe !=0{_gagaf .RotateDeg (_acgb ._cefe );};if _acgb ._ebebd ==TextOverflowHidden {_gagaf .Add_re (0,-_bgdb +_fddec +1,_acgb ._fdfbb ,_bgdb ).Add_W ().Add_n ();};_gagaf .Add_BT ();_dfbg :=0.0;var _ecefa []*_ce .BasicLine ;for _fbgge ,_bdfaa :=range _ebgf {_fdfbc :=_dbbc .X ;
var _dbcgc float64 ;if len (_bdfaa )> 0{_dbcgc =_bdfaa [0].Style .FontSize ;};_fcag ,_ ,_fecaa =_acgb .getLineMetrics (_fbgge );_fbfed =(_fcag +_fecaa );for _ ,_gccd :=range _bdfaa {_gdcbf :=&_gccd .Style ;if _gccd .Text !=""&&_gdcbf .FontSize > _dbcgc {_dbcgc =_gdcbf .FontSize ;
};if _fbfed > _dbcgc {_dbcgc =_fbfed ;};};if _fbgge !=0{_gagaf .Add_TD (0,-_dbcgc *_acgb ._gbcb +_dfbg );_gacfa -=_dbcgc *_acgb ._gbcb +_dfbg ;_dfbg =0.0;};_bgcc :=_fbgge ==len (_ebgf )-1;var (_gbaf float64 ;_egcab float64 ;_faefc *fontMetrics ;_cfgece float64 ;
_bgebb uint ;);var _eaba []float64 ;for _ ,_dbed :=range _bdfaa {_acfd :=&_dbed .Style ;if _acfd .FontSize > _egcab {_egcab =_acfd .FontSize ;_faefc =_feada (_dbed .Style .Font ,_acfd .FontSize );};if _fbfed > _egcab {_egcab =_fbfed ;};_cfba ,_eace :=_acfd .Font .GetRuneMetrics (' ');
if !_eace {return _dbbc ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _bdfbf uint ;var _bfca float64 ;_abegf :=len (_dbed .Text );
for _fccg ,_aged :=range _dbed .Text {if _aged ==' '{_bdfbf ++;continue ;};if _aged =='\u000A'{continue ;};_ffee ,_acdd :=_acfd .Font .GetRuneMetrics (_aged );if !_acdd {_eef .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_aged );
return _dbbc ,nil ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bfca +=_acfd .FontSize *_ffee .Wx *_acfd .horizontalScale ();if _fccg !=_abegf -1{_bfca +=_acfd .CharSpacing *1000.0;
};};_eaba =append (_eaba ,_bfca );_gbaf +=_bfca ;_cfgece +=float64 (_bdfbf )*_cfba .Wx *_acfd .FontSize *_acfd .horizontalScale ();_bgebb +=_bdfbf ;};_egcab *=_acgb ._gbcb ;var _fcceb []_ea .PdfObject ;_cdccb :=_acgb ._fdfbb *1000.0;if _acgb ._dgbde ==TextAlignmentJustify {if _bgebb > 0&&!_bgcc {_cfgece =(_cdccb -_gbaf )/float64 (_bgebb )/_daffd ;
};}else if _acgb ._dgbde ==TextAlignmentCenter {_aaeb :=(_cdccb -_gbaf -_cfgece )/2;_ccac :=_aaeb /_daffd ;_fcceb =append (_fcceb ,_ea .MakeFloat (-_ccac ));_fdfbc +=_aaeb /1000.0;}else if _acgb ._dgbde ==TextAlignmentRight {_gfdf :=(_cdccb -_gbaf -_cfgece );
_feag :=_gfdf /_daffd ;_fcceb =append (_fcceb ,_ea .MakeFloat (-_feag ));_fdfbc +=_gfdf /1000.0;};if len (_fcceb )> 0{_gagaf .Add_Tf (_fbffg ,_daffd ).Add_TL (_daffd *_acgb ._gbcb ).Add_TJ (_fcceb ...);};_beef :=0.0;for _eaaba ,_ccfgf :=range _bdfaa {_cfedb :=&_ccfgf .Style ;
_fdbd :=_fbffg ;_ddfg :=_daffd ;_babc :=_cfedb .OutlineColor !=nil ;_fadbe :=_cfedb .HorizontalScaling !=DefaultHorizontalScaling ;_fabbg :=_cfedb .OutlineSize !=1;if _fabbg {_gagaf .Add_w (_cfedb .OutlineSize );};_cacbc :=_cfedb .RenderingMode !=TextRenderingModeFill ;
if _cacbc {_gagaf .Add_Tr (int64 (_cfedb .RenderingMode ));};_gddg :=_cfedb .CharSpacing !=0;if _gddg {_gagaf .Add_Tc (_cfedb .CharSpacing );};_ecgc :=_cfedb .TextRise !=0;if _ecgc {_gagaf .Add_Ts (_cfedb .TextRise );};if _ccfgf .VerticalAlignment !=TextVerticalAlignmentBaseline {_feddf :=_feada (_ccfgf .Style .Font ,_cfedb .FontSize );
switch _ccfgf .VerticalAlignment {case TextVerticalAlignmentCenter :_beef =_faefc ._gbffe /2-_feddf ._gbffe /2;case TextVerticalAlignmentBottom :_beef =_faefc ._dgad -_feddf ._dgad ;case TextVerticalAlignmentTop :_beef =_fgeb -_cfedb .FontSize ;};if _beef !=0.0{_gagaf .Translate (0,_beef );
};};if _acgb ._dgbde !=TextAlignmentJustify ||_bgcc {_gdcf ,_gadfb :=_cfedb .Font .GetRuneMetrics (' ');if !_gadfb {return _dbbc ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_fdbd =_cbfe [_fbgge ][_eaaba ];_ddfg =_cfedb .FontSize ;_cfgece =_gdcf .Wx *_cfedb .horizontalScale ();};_adgg :=_cfedb .Font .Encoder ();var _dfag []byte ;for _ ,_eaea :=range _ccfgf .Text {if _eaea =='\u000A'{continue ;};if _eaea ==' '{if len (_dfag )> 0{if _babc {_gagaf .SetStrokingColor (_gdfa (_cfedb .OutlineColor ));
};if _fadbe {_gagaf .Add_Tz (_cfedb .HorizontalScaling );};_gagaf .SetNonStrokingColor (_gdfa (_cfedb .Color )).Add_Tf (_cbfe [_fbgge ][_eaaba ],_cfedb .FontSize ).Add_TJ ([]_ea .PdfObject {_ea .MakeStringFromBytes (_dfag )}...);_dfag =nil ;};if _fadbe {_gagaf .Add_Tz (DefaultHorizontalScaling );
};_gagaf .Add_Tf (_fdbd ,_ddfg ).Add_TJ ([]_ea .PdfObject {_ea .MakeFloat (-_cfgece )}...);_eaba [_eaaba ]+=_cfgece *_ddfg ;}else {if _ ,_gcfeg :=_adgg .RuneToCharcode (_eaea );!_gcfeg {_aagga =UnsupportedRuneError {Message :_g .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eaea ,_eaea ),Rune :_eaea };
_dbbc ._bdfb =append (_dbbc ._bdfb ,_aagga );_eef .Log .Debug (_aagga .Error ());if _dbbc ._bfdb <=0{continue ;};_eaea =_dbbc ._bfdb ;};_dfag =append (_dfag ,_adgg .Encode (string (_eaea ))...);};};if len (_dfag )> 0{if _babc {_gagaf .SetStrokingColor (_gdfa (_cfedb .OutlineColor ));
};if _fadbe {_gagaf .Add_Tz (_cfedb .HorizontalScaling );};_gagaf .SetNonStrokingColor (_gdfa (_cfedb .Color )).Add_Tf (_cbfe [_fbgge ][_eaaba ],_cfedb .FontSize ).Add_TJ ([]_ea .PdfObject {_ea .MakeStringFromBytes (_dfag )}...);};_daffc :=_eaba [_eaaba ]/1000.0;
if _cfedb .Underline {_eedbd :=_cfedb .UnderlineStyle .Color ;if _eedbd ==nil {_eedbd =_ccfgf .Style .Color ;};_eaga ,_ggcd ,_eecbd :=_eedbd .ToRGB ();_cgbf :=_fdfbc -_dbbc .X ;_edgd :=_gacfa -_agbg +_cfedb .TextRise -_cfedb .UnderlineStyle .Offset ;_ecefa =append (_ecefa ,&_ce .BasicLine {X1 :_cgbf ,Y1 :_edgd ,X2 :_cgbf +_daffc ,Y2 :_edgd ,LineWidth :_ccfgf .Style .UnderlineStyle .Thickness ,LineColor :_fa .NewPdfColorDeviceRGB (_eaga ,_ggcd ,_eecbd )});
};if _ccfgf ._gbgga !=nil {var _dgfgf *_ea .PdfObjectArray ;if !_ccfgf ._gdffd {switch _ecdb :=_ccfgf ._gbgga .GetContext ().(type ){case *_fa .PdfAnnotationLink :_dgfgf =_ea .MakeArray ();_ecdb .Rect =_dgfgf ;_acegb ,_dfgca :=_ecdb .Dest .(*_ea .PdfObjectArray );
if _dfgca &&_acegb .Len ()==5{_ceedca ,_gaae :=_acegb .Get (1).(*_ea .PdfObjectName );if _gaae &&_ceedca .String ()=="\u0058\u0059\u005a"{_egebf ,_agdf :=_ea .GetNumberAsFloat (_acegb .Get (3));if _agdf ==nil {_acegb .Set (3,_ea .MakeFloat (_dbbc .PageHeight -_egebf ));
};};};};_ccfgf ._gdffd =true ;};if _dgfgf !=nil {_eded :=_ce .NewPoint (_fdfbc -_dbbc .X ,_gacfa +_cfedb .TextRise -_agbg ).Rotate (_acgb ._cefe );_eded .X +=_dbbc .X ;_eded .Y +=_agbg ;_cdfa ,_eaabe ,_bfagg ,_gbab :=_decad (_daffc ,_egcab ,_acgb ._cefe );
_eded .X +=_cdfa ;_eded .Y +=_eaabe ;_dgfgf .Clear ();_dgfgf .Append (_ea .MakeFloat (_eded .X ));_dgfgf .Append (_ea .MakeFloat (_eded .Y ));_dgfgf .Append (_ea .MakeFloat (_eded .X +_bfagg ));_dgfgf .Append (_ea .MakeFloat (_eded .Y +_gbab ));};_becge .AddAnnotation (_ccfgf ._gbgga );
};_fdfbc +=_daffc ;if _fabbg {_gagaf .Add_w (1.0);};if _babc {_gagaf .Add_RG (0.0,0.0,0.0);};if _cacbc {_gagaf .Add_Tr (int64 (TextRenderingModeFill ));};if _gddg {_gagaf .Add_Tc (0);};if _ecgc {_gagaf .Add_Ts (0);};if _fadbe {_gagaf .Add_Tz (DefaultHorizontalScaling );
};if _beef !=0.0{_gagaf .Translate (0,-_beef );_beef =0.0;};};};_gagaf .Add_ET ();for _ ,_abacg :=range _ecefa {_gagaf .SetStrokingColor (_abacg .LineColor ).Add_w (_abacg .LineWidth ).Add_m (_abacg .X1 ,_abacg .Y1 ).Add_l (_abacg .X2 ,_abacg .Y2 ).Add_s ();
};_gagaf .Add_Q ();_cebee :=_gagaf .Operations ();_cebee .WrapIfNeeded ();_becge .addContents (_cebee );if _abbb {_afced :=_bgdb ;_dbbc .Y +=_afced ;_dbbc .Height -=_afced ;if _dbbc .Inline {_dbbc .X +=_acgb .Width ()+_acgb ._faaba .Right ;};};return _dbbc ,_dbfg ,nil ;
};

// Scale scales the rectangle dimensions by the specified factors.
func (_adaa *Rectangle )Scale (xFactor ,yFactor float64 ){_adaa ._faaa =xFactor *_adaa ._faaa ;_adaa ._baag =yFactor *_adaa ._baag ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_daadd *TOC )SetLineStyle (style TextStyle ){_daadd .SetLineNumberStyle (style );_daadd .SetLineTitleStyle (style );_daadd .SetLineSeparatorStyle (style );_daadd .SetLinePageStyle (style );};

// SetDueDate sets the due date of the invoice.
func (_ffgb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_ffgb ._gdcc [1].Value =dueDate ;return _ffgb ._gdcc [0],_ffgb ._gdcc [1];};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_dcdef *List )Add (item VectorDrawable )(*TextChunk ,error ){_cafe :=&listItem {_edcf :item ,_dbea :_dcdef ._cgef };switch _cabg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cabg ._ecfac {_cabg ._dcdc =15;};case *Division :case *Image :case *Table :default:return nil ,_e .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_dcdef ._fbeaf =append (_dcdef ._fbeaf ,_cafe );return &_cafe ._dbea ,nil ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_babad *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_bbaf :=&InvoiceCell {_babad ._defd ,desc };_bgde :=&InvoiceCell {_babad ._defd ,value };_babad ._cgca =append (_babad ._cgca ,[2]*InvoiceCell {_bbaf ,_bgde });return _bbaf ,_bgde ;
};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_fcfd *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcfd ._dfac .Left ,_fcfd ._dfac .Right ,_fcfd ._dfac .Top ,_fcfd ._dfac .Bottom ;};

// SetFillOpacity sets the fill opacity.
func (_efbaf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_efbaf ._egff =opacity };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_bceg *Table )NewCell ()*TableCell {return _bceg .MultiCell (1,1)};func (_fgca *RadialShading )shadingModel ()*_fa .PdfShadingType3 {_ffafd ,_adff ,_fcee :=_fgca ._gcbg ._cfcbc .ToRGB ();var _ccag _ce .Point ;switch _fgca ._egce {case AnchorBottomLeft :_ccag =_ce .Point {X :_fgca ._beaeb .Llx ,Y :_fgca ._beaeb .Lly };
case AnchorBottomRight :_ccag =_ce .Point {X :_fgca ._beaeb .Urx ,Y :_fgca ._beaeb .Ury -_fgca ._beaeb .Height ()};case AnchorTopLeft :_ccag =_ce .Point {X :_fgca ._beaeb .Llx ,Y :_fgca ._beaeb .Lly +_fgca ._beaeb .Height ()};case AnchorTopRight :_ccag =_ce .Point {X :_fgca ._beaeb .Urx ,Y :_fgca ._beaeb .Ury };
case AnchorLeft :_ccag =_ce .Point {X :_fgca ._beaeb .Llx ,Y :_fgca ._beaeb .Lly +_fgca ._beaeb .Height ()/2};case AnchorTop :_ccag =_ce .Point {X :_fgca ._beaeb .Llx +_fgca ._beaeb .Width ()/2,Y :_fgca ._beaeb .Ury };case AnchorRight :_ccag =_ce .Point {X :_fgca ._beaeb .Urx ,Y :_fgca ._beaeb .Lly +_fgca ._beaeb .Height ()/2};
case AnchorBottom :_ccag =_ce .Point {X :_fgca ._beaeb .Urx +_fgca ._beaeb .Width ()/2,Y :_fgca ._beaeb .Lly };default:_ccag =_ce .NewPoint (_fgca ._beaeb .Llx +_fgca ._beaeb .Width ()/2,_fgca ._beaeb .Lly +_fgca ._beaeb .Height ()/2);};_bgad :=_fgca ._ffdcgf ;
_fbfa :=_fgca ._cbbaf ;_beed :=_ccag .X +_fgca ._eebg ;_ddad :=_ccag .Y +_fgca ._dged ;if _bgad ==-1.0{_bgad =0.0;};if _fbfa ==-1.0{var _fabe []float64 ;_cabd :=_ec .Pow (_beed -_fgca ._beaeb .Llx ,2)+_ec .Pow (_ddad -_fgca ._beaeb .Lly ,2);_fabe =append (_fabe ,_ec .Abs (_cabd ));
_acde :=_ec .Pow (_beed -_fgca ._beaeb .Llx ,2)+_ec .Pow (_fgca ._beaeb .Lly +_fgca ._beaeb .Height ()-_ddad ,2);_fabe =append (_fabe ,_ec .Abs (_acde ));_cedf :=_ec .Pow (_fgca ._beaeb .Urx -_beed ,2)+_ec .Pow (_ddad -_fgca ._beaeb .Ury -_fgca ._beaeb .Height (),2);
_fabe =append (_fabe ,_ec .Abs (_cedf ));_bfage :=_ec .Pow (_fgca ._beaeb .Urx -_beed ,2)+_ec .Pow (_fgca ._beaeb .Ury -_ddad ,2);_fabe =append (_fabe ,_ec .Abs (_bfage ));_d .Slice (_fabe ,func (_fefcb ,_bdfe int )bool {return _fefcb > _bdfe });_fbfa =_ec .Sqrt (_fabe [0]);
};_begad :=&_fa .PdfRectangle {Llx :_beed -_fbfa ,Lly :_ddad -_fbfa ,Urx :_beed +_fbfa ,Ury :_ddad +_fbfa };_ggdbc :=_fa .NewPdfShadingType3 ();_ggdbc .PdfShading .ShadingType =_ea .MakeInteger (3);_ggdbc .PdfShading .ColorSpace =_fa .NewPdfColorspaceDeviceRGB ();
_ggdbc .PdfShading .Background =_ea .MakeArrayFromFloats ([]float64 {_ffafd ,_adff ,_fcee });_ggdbc .PdfShading .BBox =_begad ;_ggdbc .PdfShading .AntiAlias =_ea .MakeBool (_fgca ._gcbg ._eadef );_ggdbc .Coords =_ea .MakeArrayFromFloats ([]float64 {_beed ,_ddad ,_bgad ,_beed ,_ddad ,_fbfa });
_ggdbc .Domain =_ea .MakeArrayFromFloats ([]float64 {0.0,1.0});_ggdbc .Extend =_ea .MakeArray (_ea .MakeBool (_fgca ._gcbg ._ffcf [0]),_ea .MakeBool (_fgca ._gcbg ._ffcf [1]));_ggdbc .Function =_fgca ._gcbg .generatePdfFunctions ();return _ggdbc ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_fa .PdfPage )(*Block ,error ){_eefg :=&Block {};_gb ,_db :=page .GetAllContentStreams ();if _db !=nil {return nil ,_db ;};_aa :=_bd .NewContentStreamParser (_gb );_ba ,_db :=_aa .Parse ();if _db !=nil {return nil ,_db ;};_ba .WrapIfNeeded ();
_eefg ._ffc =_ba ;if page .Resources !=nil {_eefg ._gae =page .Resources ;}else {_eefg ._gae =_fa .NewPdfPageResources ();};_bab ,_db :=page .GetMediaBox ();if _db !=nil {return nil ,_db ;};if _bab .Llx !=0||_bab .Lly !=0{_eefg .translate (-_bab .Llx ,_bab .Lly );
};_eefg ._bc =_bab .Urx -_bab .Llx ;_eefg ._dec =_bab .Ury -_bab .Lly ;if page .Rotate !=nil {_eefg ._eb =-float64 (*page .Rotate );};return _eefg ,nil ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_eacfg *TOCLine )LevelOffset ()float64 {return _eacfg ._ddccb };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_efbc *Creator )AddPage (page *_fa .PdfPage )error {_aeefg ,_ddga :=_efbc .wrapPageIfNeeded (page );if _ddga !=nil {return _ddga ;};if _aeefg !=nil {page =_aeefg ;};_fegd ,_ddga :=page .GetMediaBox ();if _ddga !=nil {_eef .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ddga );
return _ddga ;};_fegd .Normalize ();_ggga ,_dde :=_fegd .Llx ,_fegd .Lly ;_feaa :=_fegd ;if _ceed :=page .CropBox ;_ceed !=nil &&*_ceed !=*_fegd {_ceed .Normalize ();_ggga ,_dde =_ceed .Llx ,_ceed .Lly ;_feaa =_ceed ;};_def :=_de .IdentityMatrix ();_aaca ,_ddga :=page .GetRotate ();
if _ddga !=nil {_eef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ddga .Error ());
};_acf :=_aaca %360!=0&&_aaca %90==0;if _acf {_gaed :=float64 ((360+_aaca %360)%360);if _gaed ==90{_def =_def .Translate (_feaa .Width (),0);}else if _gaed ==180{_def =_def .Translate (_feaa .Width (),_feaa .Height ());}else if _gaed ==270{_def =_def .Translate (0,_feaa .Height ());
};_def =_def .Mult (_de .RotationMatrix (_gaed *_ec .Pi /180));_def =_def .Round (0.000001);_dabdd :=_ffedb (_feaa ,_def );_feaa =_dabdd ;_feaa .Normalize ();};if _ggga !=0||_dde !=0{_def =_de .TranslationMatrix (_ggga ,_dde ).Mult (_def );};if !_def .Identity (){_def =_def .Round (0.000001);
_efbc ._fgec [page ]=&pageTransformations {_bff :&_def };};_efbc ._ggfe =_feaa .Width ();_efbc ._bbdg =_feaa .Height ();_efbc .initContext ();_efbc ._ccgg =append (_efbc ._ccgg ,page );_efbc ._gbb .Page ++;return nil ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_eeac *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_deeb :=_bd .NewContentCreator ();_deeb .Add_q ().Add_w (_eeac ._geeb ).SetStrokingColor (_gdfa (_eeac ._adfb )).Add_m (_eeac ._cfd ,ctx .PageHeight -_eeac ._cdbb ).Add_v (_eeac ._bcga ,ctx .PageHeight -_eeac ._affa ,_eeac ._bcca ,ctx .PageHeight -_eeac ._acdbc ).Add_S ().Add_Q ();
_gdee :=_bgga .addContentsByString (_deeb .String ());if _gdee !=nil {return nil ,ctx ,_gdee ;};return []*Block {_bgga },ctx ,nil ;};func (_fegfa *TextChunk )clone ()*TextChunk {_dbabg :=*_fegfa ;_dbabg ._gbgga =_bdfgc (_fegfa ._gbgga );return &_dbabg ;
};

// SetAnchor set gradient position anchor.
// Default to center.
func (_cdec *RadialShading )SetAnchor (anchor AnchorPoint ){_cdec ._egce =anchor };func _ffedb (_ecbaa *_fa .PdfRectangle ,_ffdcf _de .Matrix )*_fa .PdfRectangle {var _ggfab _fa .PdfRectangle ;_ggfab .Llx ,_ggfab .Lly =_ffdcf .Transform (_ecbaa .Llx ,_ecbaa .Lly );
_ggfab .Urx ,_ggfab .Ury =_ffdcf .Transform (_ecbaa .Urx ,_ecbaa .Ury );_ggfab .Normalize ();return &_ggfab ;};func (_ca *Block )addContentsByString (_bcd string )error {_cf :=_bd .NewContentStreamParser (_bcd );_cdd ,_ggg :=_cf .Parse ();if _ggg !=nil {return _ggg ;
};_ca ._ffc .WrapIfNeeded ();_cdd .WrapIfNeeded ();*_ca ._ffc =append (*_ca ._ffc ,*_cdd ...);return nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_bfee *Table )EnableRowWrap (enable bool ){_bfee ._dbac =enable };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_cdba *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aaadc :=ctx ;var _cege []*Block ;_cacfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cdba ._aacf .IsRelative (){ctx .X +=_cdba ._fbba .Left ;ctx .Y +=_cdba ._fbba .Top ;
ctx .Width -=_cdba ._fbba .Left +_cdba ._fbba .Right ;ctx .Height -=_cdba ._fbba .Top ;_cdba .SetWidth (ctx .Width );if _cdba .Height ()> ctx .Height {_cege =append (_cege ,_cacfb );_cacfb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_aead :=ctx ;
_aead .Y =ctx .Margins .Top ;_aead .X =ctx .Margins .Left +_cdba ._fbba .Left ;_aead .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_aead .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cdba ._fbba .Left -_cdba ._fbba .Right ;
ctx =_aead ;};}else {if int (_cdba ._gdffb )<=0{_cdba .SetWidth (_cdba .getTextWidth ());};ctx .X =_cdba ._ggde ;ctx .Y =_cdba ._ffdcg ;};ctx ,_caaa :=_dbdee (_cacfb ,_cdba ,ctx );if _caaa !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_caaa );
return nil ,ctx ,_caaa ;};_cege =append (_cege ,_cacfb );if _cdba ._aacf .IsRelative (){ctx .Y +=_cdba ._fbba .Bottom ;ctx .Height -=_cdba ._fbba .Bottom ;if !ctx .Inline {ctx .X =_aaadc .X ;ctx .Width =_aaadc .Width ;};return _cege ,ctx ,nil ;};return _cege ,_aaadc ,nil ;
};

// SetLineColor sets the line color.
func (_fdfa *Polyline )SetLineColor (color Color ){_fdfa ._dfgf .LineColor =_gdfa (color )};

// Height returns the current page height.
func (_cfg *Creator )Height ()float64 {return _cfg ._bbdg };func (_bfea *templateProcessor )nodeLogDebug (_egef *templateNode ,_gfdcc string ,_gfgfa ...interface{}){_eef .Log .Debug (_bfea .getNodeErrorLocation (_egef ,_gfdcc ,_gfgfa ...));};func (_gccf *templateProcessor )parseParagraph (_fcbd *templateNode ,_edgdc *Paragraph )(interface{},error ){if _edgdc ==nil {_edgdc =_gccf .creator .NewParagraph ("");
};for _ ,_bdbge :=range _fcbd ._facfb .Attr {_cfbgg :=_bdbge .Value ;switch _eegg :=_bdbge .Name .Local ;_eegg {case "\u0066\u006f\u006e\u0074":_edgdc .SetFont (_gccf .parseFontAttr (_eegg ,_cfbgg ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_edgdc .SetFontSize (_gccf .parseFloatAttr (_eegg ,_cfbgg ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_edgdc .SetTextAlignment (_gccf .parseTextAlignmentAttr (_eegg ,_cfbgg ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_edgdc .SetLineHeight (_gccf .parseFloatAttr (_eegg ,_cfbgg ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_edgdc .SetEnableWrap (_gccf .parseBoolAttr (_eegg ,_cfbgg ));case "\u0063\u006f\u006co\u0072":_edgdc .SetColor (_gccf .parseColorAttr (_eegg ,_cfbgg ));case "\u0078":_edgdc .SetPos (_gccf .parseFloatAttr (_eegg ,_cfbgg ),_edgdc ._ffdcg );
case "\u0079":_edgdc .SetPos (_edgdc ._ggde ,_gccf .parseFloatAttr (_eegg ,_cfbgg ));case "\u0061\u006e\u0067l\u0065":_edgdc .SetAngle (_gccf .parseFloatAttr (_eegg ,_cfbgg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dfad :=_gccf .parseMarginAttr (_eegg ,_cfbgg );
_edgdc .SetMargins (_dfad .Left ,_dfad .Right ,_dfad .Top ,_dfad .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_edgdc .SetMaxLines (int (_gccf .parseInt64Attr (_eegg ,_cfbgg )));default:_gccf .nodeLogDebug (_fcbd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_eegg );
};};return _edgdc ,nil ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// Write output of creator to io.Writer interface.
func (_dage *Creator )Write (ws _dfd .Writer )error {if _ddgd :=_dage .Finalize ();_ddgd !=nil {return _ddgd ;};_eadcg :=_fa .NewPdfWriter ();_eadcg .SetOptimizer (_dage ._effb );if _dage ._adea !=nil {_afaf :=_eadcg .SetForms (_dage ._adea );if _afaf !=nil {_eef .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_afaf );
return _afaf ;};};if _dage ._abfe !=nil {_eadcg .AddOutlineTree (_dage ._abfe );}else if _dage ._ffgcf !=nil &&_dage .AddOutlines {_eadcg .AddOutlineTree (&_dage ._ffgcf .ToPdfOutline ().PdfOutlineTreeNode );};if _dage ._aded !=nil {if _cdaa :=_eadcg .SetPageLabels (_dage ._aded );
_cdaa !=nil {_eef .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_cdaa );return _cdaa ;};};if _dage ._gfc !=nil {for _ ,_ebb :=range _dage ._gfc {_ggda :=_ebb .SubsetRegistered ();
if _ggda !=nil {_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_ggda );return _ggda ;};};};if _dage ._gbgd !=nil {_cfab :=_dage ._gbgd (&_eadcg );
if _cfab !=nil {_eef .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cfab );return _cfab ;};};for _ ,_dgae :=range _dage ._ccgg {_fbgd :=_eadcg .AddPage (_dgae );if _fbgd !=nil {_eef .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_fbgd );
return _fbgd ;};};_ccbe :=_eadcg .Write (ws );if _ccbe !=nil {return _ccbe ;};return nil ;};

// SetBorderColor sets the border color.
func (_adeg *CurvePolygon )SetBorderColor (color Color ){_adeg ._dbag .BorderColor =_gdfa (color )};

// SetBorder sets the cell's border style.
func (_fecb *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_fecb ._cbbdb =CellBorderStyleSingle ;_fecb ._fceg =width ;_fecb ._fafdb =CellBorderStyleSingle ;
_fecb ._gegf =width ;_fecb ._fbcg =CellBorderStyleSingle ;_fecb ._bebbd =width ;_fecb ._deaff =CellBorderStyleSingle ;_fecb ._faeaf =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_fecb ._cbbdb =CellBorderStyleDouble ;_fecb ._fceg =width ;
_fecb ._fafdb =CellBorderStyleDouble ;_fecb ._gegf =width ;_fecb ._fbcg =CellBorderStyleDouble ;_fecb ._bebbd =width ;_fecb ._deaff =CellBorderStyleDouble ;_fecb ._faeaf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_fecb ._cbbdb =style ;
_fecb ._fceg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_fecb ._fafdb =style ;_fecb ._gegf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_fecb ._fbcg =style ;
_fecb ._bebbd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_fecb ._deaff =style ;_fecb ._faeaf =width ;};};

// Notes returns the notes section of the invoice as a title-content pair.
func (_acae *Invoice )Notes ()(string ,string ){return _acae ._ebcg [0],_acae ._ebcg [1]};

// Scale scales the ellipse dimensions by the specified factors.
func (_ggdab *Ellipse )Scale (xFactor ,yFactor float64 ){_ggdab ._bgea =xFactor *_ggdab ._bgea ;_ggdab ._dceb =yFactor *_ggdab ._dceb ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_gcacg *Image )SetEncoder (encoder _ea .StreamEncoder ){_gcacg ._fbfd =encoder };

// AddLine appends a new line to the invoice line items table.
func (_faccc *Invoice )AddLine (values ...string )[]*InvoiceCell {_agac :=len (_faccc ._cgcg );var _febd []*InvoiceCell ;for _aeefge ,_gffc :=range values {_aaccd :=_faccc .newCell (_gffc ,_faccc ._cdab );if _aeefge < _agac {_aaccd .Alignment =_faccc ._cgcg [_aeefge ].Alignment ;
};_febd =append (_febd ,_aaccd );};_faccc ._cgec =append (_faccc ._cgec ,_febd );return _febd ;};var _gecc =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_cagcb },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_faaf :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_gcee :_bbed },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_decfe },"\u0074\u0061\u0062l\u0065":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_gdadab },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_faaf :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_gcee :_ddbgb },"\u006c\u0069\u006e\u0065":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_cbbafb },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_dggdf },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_faaeb },"\u0069\u006d\u0061g\u0065":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_gdaaa },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_caaff },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_faaf :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_cabda },"\u0063\u0068\u0061r\u0074":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_fbdd },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gcee :_gcgbc },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_faaf :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_gcee :_ebgcc },"\u006c\u0069\u0073\u0074":&templateTag {_faaf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_cggbe },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_faaf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_gcee :_dbdf },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_faaf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_gcee :_bdced }};


// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_gedc *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gedc ._faaba .Left ,_gedc ._faaba .Right ,_gedc ._faaba .Top ,_gedc ._faaba .Bottom ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_gabe *Invoice )TitleStyle ()TextStyle {return _gabe ._gbfbc };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_gac *Chapter )SetIncludeInTOC (includeInTOC bool ){_gac ._abee =includeInTOC };

// NewPolygon creates a new polygon.
func (_feb *Creator )NewPolygon (points [][]_ce .Point )*Polygon {return _feab (points )};

// SetFillColor sets the fill color.
func (_cabfb *PolyBezierCurve )SetFillColor (color Color ){_cabfb ._bafc =color ;_cabfb ._cadfg .FillColor =_gdfa (color );};

// RotatedSize returns the width and height of the rotated block.
func (_gaef *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cbd ,_gbg :=_decad (_gaef ._bc ,_gaef ._dec ,_gaef ._eb );return _cbd ,_gbg ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_afec *Division )Height ()float64 {var _gdcb float64 ;for _ ,_abdd :=range _afec ._cga {switch _cafg :=_abdd .(type ){case marginDrawable :_ ,_ ,_aaad ,_efbd :=_cafg .GetMargins ();_gdcb +=_cafg .Height ()+_aaad +_efbd ;default:_gdcb +=_cafg .Height ();
};};return _gdcb ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_agaf *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _agaf ._dfbf ,_agaf ._aeecg ,_agaf ._gagg ,_agaf ._cbaff ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_fadf *Creator )DrawTemplate (r _dfd .Reader ,data interface{},options *TemplateOptions )error {return _efccg (_fadf ,r ,data ,options ,_fadf );};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_dgbd *shading ;_defa *_fa .PdfRectangle ;_gfgaf float64 ;};

// Width returns the current page width.
func (_dbfe *Creator )Width ()float64 {return _dbfe ._ggfe };func _ggcb (_begc []byte )(*Image ,error ){_adae :=_ef .NewReader (_begc );_ddaed ,_deed :=_fa .ImageHandling .Read (_adae );if _deed !=nil {_eef .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_deed );
return nil ,_deed ;};return _aagg (_ddaed );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_adgb *Invoice )SetAddressHeadingStyle (style TextStyle ){_adgb ._cecc =style };

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_gafc *GraphicSVG )SetPos (x ,y float64 ){_gafc ._gacf =PositionAbsolute ;_gafc ._gfgc =x ;_gafc ._dffe =y ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gegbe *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _gegbe ._cgga [0],_gegbe ._cgga [1]};func (_dfce *List )ctxHeight (_gecd float64 )float64 {_gecd -=_dfce ._dcdc ;var _cbbd float64 ;for _ ,_adbb :=range _dfce ._fbeaf {_cbbd +=_adbb .ctxHeight (_gecd );
};return _cbbd ;};

// SetRowPosition sets cell row position.
func (_dgdfd *TableCell )SetRowPosition (row int ){_dgdfd ._cceef =row };

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// BorderColor returns the border color of the rectangle.
func (_dcfae *Rectangle )BorderColor ()Color {return _dcfae ._bada };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_gaffa *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbaae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_deda ,_ddgb :=_bbaae .setOpacity (_gaffa ._egff ,_gaffa ._dagfe );if _ddgb !=nil {return nil ,ctx ,_ddgb ;
};_beeg :=_gaffa ._cadfg ;_beeg .FillEnabled =_beeg .FillColor !=nil ;var (_fcbe =ctx .PageHeight ;_fcdd =_beeg .Curves ;_gfec =make ([]_ce .CubicBezierCurve ,0,len (_beeg .Curves )););_gdada :=_fa .PdfRectangle {};for _abbd :=range _beeg .Curves {_dfefc :=_fcdd [_abbd ];
_dfefc .P0 .Y =_fcbe -_dfefc .P0 .Y ;_dfefc .P1 .Y =_fcbe -_dfefc .P1 .Y ;_dfefc .P2 .Y =_fcbe -_dfefc .P2 .Y ;_dfefc .P3 .Y =_fcbe -_dfefc .P3 .Y ;_gfec =append (_gfec ,_dfefc );_adeac :=_dfefc .GetBounds ();if _abbd ==0{_gdada =_adeac ;}else {_gdada .Llx =_ec .Min (_gdada .Llx ,_adeac .Llx );
_gdada .Lly =_ec .Min (_gdada .Lly ,_adeac .Lly );_gdada .Urx =_ec .Max (_gdada .Urx ,_adeac .Urx );_gdada .Ury =_ec .Max (_gdada .Ury ,_adeac .Ury );};};_beeg .Curves =_gfec ;defer func (){_beeg .Curves =_fcdd }();if _beeg .FillEnabled {_gbggg :=_ddcd (_bbaae ,_gaffa ._cadfg .FillColor ,_gaffa ._bafc ,func ()Rectangle {return Rectangle {_dfbc :_gdada .Llx ,_gbfgg :_gdada .Lly ,_faaa :_gdada .Width (),_baag :_gdada .Height ()};
});if _gbggg !=nil {return nil ,ctx ,_gbggg ;};};_bfdbg ,_ ,_ddgb :=_beeg .Draw (_deda );if _ddgb !=nil {return nil ,ctx ,_ddgb ;};if _ddgb =_bbaae .addContentsByString (string (_bfdbg ));_ddgb !=nil {return nil ,ctx ,_ddgb ;};return []*Block {_bbaae },ctx ,nil ;
};type templateNode struct{_ccfeb interface{};_facfb _f .StartElement ;_bgba *templateNode ;_edcb int ;_gdbed int ;_fcagb int64 ;};func (_aef *Chapter )headingNumber ()string {var _deg string ;if _aef ._faea {if _aef ._fgb !=0{_deg =_a .Itoa (_aef ._fgb )+"\u002e";
};if _aef ._eda !=nil {_acdg :=_aef ._eda .headingNumber ();if _acdg !=""{_deg =_acdg +_deg ;};};};return _deg ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_gfea *Ellipse )ScaleToWidth (w float64 ){_caa :=_gfea ._dceb /_gfea ._bgea ;_gfea ._bgea =w ;_gfea ._dceb =w *_caa ;};func _defdc (_cfeg TextStyle )*StyledParagraph {return &StyledParagraph {_cfbcg :[]*TextChunk {},_aegbg :_cfeg ,_ggee :_dbgda (_cfeg .Font ),_gbcb :1.0,_dgbde :TextAlignmentLeft ,_dgba :true ,_gadge :true ,_ebgbe :false ,_cefe :0,_bagd :1,_agddd :1,_defc :PositionRelative };
};func (_afee *List )markerWidth ()float64 {var _bbbc float64 ;for _ ,_ebbg :=range _afee ._fbeaf {_abfg :=_defdc (_afee ._dbca );_abfg .SetEnableWrap (false );_abfg .SetTextAlignment (TextAlignmentRight );_abfg .Append (_ebbg ._dbea .Text ).Style =_ebbg ._dbea .Style ;
_cgfd :=_abfg .getTextWidth ()/1000.0;if _bbbc < _cgfd {_bbbc =_cgfd ;};};return _bbbc ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gaada *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_egfab ,_aegdg :=_gaada .Wrap (width );if _aegdg !=nil {return nil ,_aegdg ;};_ffec :=int (height /_gaada .Style .FontSize );if _ffec >=len (_egfab ){return nil ,nil ;};_bccb :="\u000a";
_gaada .Text =_dc .Replace (_dc .Join (_egfab [:_ffec ],"\u0020"),_bccb +"\u0020",_bccb ,-1);_bffbc :=_dc .Replace (_dc .Join (_egfab [_ffec :],"\u0020"),_bccb +"\u0020",_bccb ,-1);return NewTextChunk (_bffbc ,_gaada .Style ),nil ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_cgge :_ec .Max (_ec .Min (c ,1.0),0.0),_fbcb :_ec .Max (_ec .Min (m ,1.0),0.0),_abad :_ec .Max (_ec .Min (y ,1.0),0.0),_gdad :_ec .Max (_ec .Min (k ,1.0),0.0)};};func _dgaf (_eabfa float64 ,_cedc float64 )float64 {return _ec .Round (_eabfa /_cedc )*_cedc };


// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ceeaf *Invoice )InfoLines ()[][2]*InvoiceCell {_eacf :=[][2]*InvoiceCell {_ceeaf ._cgga ,_ceeaf ._bacd ,_ceeaf ._gdcc };return append (_eacf ,_ceeaf ._dgec ...);};

// NewInvoice returns an instance of an empty invoice.
func (_bcbaf *Creator )NewInvoice ()*Invoice {_ggfaa :=_bcbaf .NewTextStyle ();_ggfaa .Font =_bcbaf ._gaba ;return _ceef (_bcbaf .NewTextStyle (),_ggfaa );};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_eged :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_eef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eged ;
};var _fdb ,_bbbf ,_ecfa int ;if len (hexStr )==4{var _aea ,_aegg ,_fbag int ;_afg ,_gbgc :=_g .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_aea ,&_aegg ,&_fbag );if _gbgc !=nil {_eef .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_gbgc );
return _eged ;};if _afg !=3{_eef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eged ;};_fdb =_aea *16+_aea ;_bbbf =_aegg *16+_aegg ;_ecfa =_fbag *16+_fbag ;}else {_bfc ,_babf :=_g .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fdb ,&_bbbf ,&_ecfa );
if _babf !=nil {_eef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eged ;};if _bfc !=3{_eef .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bfc );
return _eged ;};};_ebca :=float64 (_fdb )/255.0;_ffga :=float64 (_bbbf )/255.0;_cfe :=float64 (_ecfa )/255.0;_eged ._abec =_ebca ;_eged ._eafb =_ffga ;_eged ._baa =_cfe ;return _eged ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_faae *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbbf :=_faae ;if _faae ._dbac {_dbbf =_faae .clone ();};return _fggg (_dbbf ,ctx );};func (_acbe *FilledCurve )draw (_bebbb *Block ,_dabac string )([]byte ,*_fa .PdfRectangle ,error ){_dbab :=_ce .NewCubicBezierPath ();
for _ ,_ebgg :=range _acbe ._edeb {_dbab =_dbab .AppendCurve (_ebgg );};creator :=_bd .NewContentCreator ();creator .Add_q ();if _acbe .FillEnabled &&_acbe ._dagdb !=nil {_dagf :=_gdfa (_acbe ._dagdb );_abeg :=_ddcd (_bebbb ,_dagf ,_acbe ._dagdb ,func ()Rectangle {_ffdc :=_ce .NewCubicBezierPath ();
for _ ,_baef :=range _acbe ._edeb {_ffdc =_ffdc .AppendCurve (_baef );};_gff :=_ffdc .GetBoundingBox ();if _acbe .BorderEnabled {_gff .Height +=_acbe .BorderWidth ;_gff .Width +=_acbe .BorderWidth ;_gff .X -=_acbe .BorderWidth /2;_gff .Y -=_acbe .BorderWidth /2;
};return Rectangle {_dfbc :_gff .X ,_gbfgg :_gff .Y ,_faaa :_gff .Width ,_baag :_gff .Height };});if _abeg !=nil {return nil ,nil ,_abeg ;};creator .SetNonStrokingColor (_dagf );};if _acbe .BorderEnabled {if _acbe ._baed !=nil {creator .SetStrokingColor (_gdfa (_acbe ._baed ));
};creator .Add_w (_acbe .BorderWidth );};if len (_dabac )> 1{creator .Add_gs (_ea .PdfObjectName (_dabac ));};_ce .DrawBezierPathWithCreator (_dbab ,creator );creator .Add_h ();if _acbe .FillEnabled &&_acbe .BorderEnabled {creator .Add_B ();}else if _acbe .FillEnabled {creator .Add_f ();
}else if _acbe .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_fag :=_dbab .GetBoundingBox ();if _acbe .BorderEnabled {_fag .Height +=_acbe .BorderWidth ;_fag .Width +=_acbe .BorderWidth ;_fag .X -=_acbe .BorderWidth /2;_fag .Y -=_acbe .BorderWidth /2;
};_eaeg :=&_fa .PdfRectangle {};_eaeg .Llx =_fag .X ;_eaeg .Lly =_fag .Y ;_eaeg .Urx =_fag .X +_fag .Width ;_eaeg .Ury =_fag .Y +_fag .Height ;return creator .Bytes (),_eaeg ,nil ;};func _cgege ()*listItem {return &listItem {}};func _cecg ()*Division {return &Division {_gfbg :true }};


// SetText sets the text content of the Paragraph.
func (_dgbf *Paragraph )SetText (text string ){_dgbf ._babfa =text };

// Scale block by specified factors in the x and y directions.
func (_fg *Block )Scale (sx ,sy float64 ){_fgf :=_bd .NewContentCreator ().Scale (sx ,sy ).Operations ();*_fg ._ffc =append (*_fgf ,*_fg ._ffc ...);_fg ._ffc .WrapIfNeeded ();_fg ._bc *=sx ;_fg ._dec *=sy ;};func _decad (_abcaa ,_befad ,_fgcbf float64 )(_cbce ,_feeaf ,_edfb ,_eacdc float64 ){if _fgcbf ==0{return 0,0,_abcaa ,_befad ;
};_bgcfb :=_ce .Path {Points :[]_ce .Point {_ce .NewPoint (0,0).Rotate (_fgcbf ),_ce .NewPoint (_abcaa ,0).Rotate (_fgcbf ),_ce .NewPoint (0,_befad ).Rotate (_fgcbf ),_ce .NewPoint (_abcaa ,_befad ).Rotate (_fgcbf )}}.GetBoundingBox ();return _bgcfb .X ,_bgcfb .Y ,_bgcfb .Width ,_bgcfb .Height ;
};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_geafb *Table )MultiRowCell (rowspan int )*TableCell {return _geafb .MultiCell (rowspan ,1)};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_eaf *Block )AddAnnotation (annotation *_fa .PdfAnnotation ){for _ ,_ge :=range _eaf ._cc {if _ge ==annotation {return ;};};_eaf ._cc =append (_eaf ._cc ,annotation );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_dbbd *Creator )PageFinalize (pageFinalizeFunc func (_effc PageFinalizeFunctionArgs )error ){_dbbd ._geab =pageFinalizeFunc ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cdcad *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _cdcad ._bacd [0],_cdcad ._bacd [1]};

// SetInline sets the inline mode of the division.
func (_fcge *Division )SetInline (inline bool ){_fcge ._dacf =inline };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_gfbfg *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_gfbfg .Text },nil ;};var _aeee []string ;var _gaeaa []rune ;var _fdcef float64 ;var _fcgbg []float64 ;_dacbac :=_gfbfg .Style ;_feda :=_bfed (_gfbfg .Text );
for _ ,_fabd :=range _gfbfg .Text {if _fabd =='\u000A'{_dafg :=_ecdag (string (_gaeaa ),_feda );_aeee =append (_aeee ,_dc .TrimRightFunc (_dafg ,_efe .IsSpace )+string (_fabd ));_gaeaa =nil ;_fdcef =0;_fcgbg =nil ;continue ;};_eacb :=_fabd ==' ';_agdcb ,_bbccd :=_dacbac .Font .GetRuneMetrics (_fabd );
if !_bbccd {_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_fabd ,_fabd ,_dacbac .Font .BaseFont (),_dacbac .Font .Subtype ());
_eef .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dacbac .Font );_eef .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dacbac .Font .Encoder ());return nil ,_e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_addcd :=_dacbac .FontSize *_agdcb .Wx ;_bdgeg :=_addcd ;if !_eacb {_bdgeg =_addcd +_dacbac .CharSpacing *1000.0;};if _fdcef +_addcd > width *1000.0{_fgbe :=-1;if !_eacb {for _eefaa :=len (_gaeaa )-1;_eefaa >=0;_eefaa --{if _gaeaa [_eefaa ]==' '{_fgbe =_eefaa ;
break ;};};};_affgfd :=string (_gaeaa );if _fgbe > 0{_affgfd =string (_gaeaa [0:_fgbe +1]);_gaeaa =append (_gaeaa [_fgbe +1:],_fabd );_fcgbg =append (_fcgbg [_fgbe +1:],_bdgeg );_fdcef =0;for _ ,_eeagd :=range _fcgbg {_fdcef +=_eeagd ;};}else {if _eacb {_gaeaa =[]rune {};
_fcgbg =[]float64 {};_fdcef =0;}else {_gaeaa =[]rune {_fabd };_fcgbg =[]float64 {_bdgeg };_fdcef =_bdgeg ;};};_affgfd =_ecdag (_affgfd ,_feda );_aeee =append (_aeee ,_dc .TrimRightFunc (_affgfd ,_efe .IsSpace ));}else {_gaeaa =append (_gaeaa ,_fabd );_fdcef +=_bdgeg ;
_fcgbg =append (_fcgbg ,_bdgeg );};};if len (_gaeaa )> 0{_gafa :=string (_gaeaa );_gafa =_ecdag (_gafa ,_feda );_aeee =append (_aeee ,_gafa );};return _aeee ,nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_bea *Chapter )NewSubchapter (title string )*Chapter {_ced :=_ggbe (_bea ._abd ._gcedf );_ced .FontSize =14;_bea ._cdcc ++;_cagc :=_bdbc (_bea ,_bea ._gdaf ,_bea ._eaa ,title ,_bea ._cdcc ,_ced );_bea .Add (_cagc );return _cagc ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func _gdfa (_gfbf Color )_fa .PdfColor {if _gfbf ==nil {_gfbf =ColorBlack ;};switch _bcba :=_gfbf .(type ){case cmykColor :return _fa .NewPdfColorDeviceCMYK (_bcba ._cgge ,_bcba ._fbcb ,_bcba ._abad ,_bcba ._gdad );case *LinearShading :return _fa .NewPdfColorPatternType2 ();
case *RadialShading :return _fa .NewPdfColorPatternType3 ();};return _fa .NewPdfColorDeviceRGB (_gfbf .ToRGB ());};func (_gefdb *Invoice )drawAddress (_affc *InvoiceAddress )[]*StyledParagraph {var _egedb []*StyledParagraph ;if _affc .Heading !=""{_bgeg :=_defdc (_gefdb ._cecc );
_bgeg .SetMargins (0,0,0,7);_bgeg .Append (_affc .Heading );_egedb =append (_egedb ,_bgeg );};_ccee :=_defdc (_gefdb ._gbgdd );_ccee .SetLineHeight (1.2);_gbcd :=_affc .Separator ;if _gbcd ==""{_gbcd =_gefdb ._edec ;};_gaag :=_affc .City ;if _affc .State !=""{if _gaag !=""{_gaag +=_gbcd ;
};_gaag +=_affc .State ;};if _affc .Zip !=""{if _gaag !=""{_gaag +=_gbcd ;};_gaag +=_affc .Zip ;};if _affc .Name !=""{_ccee .Append (_affc .Name +"\u000a");};if _affc .Street !=""{_ccee .Append (_affc .Street +"\u000a");};if _affc .Street2 !=""{_ccee .Append (_affc .Street2 +"\u000a");
};if _gaag !=""{_ccee .Append (_gaag +"\u000a");};if _affc .Country !=""{_ccee .Append (_affc .Country +"\u000a");};_gcdd :=_defdc (_gefdb ._gbgdd );_gcdd .SetLineHeight (1.2);_gcdd .SetMargins (0,0,7,0);if _affc .Phone !=""{_gcdd .Append (_affc .fmtLine (_affc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_affc .HidePhoneLabel ));
};if _affc .Email !=""{_gcdd .Append (_affc .fmtLine (_affc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_affc .HideEmailLabel ));};_egedb =append (_egedb ,_ccee ,_gcdd );return _egedb ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_bcgg *Image )ScaleToWidth (w float64 ){_bfff :=_bcgg ._ffab /_bcgg ._gfef ;_bcgg ._gfef =w ;_bcgg ._ffab =w *_bfff ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_dcdab *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_effcc ,_ ,_daff :=_dcdab .draw (_cfcb ,"");if _daff !=nil {return nil ,ctx ,_daff ;};_daff =_cfcb .addContentsByString (string (_effcc ));
if _daff !=nil {return nil ,ctx ,_daff ;};return []*Block {_cfcb },ctx ,nil ;};

// Height returns the height of the list.
func (_eabe *List )Height ()float64 {var _bgbf float64 ;for _ ,_becf :=range _eabe ._fbeaf {_bgbf +=_becf .ctxHeight (_eabe .Width ());};return _bgbf ;};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_abggg *Rectangle )SetBorderOpacity (opacity float64 ){_abggg ._gacec =opacity };func _fbdd (_gegba *templateProcessor ,_efdff *templateNode )(interface{},error ){return _gegba .parseChart (_efdff );};func (_fbggc *templateProcessor )parseFloatAttr (_fgced ,_cgcfd string )float64 {_eef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fgced ,_cgcfd );
_fcbf ,_ :=_a .ParseFloat (_cgcfd ,64);return _fcbf ;};func (_bdecb *templateProcessor )addNodeText (_aebfbc *templateNode ,_dbggf string )error {_bgab :=_aebfbc ._ccfeb ;if _bgab ==nil {return nil ;};switch _acag :=_bgab .(type ){case *TextChunk :_acag .Text =_dbggf ;
case *Paragraph :switch _aebfbc ._facfb .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _aebfbc ._bgba !=nil {if _cagae ,_acec :=_aebfbc ._bgba ._ccfeb .(*Chapter );_acec {_cagae ._ebfe =_dbggf ;
_acag .SetText (_cagae .headingText ());};};default:_acag .SetText (_dbggf );};};return nil ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_dacba *Chapter )Add (d Drawable )error {if Drawable (_dacba )==d {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cdca :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_dacba ._cdde =append (_dacba ._cdde ,d );case containerDrawable :_ffa ,_cggc :=_cdca .ContainerComponent (_dacba );
if _cggc !=nil {return _cggc ;};_dacba ._cdde =append (_dacba ._cdde ,_ffa );default:_eef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_eabb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _eabb ._gege };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// NewDivision returns a new Division container component.
func (_fbcee *Creator )NewDivision ()*Division {return _cecg ()};func _feaaf (_faaea *_fa .PdfAnnotationLink )*_fa .PdfAnnotationLink {if _faaea ==nil {return nil ;};_cedfa :=_fa .NewPdfAnnotationLink ();_cedfa .BS =_faaea .BS ;_cedfa .A =_faaea .A ;if _fdgfb ,_fggea :=_faaea .GetAction ();
_fggea ==nil &&_fdgfb !=nil {_cedfa .SetAction (_fdgfb );};if _adbdg ,_cecb :=_faaea .Dest .(*_ea .PdfObjectArray );_cecb {_cedfa .Dest =_ea .MakeArray (_adbdg .Elements ()...);};return _cedfa ;};

// SkipRows skips over a specified number of rows in the table.
func (_fgda *Table )SkipRows (num int ){_dbgc :=num *_fgda ._beege -1;if _dbgc < 0{_eef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _aeaee :=0;_aeaee < _dbgc ;_aeaee ++{_fgda .NewCell ();};};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_beg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _beg ._dee .Left ,_beg ._dee .Right ,_beg ._dee .Top ,_beg ._dee .Bottom ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bbdc *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bbdc ._eead .Left ,_bbdc ._eead .Right ,_bbdc ._eead .Top ,_bbdc ._eead .Bottom ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_efagf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgdcbc :=ctx ;_acecd ,ctx ,_gaffe :=_efagf ._bagf .GeneratePageBlocks (ctx );if _gaffe !=nil {return _acecd ,ctx ,_gaffe ;};if _efagf ._ecfb .IsRelative (){ctx .X =_dgdcbc .X ;
};if _efagf ._ecfb .IsAbsolute (){return _acecd ,_dgdcbc ,nil ;};return _acecd ,ctx ,nil ;};

// SetMargins sets the margins of the chart component.
func (_ebfb *Chart )SetMargins (left ,right ,top ,bottom float64 ){_ebfb ._ebga .Left =left ;_ebfb ._ebga .Right =right ;_ebfb ._ebga .Top =top ;_ebfb ._ebga .Bottom =bottom ;};func (_gbbb *templateProcessor )parsePageBreak (_fbega *templateNode )(interface{},error ){return _ddge (),nil ;
};func _ddge ()*PageBreak {return &PageBreak {}};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_efbb *Creator )NewParagraph (text string )*Paragraph {return _gacc (text ,_efbb .NewTextStyle ())};func (_eegec *templateProcessor )parseStyledParagraph (_cggcf *templateNode )(interface{},error ){_dafb :=_eegec .creator .NewStyledParagraph ();for _ ,_cbaeg :=range _cggcf ._facfb .Attr {_cbecb :=_cbaeg .Value ;
switch _dfgfc :=_cbaeg .Name .Local ;_dfgfc {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dafb .SetTextAlignment (_eegec .parseTextAlignmentAttr (_dfgfc ,_cbecb ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dafb .SetTextVerticalAlignment (_eegec .parseTextVerticalAlignmentAttr (_dfgfc ,_cbecb ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_dafb .SetLineHeight (_eegec .parseFloatAttr (_dfgfc ,_cbecb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cebg :=_eegec .parseMarginAttr (_dfgfc ,_cbecb );_dafb .SetMargins (_cebg .Left ,_cebg .Right ,_cebg .Top ,_cebg .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_dafb .SetEnableWrap (_eegec .parseBoolAttr (_dfgfc ,_cbecb ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_dafb .EnableWordWrap (_eegec .parseBoolAttr (_dfgfc ,_cbecb ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_dafb .SetTextOverflow (_eegec .parseTextOverflowAttr (_dfgfc ,_cbecb ));case "\u0078":_dafb .SetPos (_eegec .parseFloatAttr (_dfgfc ,_cbecb ),_dafb ._cgcgca );case "\u0079":_dafb .SetPos (_dafb ._gbdbe ,_eegec .parseFloatAttr (_dfgfc ,_cbecb ));
case "\u0061\u006e\u0067l\u0065":_dafb .SetAngle (_eegec .parseFloatAttr (_dfgfc ,_cbecb ));default:_eegec .nodeLogDebug (_cggcf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dfgfc );
};};return _dafb ,nil ;};

// BorderWidth returns the border width of the ellipse.
func (_fgcd *Ellipse )BorderWidth ()float64 {return _fgcd ._cadd };

// SetColorBottom sets border color for bottom.
func (_cfc *border )SetColorBottom (col Color ){_cfc ._ada =col };

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_dfbde *Line )SetMargins (left ,right ,top ,bottom float64 ){_dfbde ._dcdb .Left =left ;_dfbde ._dcdb .Right =right ;_dfbde ._dcdb .Top =top ;_dfbde ._dcdb .Bottom =bottom ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_bfag *Invoice )SetNoteStyle (style TextStyle ){_bfag ._bgeac =style };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_cfd float64 ;_cdbb float64 ;_bcga float64 ;_affa float64 ;_bcca float64 ;_acdbc float64 ;_adfb Color ;_geeb float64 ;};func (_cffg *templateProcessor )parseEllipse (_bdcfe *templateNode )(interface{},error ){_fcff :=_cffg .creator .NewEllipse (0,0,0,0);
for _ ,_cagf :=range _bdcfe ._facfb .Attr {_dbgd :=_cagf .Value ;switch _degbe :=_cagf .Name .Local ;_degbe {case "\u0063\u0078":_fcff ._fgcb =_cffg .parseFloatAttr (_degbe ,_dbgd );case "\u0063\u0079":_fcff ._eadb =_cffg .parseFloatAttr (_degbe ,_dbgd );
case "\u0077\u0069\u0064t\u0068":_fcff .SetWidth (_cffg .parseFloatAttr (_degbe ,_dbgd ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fcff .SetHeight (_cffg .parseFloatAttr (_degbe ,_dbgd ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_fcff .SetFillColor (_cffg .parseColorAttr (_degbe ,_dbgd ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_fcff .SetFillOpacity (_cffg .parseFloatAttr (_degbe ,_dbgd ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fcff .SetBorderColor (_cffg .parseColorAttr (_degbe ,_dbgd ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_fcff .SetBorderOpacity (_cffg .parseFloatAttr (_degbe ,_dbgd ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_fcff .SetBorderWidth (_cffg .parseFloatAttr (_degbe ,_dbgd ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fcff .SetPositioning (_cffg .parsePositioningAttr (_degbe ,_dbgd ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fcff .SetFitMode (_cffg .parseFitModeAttr (_degbe ,_dbgd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbefc :=_cffg .parseMarginAttr (_degbe ,_dbgd );
_fcff .SetMargins (_bbefc .Left ,_bbefc .Right ,_bbefc .Top ,_bbefc .Bottom );default:_cffg .nodeLogDebug (_bdcfe ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_degbe );
};};return _fcff ,nil ;};type rgbColor struct{_abec ,_eafb ,_baa float64 };func _fggg (_gbbf *Table ,_eagd DrawContext )([]*Block ,DrawContext ,error ){var _efbcd []*Block ;_agadf :=NewBlock (_eagd .PageWidth ,_eagd .PageHeight );_gbbf .updateRowHeights (_eagd .Width -_gbbf ._fefca .Left -_gbbf ._fefca .Right );
_ebae :=_gbbf ._fefca .Top ;if _gbbf ._dbgb .IsRelative ()&&!_gbbf ._cbca {_aabc :=_gbbf .Height ();if _aabc > _eagd .Height -_gbbf ._fefca .Top &&_aabc <=_eagd .PageHeight -_eagd .Margins .Top -_eagd .Margins .Bottom {_efbcd =[]*Block {NewBlock (_eagd .PageWidth ,_eagd .PageHeight -_eagd .Y )};
var _cfgg error ;if _ ,_eagd ,_cfgg =_ddge ().GeneratePageBlocks (_eagd );_cfgg !=nil {return nil ,_eagd ,_cfgg ;};_ebae =0;};};_cebea :=_eagd ;if _gbbf ._dbgb .IsAbsolute (){_eagd .X =_gbbf ._dcbdd ;_eagd .Y =_gbbf ._dfdc ;}else {_eagd .X +=_gbbf ._fefca .Left ;
_eagd .Y +=_ebae ;_eagd .Width -=_gbbf ._fefca .Left +_gbbf ._fefca .Right ;_eagd .Height -=_ebae ;};_gbebd :=_eagd .Width ;_faffc :=_eagd .X ;_fgce :=_eagd .Y ;_bcdaf :=_eagd .Height ;_bafcf :=0;_cddef ,_aegbc :=-1,-1;if _gbbf ._acgfbd {for _bcdg ,_cdbab :=range _gbbf ._bdfef {if _cdbab ._cceef < _gbbf ._adaae {continue ;
};if _cdbab ._cceef > _gbbf ._begg {break ;};if _cddef < 0{_cddef =_bcdg ;};_aegbc =_bcdg ;};};if _eggd :=_gbbf .wrapContent (_eagd );_eggd !=nil {return nil ,_eagd ,_eggd ;};_gbbf .updateRowHeights (_eagd .Width -_gbbf ._fefca .Left -_gbbf ._fefca .Right );
var (_ddeaf bool ;_cfec int ;_fedcb int ;_dgaa bool ;_aefc int ;_dbcbd error ;);for _acgc :=0;_acgc < len (_gbbf ._bdfef );_acgc ++{_efged :=_gbbf ._bdfef [_acgc ];if _cbfbf ,_bgebbd :=_gbbf .getLastCellFromCol (_efged ._baceb );_cbfbf ==_acgc {if (_bgebbd ._cceef +_bgebbd ._badd -1)< _gbbf ._cccb {for _eggdb :=_efged ._cceef ;
_eggdb < _gbbf ._cccb ;_eggdb ++{_eddc :=&TableCell {};_eddc ._cceef =_eggdb +1;_eddc ._badd =1;_eddc ._baceb =_efged ._baceb ;_gbbf ._bdfef =append (_gbbf ._bdfef ,_eddc );};};};_fbcbd :=_efged .width (_gbbf ._gaecf ,_gbebd );_cfbafb :=float64 (0.0);for _gbge :=0;
_gbge < _efged ._baceb -1;_gbge ++{_cfbafb +=_gbbf ._gaecf [_gbge ]*_gbebd ;};_dfbff :=float64 (0.0);for _abbc :=_bafcf ;_abbc < _efged ._cceef -1;_abbc ++{_dfbff +=_gbbf ._cddcg [_abbc ];};_eagd .Height =_bcdaf -_dfbff ;_bdge :=float64 (0.0);for _gefcc :=0;
_gefcc < _efged ._badd ;_gefcc ++{_bdge +=_gbbf ._cddcg [_efged ._cceef +_gefcc -1];};_cefeb :=_dgaa &&_efged ._cceef !=_aefc ;_aefc =_efged ._cceef ;if _cefeb ||_bdge > _eagd .Height {if _gbbf ._dbac &&!_dgaa {_dgaa ,_dbcbd =_gbbf .wrapRow (_acgc ,_eagd ,_gbebd );
if _dbcbd !=nil {return nil ,_eagd ,_dbcbd ;};if _dgaa {_acgc --;continue ;};_cefeb =true ;};_efbcd =append (_efbcd ,_agadf );_agadf =NewBlock (_eagd .PageWidth ,_eagd .PageHeight );_faffc =_eagd .Margins .Left +_gbbf ._fefca .Left ;_fgce =_eagd .Margins .Top ;
_eagd .Height =_eagd .PageHeight -_eagd .Margins .Top -_eagd .Margins .Bottom ;_eagd .Page ++;_bcdaf =_eagd .Height ;_bafcf =_efged ._cceef -1;_dfbff =0;_dgaa =false ;if _gbbf ._acgfbd &&_cddef >=0{_cfec =_acgc ;_acgc =_cddef -1;_fedcb =_bafcf ;_bafcf =_gbbf ._adaae -1;
_ddeaf =true ;if _efged ._badd > (_gbbf ._cccb -_aefc )||(_efged ._badd > 1&&_acgc < 0){_eef .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_ddeaf =false ;_cddef ,_aegbc =-1,-1;};continue ;};if _cefeb {_acgc --;continue ;};};_eagd .Width =_fbcbd ;_eagd .X =_faffc +_cfbafb ;_eagd .Y =_fgce +_dfbff ;_febdb :=_edd (_eagd .X ,_eagd .Y ,_fbcbd ,_bdge );if _efged ._cbacb !=nil {_febdb .SetFillColor (_efged ._cbacb );
};_febdb .LineStyle =_efged ._gegge ;_febdb ._dcda =_efged ._cbbdb ;_febdb ._adg =_efged ._fbcg ;_febdb ._bdd =_efged ._deaff ;_febdb ._befg =_efged ._fafdb ;if _efged ._cgce !=nil {_febdb .SetColorLeft (_efged ._cgce );};if _efged ._cfaea !=nil {_febdb .SetColorBottom (_efged ._cfaea );
};if _efged ._egddb !=nil {_febdb .SetColorRight (_efged ._egddb );};if _efged ._bbcfdd !=nil {_febdb .SetColorTop (_efged ._bbcfdd );};_febdb .SetWidthBottom (_efged ._gegf );_febdb .SetWidthLeft (_efged ._fceg );_febdb .SetWidthRight (_efged ._bebbd );
_febdb .SetWidthTop (_efged ._faeaf );_ggacb :=_agadf .Draw (_febdb );if _ggacb !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ggacb );};if _efged ._cead !=nil {_dfabe :=_efged ._cead .Width ();_egcfc :=_efged ._cead .Height ();
_fcfc :=0.0;switch _edgaa :=_efged ._cead .(type ){case *Paragraph :if _edgaa ._fade {_dfabe =_edgaa .getMaxLineWidth ()/1000.0;};_dfabe +=_edgaa ._fbba .Left +_edgaa ._fbba .Right ;_egcfc +=_edgaa ._fbba .Top +_edgaa ._fbba .Bottom ;case *StyledParagraph :if _edgaa ._dgba {_dfabe =_edgaa .getMaxLineWidth ()/1000.0;
};_aedb ,_caggb ,_cdgff :=_edgaa .getLineMetrics (0);_bddg ,_fcde :=_aedb *_edgaa ._gbcb ,_caggb *_edgaa ._gbcb ;if _edgaa ._ggdf ==TextVerticalAlignmentCenter {_fcfc =_fcde -(_caggb +(_aedb +_cdgff -_caggb )/2+(_fcde -_caggb )/2);};if len (_edgaa ._egffa )==1{_egcfc =_bddg ;
}else {_egcfc =_egcfc -_fcde +_bddg ;};_fcfc +=_bddg -_fcde ;switch _efged ._ecbg {case CellVerticalAlignmentTop :_fcfc +=_bddg *0.5;case CellVerticalAlignmentBottom :_fcfc -=_bddg *0.5;};_dfabe +=_edgaa ._faaba .Left +_edgaa ._faaba .Right ;_egcfc +=_edgaa ._faaba .Top +_edgaa ._faaba .Bottom ;
case *Table :_dfabe =_fbcbd ;case *List :_dfabe =_fbcbd ;case *Division :_dfabe =_fbcbd ;case *Chart :_dfabe =_fbcbd ;case *Line :_egcfc +=_edgaa ._dcdb .Top +_edgaa ._dcdb .Bottom ;_fcfc -=_edgaa .Height ()/2;case *Image :_dfabe +=_edgaa ._gbba .Left +_edgaa ._gbba .Right ;
_egcfc +=_edgaa ._gbba .Top +_edgaa ._gbba .Bottom ;};switch _efged ._dedb {case CellHorizontalAlignmentLeft :_eagd .X +=_efged ._ddbeg ;_eagd .Width -=_efged ._ddbeg ;case CellHorizontalAlignmentCenter :if _bgbc :=_fbcbd -_dfabe ;_bgbc > 0{_eagd .X +=_bgbc /2;
_eagd .Width -=_bgbc /2;};case CellHorizontalAlignmentRight :if _fbcbd > _dfabe {_eagd .X =_eagd .X +_fbcbd -_dfabe -_efged ._ddbeg ;_eagd .Width -=_efged ._ddbeg ;};};_aeaec :=_eagd .Y ;_daebb :=_eagd .Height ;_eagd .Y +=_fcfc ;switch _efged ._ecbg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gffa :=_bdge -_egcfc ;
_gffa > 0{_eagd .Y +=_gffa /2;_eagd .Height -=_gffa /2;};case CellVerticalAlignmentBottom :if _bdge > _egcfc {_eagd .Y =_eagd .Y +_bdge -_egcfc ;_eagd .Height =_bdge ;};};_cdeb :=_agadf .DrawWithContext (_efged ._cead ,_eagd );if _cdeb !=nil {_eef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cdeb );
};_eagd .Y =_aeaec ;_eagd .Height =_daebb ;};_eagd .Y +=_bdge ;_eagd .Height -=_bdge ;if _ddeaf &&_acgc +1> _aegbc {_fgce +=_dfbff +_bdge ;_bcdaf -=_bdge +_dfbff ;_bafcf =_fedcb ;_acgc =_cfec -1;_ddeaf =false ;};};_efbcd =append (_efbcd ,_agadf );if _gbbf ._dbgb .IsAbsolute (){return _efbcd ,_cebea ,nil ;
};_eagd .X =_cebea .X ;_eagd .Width =_cebea .Width ;_eagd .Y +=_gbbf ._fefca .Bottom ;_eagd .Height -=_gbbf ._fefca .Bottom ;return _efbcd ,_eagd ,nil ;};func _cbbafb (_aeda *templateProcessor ,_gedcc *templateNode )(interface{},error ){return _aeda .parseLine (_gedcc );
};

// SetMargins sets the margins of the graphic svg component.
func (_bcfbf *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_bcfbf ._eefa .Left =left ;_bcfbf ._eefa .Right =right ;_bcfbf ._eefa .Top =top ;_bcfbf ._eefa .Bottom =bottom ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ffca *Invoice )AddressStyle ()TextStyle {return _ffca ._gbgdd };func (_bdaa *templateProcessor )parseLine (_abaea *templateNode )(interface{},error ){_gcdcc :=_bdaa .creator .NewLine (0,0,0,0);for _ ,_agce :=range _abaea ._facfb .Attr {_ggacef :=_agce .Value ;
switch _begd :=_agce .Name .Local ;_begd {case "\u0078\u0031":_gcdcc ._dfbf =_bdaa .parseFloatAttr (_begd ,_ggacef );case "\u0079\u0031":_gcdcc ._aeecg =_bdaa .parseFloatAttr (_begd ,_ggacef );case "\u0078\u0032":_gcdcc ._gagg =_bdaa .parseFloatAttr (_begd ,_ggacef );
case "\u0079\u0032":_gcdcc ._cbaff =_bdaa .parseFloatAttr (_begd ,_ggacef );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_gcdcc .SetLineWidth (_bdaa .parseFloatAttr (_begd ,_ggacef ));case "\u0063\u006f\u006co\u0072":_gcdcc .SetColor (_bdaa .parseColorAttr (_begd ,_ggacef ));
case "\u0073\u0074\u0079l\u0065":_gcdcc .SetStyle (_bdaa .parseLineStyleAttr (_begd ,_ggacef ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_gcdcc .SetDashPattern (_bdaa .parseInt64Array (_begd ,_ggacef ),_gcdcc ._gfee );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_gcdcc .SetDashPattern (_gcdcc ._efgeg ,_bdaa .parseInt64Attr (_begd ,_ggacef ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_gcdcc .SetOpacity (_bdaa .parseFloatAttr (_begd ,_ggacef ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gcdcc .SetPositioning (_bdaa .parsePositioningAttr (_begd ,_ggacef ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gcdcc .SetFitMode (_bdaa .parseFitModeAttr (_begd ,_ggacef ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fddaa :=_bdaa .parseMarginAttr (_begd ,_ggacef );_gcdcc .SetMargins (_fddaa .Left ,_fddaa .Right ,_fddaa .Top ,_fddaa .Bottom );default:_bdaa .nodeLogDebug (_abaea ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_begd );
};};return _gcdcc ,nil ;};

// SetAngle sets the rotation angle in degrees.
func (_efb *Block )SetAngle (angleDeg float64 ){_efb ._eb =angleDeg };

// WriteToFile writes the Creator output to file specified by path.
func (_ccfb *Creator )WriteToFile (outputPath string )error {_dbge ,_gbdb :=_df .Create (outputPath );if _gbdb !=nil {return _gbdb ;};defer _dbge .Close ();return _ccfb .Write (_dbge );};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_eaae *Division )SetPadding (left ,right ,top ,bottom float64 ){_eaae ._dgfg .Left =left ;_eaae ._dgfg .Right =right ;_eaae ._dgfg .Top =top ;_eaae ._dgfg .Bottom =bottom ;};func (_fecf *TemplateOptions )init (){if _fecf .SubtemplateMap ==nil {_fecf .SubtemplateMap =map[string ]_dfd .Reader {};
};if _fecf .FontMap ==nil {_fecf .FontMap =map[string ]*_fa .PdfFont {};};if _fecf .ImageMap ==nil {_fecf .ImageMap =map[string ]*_fa .Image {};};if _fecf .ColorMap ==nil {_fecf .ColorMap =map[string ]Color {};};if _fecf .ChartMap ==nil {_fecf .ChartMap =map[string ]_ff .ChartRenderable {};
};};func (_ggdd *templateProcessor )parseHorizontalAlignmentAttr (_gcbf ,_bfaggb string )HorizontalAlignment {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_gcbf ,_bfaggb );
_dggd :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_bfaggb ];return _dggd ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _fbac (color ,point )};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_abgag *Table )Width ()float64 {return 0};func (_cbbca *TableCell )cloneProps (_bgdc VectorDrawable )*TableCell {_febe :=*_cbbca ;_febe ._cead =_bgdc ;return &_febe ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_facea *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gadeb :=ctx ;_fffe ,ctx ,_eeab :=_facea ._edbe .GeneratePageBlocks (ctx );if _eeab !=nil {return _fffe ,ctx ,_eeab ;};for _ ,_ccdg :=range _facea ._agfbb {_fgbc :=_ccdg ._gdda ;
if !_facea ._cfgge {_ccdg ._gdda =0;};_adba ,_fdfgf ,_aaaba :=_ccdg .GeneratePageBlocks (ctx );_ccdg ._gdda =_fgbc ;if _aaaba !=nil {return _fffe ,ctx ,_aaaba ;};if len (_adba )< 1{continue ;};_fffe [len (_fffe )-1].mergeBlocks (_adba [0]);_fffe =append (_fffe ,_adba [1:]...);
ctx =_fdfgf ;};if _facea ._cafed .IsRelative (){ctx .X =_gadeb .X ;};if _facea ._cafed .IsAbsolute (){return _fffe ,_gadeb ,nil ;};return _fffe ,ctx ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gcfa *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cgfe float64 ;var _ccbc []*StyledParagraph ;for _ ,_bfgg :=range _gcfa ._fbeaf {_efde :=_defdc (_gcfa ._dbca );_efde .SetEnableWrap (false );_efde .SetTextAlignment (TextAlignmentRight );
_efde .Append (_bfgg ._dbea .Text ).Style =_bfgg ._dbea .Style ;_cadg :=_efde .getTextWidth ()/1000.0/ctx .Width ;if _cgfe < _cadg {_cgfe =_cadg ;};_ccbc =append (_ccbc ,_efde );};_fbggd :=_bgfa (2);_fbggd .SetColumnWidths (_cgfe ,1-_cgfe );_fbggd .SetMargins (_gcfa ._eead .Left +_gcfa ._dcdc ,_gcfa ._eead .Right ,_gcfa ._eead .Top ,_gcfa ._eead .Bottom );
_fbggd .EnableRowWrap (true );for _edea ,_abed :=range _gcfa ._fbeaf {_dgfb :=_fbggd .NewCell ();_dgfb .SetIndent (0);_dgfb .SetContent (_ccbc [_edea ]);_dgfb =_fbggd .NewCell ();_dgfb .SetIndent (0);_dgfb .SetContent (_abed ._edcf );};return _fbggd .GeneratePageBlocks (ctx );
};

// FitMode returns the fit mode of the image.
func (_egbac *Image )FitMode ()FitMode {return _egbac ._bdbe };

// SetBorderColor sets the border color.
func (_cfga *Polygon )SetBorderColor (color Color ){_cfga ._cgecf .BorderColor =_gdfa (color )};func _dbcb (_dffg *_ga .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_baea :_dffg ,_gacf :PositionRelative ,_eefa :Margins {Top :10,Bottom :10}},nil ;
};

// SetPos sets absolute positioning with specified coordinates.
func (_cdfc *StyledParagraph )SetPos (x ,y float64 ){_cdfc ._defc =PositionAbsolute ;_cdfc ._gbdbe =x ;_cdfc ._cgcgca =y ;};func (_fabgb *templateProcessor )parseList (_eccd *templateNode )(interface{},error ){_feccc :=_fabgb .creator .NewList ();for _ ,_adeeef :=range _eccd ._facfb .Attr {_dfcea :=_adeeef .Value ;
switch _fbae :=_adeeef .Name .Local ;_fbae {case "\u0069\u006e\u0064\u0065\u006e\u0074":_feccc .SetIndent (_fabgb .parseFloatAttr (_fbae ,_dfcea ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bfffc :=_fabgb .parseMarginAttr (_fbae ,_dfcea );_feccc .SetMargins (_bfffc .Left ,_bfffc .Right ,_bfffc .Top ,_bfffc .Bottom );
default:_fabgb .nodeLogDebug (_eccd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fbae );
};};return _feccc ,nil ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_ecabcg *TOC )SetLineSeparatorStyle (style TextStyle ){_ecabcg ._dbfad =style };func (_cbbc *Division )drawBackground (_fbec []*Block ,_facfg ,_gge DrawContext ,_abgg bool )([]*Block ,error ){_dbggc :=len (_fbec );if _dbggc ==0||_cbbc ._gcde ==nil {return _fbec ,nil ;
};_agg :=make ([]*Block ,0,len (_fbec ));for _eeae ,_gaecc :=range _fbec {var (_bgebd =_cbbc ._gcde .BorderRadiusTopLeft ;_feff =_cbbc ._gcde .BorderRadiusTopRight ;_deef =_cbbc ._gcde .BorderRadiusBottomLeft ;_bgag =_cbbc ._gcde .BorderRadiusBottomRight ;
);_ceg :=_facfg ;_ceg .Page +=_eeae ;if _eeae ==0{if _abgg {_agg =append (_agg ,_gaecc );continue ;};if _dbggc ==1{_ceg .Height =_gge .Y -_facfg .Y ;};}else {_ceg .X =_ceg .Margins .Left +_cbbc ._cdef .Left ;_ceg .Y =_ceg .Margins .Top ;_ceg .Width =_ceg .PageWidth -_ceg .Margins .Left -_ceg .Margins .Right -_cbbc ._cdef .Left -_cbbc ._cdef .Right ;
if _eeae ==_dbggc -1{_ceg .Height =_gge .Y -_ceg .Margins .Top -_cbbc ._cdef .Top ;}else {_ceg .Height =_ceg .PageHeight -_ceg .Margins .Top -_ceg .Margins .Bottom ;};if !_abgg {_bgebd =0;_feff =0;};};if _dbggc > 1&&_eeae !=_dbggc -1{_deef =0;_bgag =0;
};_dcef :=_cfce (_ceg .X ,_ceg .Y ,_ceg .Width ,_ceg .Height );_dcef .SetFillColor (_cbbc ._gcde .FillColor );_dcef .SetBorderColor (_cbbc ._gcde .BorderColor );_dcef .SetBorderWidth (_cbbc ._gcde .BorderSize );_dcef .SetBorderRadius (_bgebd ,_feff ,_deef ,_bgag );
_eeacg ,_ ,_ede :=_dcef .GeneratePageBlocks (_ceg );if _ede !=nil {return nil ,_ede ;};if len (_eeacg )==0{continue ;};_gegc :=_eeacg [0];if _ede =_gegc .mergeBlocks (_gaecc );_ede !=nil {return nil ,_ede ;};_agg =append (_agg ,_gegc );};return _agg ,nil ;
};func (_ccg *Block )mergeBlocks (_ceb *Block )error {_cfbb :=_gdb (_ccg ._ffc ,_ccg ._gae ,_ceb ._ffc ,_ceb ._gae );if _cfbb !=nil {return _cfbb ;};for _ ,_af :=range _ceb ._cc {_ccg .AddAnnotation (_af );};return nil ;};const (TextAlignmentLeft TextAlignment =iota ;
TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// TextAlignment options for paragraph.
type TextAlignment int ;

// NewColumn returns a new column for the line items invoice table.
func (_baeg *Invoice )NewColumn (description string )*InvoiceCell {return _baeg .newColumn (description ,CellHorizontalAlignmentLeft );};func (_ebgad *pageTransformations )transformPage (_eaag *_fa .PdfPage )error {if _daf :=_ebgad .applyFlip (_eaag );
_daf !=nil {return _daf ;};return nil ;};

// SetWidth sets the width of the rectangle.
func (_agggf *Rectangle )SetWidth (width float64 ){_agggf ._faaa =width };

// SetBorderWidth sets the border width.
func (_dcaa *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_dcaa ._cadfg .BorderWidth =borderWidth ;};func _feada (_bcead *_fa .PdfFont ,_bdede float64 )*fontMetrics {_edgfe :=&fontMetrics {};if _bcead ==nil {_eef .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _edgfe ;};_gefff ,_gfecc :=_bcead .GetFontDescriptor ();if _gfecc !=nil {_eef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_gfecc );
return _edgfe ;};if _edgfe ._cbaab ,_gfecc =_gefff .GetCapHeight ();_gfecc !=nil {_eef .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_gfecc );
};if int (_edgfe ._cbaab )<=0{_eef .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_edgfe ._cbaab =1000;};_edgfe ._cbaab *=_bdede /1000.0;if _edgfe ._gbffe ,_gfecc =_gefff .GetXHeight ();_gfecc !=nil {_eef .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_gfecc );
};_edgfe ._gbffe *=_bdede /1000.0;if _edgfe ._aebcd ,_gfecc =_gefff .GetAscent ();_gfecc !=nil {_eef .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_gfecc );
};_edgfe ._aebcd *=_bdede /1000.0;if _edgfe ._dgad ,_gfecc =_gefff .GetDescent ();_gfecc !=nil {_eef .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_gfecc );
};_edgfe ._dgad *=_bdede /1000.0;return _edgfe ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_cdbg *shading )SetExtends (start bool ,end bool ){_cdbg ._ffcf =[]bool {start ,end }};func (_egae *templateProcessor )getNodeErrorLocation (_fgcdd *templateNode ,_bbbca string ,_cbafd ...interface{})string {_bdbbc :=_g .Sprintf (_bbbca ,_cbafd ...);
_dbcd :=_g .Sprintf ("\u0025\u0064",_fgcdd ._fcagb );if _fgcdd ._edcb !=0{_dbcd =_g .Sprintf ("\u0025\u0064\u003a%\u0064",_fgcdd ._edcb ,_fgcdd ._gdbed );};if _egae ._cdgag !=""{return _g .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_bdbbc ,_egae ._cdgag ,_dbcd );
};return _g .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_bdbbc ,_dbcd );};func (_ffef *Paragraph )getMaxLineWidth ()float64 {if _ffef ._gbdea ==nil ||len (_ffef ._gbdea )==0{_ffef .wrapText ();};var _gebe float64 ;for _ ,_ecae :=range _ffef ._gbdea {_acac :=_ffef .getTextLineWidth (_ecae );
if _acac > _gebe {_gebe =_acac ;};};return _gebe ;};func (_fcaafa *TOCLine )prepareParagraph (_gdccb *StyledParagraph ,_dedcd DrawContext ){_bcdc :=_fcaafa .Title .Text ;if _fcaafa .Number .Text !=""{_bcdc ="\u0020"+_bcdc ;};_bcdc +="\u0020";_ababg :=_fcaafa .Page .Text ;
if _ababg !=""{_ababg ="\u0020"+_ababg ;};_gdccb ._cfbcg =[]*TextChunk {{Text :_fcaafa .Number .Text ,Style :_fcaafa .Number .Style ,_gbgga :_fcaafa .getLineLink ()},{Text :_bcdc ,Style :_fcaafa .Title .Style ,_gbgga :_fcaafa .getLineLink ()},{Text :_ababg ,Style :_fcaafa .Page .Style ,_gbgga :_fcaafa .getLineLink ()}};
_gdccb .wrapText ();_gaaaf :=len (_gdccb ._egffa );if _gaaaf ==0{return ;};_affd :=_dedcd .Width *1000-_gdccb .getTextLineWidth (_gdccb ._egffa [_gaaaf -1]);_baae :=_gdccb .getTextLineWidth ([]*TextChunk {&_fcaafa .Separator });_dagaf :=int (_affd /_baae );
_dgaeb :=_dc .Repeat (_fcaafa .Separator .Text ,_dagaf );_dcbeg :=_fcaafa .Separator .Style ;_gfbag :=_gdccb .Insert (2,_dgaeb );_gfbag .Style =_dcbeg ;_gfbag ._gbgga =_fcaafa .getLineLink ();_affd =_affd -float64 (_dagaf )*_baae ;if _affd > 500{_fcacb ,_egbba :=_dcbeg .Font .GetRuneMetrics (' ');
if _egbba &&_affd > _fcacb .Wx {_dgbdb :=int (_affd /_fcacb .Wx );if _dgbdb > 0{_aaed :=_dcbeg ;_aaed .FontSize =1;_gfbag =_gdccb .Insert (2,_dc .Repeat ("\u0020",_dgbdb ));_gfbag .Style =_aaed ;_gfbag ._gbgga =_fcaafa .getLineLink ();};};};};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_eagb *TOC )SetLineLevelOffset (levelOffset float64 ){_eagb ._gafab =levelOffset };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_dcagc *TOCLine )SetLink (page int64 ,x ,y float64 ){_dcagc ._faga =x ;_dcagc ._eeaa =y ;_dcagc ._gdda =page ;_fbcd :=_dcagc ._bagf ._ggee .Color ;_dcagc .Number .Style .Color =_fbcd ;_dcagc .Title .Style .Color =_fbcd ;_dcagc .Separator .Style .Color =_fbcd ;
_dcagc .Page .Style .Color =_fbcd ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_gdcd *Chart )SetPos (x ,y float64 ){_gdcd ._gbdd =PositionAbsolute ;_gdcd ._ggf =x ;_gdcd ._gfe =y ;};

// SetIndent sets the cell's left indent.
func (_gbdf *TableCell )SetIndent (indent float64 ){_gbdf ._ddbeg =indent };func (_cfgfe *templateProcessor )loadImageFromSrc (_dcafd string )(*Image ,error ){if _dcafd ==""{_eef .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_cfee ;};_afcedg :=_dc .Split (_dcafd ,"\u002c");for _ ,_afedd :=range _afcedg {_afedd =_dc .TrimSpace (_afedd );if _afedd ==""{continue ;};_efbafg ,_dbegb :=_cfgfe ._cbdga .ImageMap [_afedd ];if _dbegb {return _aagg (_efbafg );};if _dabgb :=_cfgfe .parseAttrPropList (_afedd );
len (_dabgb )> 0{if _egffg ,_bddcg :=_dabgb ["\u0070\u0061\u0074\u0068"];_bddcg {if _ddafd ,_dcbg :=_acgfb (_egffg );_dcbg !=nil {_eef .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_egffg ,_dcbg );
}else {return _ddafd ,nil ;};};};};_eef .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dcafd );return nil ,_cfee ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_babfa string ;_gcedf *_fa .PdfFont ;_cgcbd float64 ;_ecegc float64 ;_beaa Color ;_fbgf TextAlignment ;_fade bool ;_gdffb float64 ;_ebfbg int ;_gade bool ;_dgdea float64 ;_fbba Margins ;_aacf Positioning ;_ggde float64 ;_ffdcg float64 ;
_bdefc ,_efdb float64 ;_gbdea []string ;};

// LineWidth returns the width of the line.
func (_eebfc *Line )LineWidth ()float64 {return _eebfc ._baec };func _decfe (_bacebg *templateProcessor ,_gbfbcd *templateNode )(interface{},error ){return _bacebg .parseDivision (_gbfbcd );};

// SetBorderWidth sets the border width.
func (_fdce *CurvePolygon )SetBorderWidth (borderWidth float64 ){_fdce ._dbag .BorderWidth =borderWidth };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_bdggf *List )Marker ()*TextChunk {return &_bdggf ._cgef };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bbba *TOC )SetHeading (text string ,style TextStyle ){_cgfdg :=_bbba .Heading ();_cgfdg .Reset ();_ggaec :=_cgfdg .Append (text );_ggaec .Style =style ;};

// Cols returns the total number of columns the table has.
func (_ddbec *Table )Cols ()int {return _ddbec ._beege };

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_bbcgf *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_bbcgf ._efgeg =dashArray ;_bbcgf ._gfee =dashPhase ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_ecba *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gbfd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gbfd ._bbgg =toc ;};func (_aaadaf *templateProcessor )parseDivision (_dgdd *templateNode )(interface{},error ){_edab :=_aaadaf .creator .NewDivision ();for _ ,_dgfba :=range _dgdd ._facfb .Attr {_bdcb :=_dgfba .Value ;
switch _baab :=_dgfba .Name .Local ;_baab {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_edab .EnablePageWrap (_aaadaf .parseBoolAttr (_baab ,_bdcb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fdda :=_aaadaf .parseMarginAttr (_baab ,_bdcb );
_edab .SetMargins (_fdda .Left ,_fdda .Right ,_fdda .Top ,_fdda .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_gcba :=_aaadaf .parseMarginAttr (_baab ,_bdcb );_edab .SetPadding (_gcba .Left ,_gcba .Right ,_gcba .Top ,_gcba .Bottom );default:_aaadaf .nodeLogDebug (_dgdd ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_baab );
};};return _edab ,nil ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dffc *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_becd :=_defdc (_dffc ._dbca );_becd .Append (text );_bdgfe ,_bdfa :=_dffc .Add (_becd );return _becd ,_bdgfe ,_bdfa ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_fbca *Creator )DrawHeader (drawHeaderFunc func (_gccc *Block ,_fac HeaderFunctionArgs )){_fbca ._feef =drawHeaderFunc ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_cgge :_ec .Min (float64 (c ),100)/100.0,_fbcb :_ec .Min (float64 (m ),100)/100.0,_abad :_ec .Min (float64 (y ),100)/100.0,_gdad :_ec .Min (float64 (k ),100)/100.0};};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetBorderOpacity sets the border opacity of the ellipse.
func (_gbbg *Ellipse )SetBorderOpacity (opacity float64 ){_gbbg ._acdcf =opacity };type shading struct{_cfcbc Color ;_eadef bool ;_ffcf []bool ;_fbdg []*ColorPoint ;};func _cabda (_cbefe *templateProcessor ,_cabac *templateNode )(interface{},error ){return _cbefe .parseChapterHeading (_cabac );
};

// SetSideBorderStyle sets the cell's side border style.
func (_fede *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_fede ._deaff =style ;_fede ._fafdb =style ;_fede ._cbbdb =style ;_fede ._fbcg =style ;case CellBorderSideTop :_fede ._deaff =style ;
case CellBorderSideBottom :_fede ._fafdb =style ;case CellBorderSideLeft :_fede ._cbbdb =style ;case CellBorderSideRight :_fede ._fbcg =style ;};};

// Height returns the height of the graphic svg.
func (_ecef *GraphicSVG )Height ()float64 {return _ecef ._baea .Height };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_cadb *Invoice )TotalLines ()[][2]*InvoiceCell {_fdac :=[][2]*InvoiceCell {_cadb ._aeggf };_fdac =append (_fdac ,_cadb ._cgca ...);return append (_fdac ,_cadb ._cadf );};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_gagf *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// Invoice represents a configurable invoice template.
type Invoice struct{_afgg string ;_fabc *Image ;_gcfe *InvoiceAddress ;_aecb *InvoiceAddress ;_edec string ;_cgga [2]*InvoiceCell ;_bacd [2]*InvoiceCell ;_gdcc [2]*InvoiceCell ;_dgec [][2]*InvoiceCell ;_cgcg []*InvoiceCell ;_cgec [][]*InvoiceCell ;_aeggf [2]*InvoiceCell ;
_cadf [2]*InvoiceCell ;_cgca [][2]*InvoiceCell ;_ebcg [2]string ;_befe [2]string ;_gdag [][2]string ;_ggac TextStyle ;_acaa TextStyle ;_gbfbc TextStyle ;_gbgdd TextStyle ;_cecc TextStyle ;_bgeac TextStyle ;_gaga TextStyle ;_cebef InvoiceCellProps ;_abef InvoiceCellProps ;
_cdab InvoiceCellProps ;_defd InvoiceCellProps ;_fcgdf Positioning ;};func (_deba *Table )wrapRow (_abbge int ,_cccf DrawContext ,_gdge float64 )(bool ,error ){if !_deba ._dbac {return false ,nil ;};var (_gcdga =_deba ._bdfef [_abbge ];_ddfgb =-1;_abcg []*TableCell ;
_fgdb float64 ;_gaad bool ;_bgcff =make ([]float64 ,0,len (_deba ._gaecf )););_cgfda :=func (_adgff *TableCell ,_facb VectorDrawable ,_deedc bool )*TableCell {_acbg :=*_adgff ;_acbg ._cead =_facb ;if _deedc {_acbg ._cceef ++;};return &_acbg ;};_dacbb :=func (_egbe int ,_bfdea VectorDrawable ){var _bgdec float64 =-1;
if _bfdea ==nil {if _gfdce :=_bgcff [_egbe -_abbge ];_gfdce > _cccf .Height {_bfdea =_deba ._bdfef [_egbe ]._cead ;_deba ._bdfef [_egbe ]._cead =nil ;_bgcff [_egbe -_abbge ]=0;_bgdec =_gfdce ;};};_eabf :=_cgfda (_deba ._bdfef [_egbe ],_bfdea ,true );_abcg =append (_abcg ,_eabf );
if _bgdec < 0{_bgdec =_eabf .height (_cccf .Width );};if _bgdec > _fgdb {_fgdb =_bgdec ;};};for _dfefcc :=_abbge ;_dfefcc < len (_deba ._bdfef );_dfefcc ++{_aebg :=_deba ._bdfef [_dfefcc ];if _gcdga ._cceef !=_aebg ._cceef {_ddfgb =_dfefcc ;break ;};_cccf .Width =_aebg .width (_deba ._gaecf ,_gdge );
_fbdgb :=_aebg .height (_cccf .Width );var _gdafd VectorDrawable ;switch _gddba :=_aebg ._cead .(type ){case *StyledParagraph :if _fbdgb > _cccf .Height {_bbad :=_cccf ;_bbad .Height =_ec .Floor (_cccf .Height -_gddba ._faaba .Top -_gddba ._faaba .Bottom -0.5*_gddba .getTextHeight ());
_ccdbb ,_fdec ,_gafee :=_gddba .split (_bbad );if _gafee !=nil {return false ,_gafee ;};if _ccdbb !=nil &&_fdec !=nil {_gddba =_ccdbb ;_aebg =_cgfda (_aebg ,_ccdbb ,false );_deba ._bdfef [_dfefcc ]=_aebg ;_gdafd =_fdec ;_gaad =true ;};_fbdgb =_aebg .height (_cccf .Width );
};case *Division :if _fbdgb > _cccf .Height {_aebac :=_cccf ;_aebac .Height =_ec .Floor (_cccf .Height -_gddba ._cdef .Top -_gddba ._cdef .Bottom );_cecf ,_dgef :=_gddba .split (_aebac );if _cecf !=nil &&_dgef !=nil {_gddba =_cecf ;_aebg =_cgfda (_aebg ,_cecf ,false );
_deba ._bdfef [_dfefcc ]=_aebg ;_gdafd =_dgef ;_gaad =true ;if _cecf ._gcde !=nil {_cecf ._gcde .BorderRadiusBottomLeft =0;_cecf ._gcde .BorderRadiusBottomRight =0;};if _dgef ._gcde !=nil {_dgef ._gcde .BorderRadiusTopLeft =0;_dgef ._gcde .BorderRadiusTopRight =0;
};_fbdgb =_aebg .height (_cccf .Width );};};case *List :if _fbdgb > _cccf .Height {_cadgg :=_cccf ;_cadgg .Height =_ec .Floor (_cccf .Height -_gddba ._eead .Vertical ());_cfcbb ,_dbabc :=_gddba .split (_cadgg );if _cfcbb !=nil {_gddba =_cfcbb ;_aebg =_cgfda (_aebg ,_cfcbb ,false );
_deba ._bdfef [_dfefcc ]=_aebg ;};if _dbabc !=nil {_gdafd =_dbabc ;_gaad =true ;};_fbdgb =_aebg .height (_cccf .Width );};};_bgcff =append (_bgcff ,_fbdgb );if _gaad {if _abcg ==nil {_abcg =make ([]*TableCell ,0,len (_deba ._gaecf ));for _cceb :=_abbge ;
_cceb < _dfefcc ;_cceb ++{_dacbb (_cceb ,nil );};};_dacbb (_dfefcc ,_gdafd );};};var _deddg float64 ;for _ ,_eeccg :=range _bgcff {if _eeccg > _deddg {_deddg =_eeccg ;};};if _gaad &&_deddg < _cccf .Height {if _ddfgb < 0{_ddfgb =len (_deba ._bdfef );};_bccaf :=_deba ._bdfef [_ddfgb -1]._cceef +_deba ._bdfef [_ddfgb -1]._badd -1;
for _dedac :=_ddfgb ;_dedac < len (_deba ._bdfef );_dedac ++{_deba ._bdfef [_dedac ]._cceef ++;};_deba ._bdfef =append (_deba ._bdfef [:_ddfgb ],append (_abcg ,_deba ._bdfef [_ddfgb :]...)...);_deba ._cddcg =append (_deba ._cddcg [:_bccaf ],append ([]float64 {_fgdb },_deba ._cddcg [_bccaf :]...)...);
_deba ._cddcg [_gcdga ._cceef +_gcdga ._badd -2]=_deddg ;};return _gaad ,nil ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fcgec *Invoice )NoteHeadingStyle ()TextStyle {return _fcgec ._gaga };func _efccg (_badf *Creator ,_abff _dfd .Reader ,_agedg interface{},_cbcba *TemplateOptions ,_eagg componentRenderer )error {if _badf ==nil {_eef .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _abeb ;};_agga :="";if _cfbe ,_acgcc :=_abff .(*_df .File );_acgcc {_agga =_cfbe .Name ();};_ccea :=_ef .NewBuffer (nil );if _ ,_gaega :=_dfd .Copy (_ccea ,_abff );_gaega !=nil {return _gaega ;};_bgaaf :=_cb .FuncMap {"\u0064\u0069\u0063\u0074":_cdaaa };
if _cbcba !=nil &&_cbcba .HelperFuncMap !=nil {for _edbf ,_gcdgea :=range _cbcba .HelperFuncMap {if _ ,_bgdac :=_bgaaf [_edbf ];_bgdac {_eef .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_edbf );
continue ;};_bgaaf [_edbf ]=_gcdgea ;};};_debab ,_cbdf :=_cb .New ("").Funcs (_bgaaf ).Parse (_ccea .String ());if _cbdf !=nil {return _cbdf ;};if _cbcba !=nil &&_cbcba .SubtemplateMap !=nil {for _ecgg ,_ffcfg :=range _cbcba .SubtemplateMap {if _ecgg ==""{_eef .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _ffcfg ==nil {_eef .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_fbge :=_ef .NewBuffer (nil );if _ ,_bbbcb :=_dfd .Copy (_fbge ,_ffcfg );_bbbcb !=nil {return _bbbcb ;};if _ ,_gbafa :=_debab .New (_ecgg ).Parse (_fbge .String ());_gbafa !=nil {return _gbafa ;};};};_ccea .Reset ();if _dfbca :=_debab .Execute (_ccea ,_agedg );
_dfbca !=nil {return _dfbca ;};return _bbec (_badf ,_agga ,_ccea .Bytes (),_cbcba ,_eagg ).run ();};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_face *Table )SetMargins (left ,right ,top ,bottom float64 ){_face ._fefca .Left =left ;_face ._fefca .Right =right ;_face ._fefca .Top =top ;_face ._fefca .Bottom =bottom ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_cga []VectorDrawable ;_gbfg Positioning ;_cdef Margins ;_dgfg Margins ;_dacf bool ;_gfbg bool ;_gcde *Background ;};

// SetStyleBottom sets border style for bottom side.
func (_ddde *border )SetStyleBottom (style CellBorderStyle ){_ddde ._befg =style };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gef *Creator )SetOptimizer (optimizer _fa .Optimizer ){_gef ._effb =optimizer };

// SetFillColor sets background color for border.
func (_ddd *border )SetFillColor (col Color ){_ddd ._eede =col };func _fabb (_cddd []_ce .Point )*Polyline {return &Polyline {_dfgf :&_ce .Polyline {Points :_cddd ,LineColor :_fa .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_ggba :1.0};};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_eeg *Block )ScaleToHeight (h float64 ){_aac :=h /_eeg ._dec ;_eeg .Scale (_aac ,_aac )};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Width returns the width of the specified text chunk.
func (_efacg *TextChunk )Width ()float64 {var (_gbfa float64 ;_ggeff =_efacg .Style ;);for _ ,_eadda :=range _efacg .Text {_dfbda ,_degd :=_ggeff .Font .GetRuneMetrics (_eadda );if !_degd {_eef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_eadda ,_eadda ,_ggeff .Font .BaseFont (),_ggeff .Font .Subtype ());
_eef .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ggeff .Font );_eef .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ggeff .Font .Encoder ());};_gfabd :=_ggeff .FontSize *_dfbda .Wx ;_bdecf :=_gfabd ;
if _eadda !=' '{_bdecf =_gfabd +_ggeff .CharSpacing *1000.0;};_gbfa +=_bdecf ;};return _gbfa /1000.0;};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_fbggf *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbggf ._dcdb .Left ,_fbggf ._dcdb .Right ,_fbggf ._dcdb .Top ,_fbggf ._dcdb .Bottom ;};func _cagcb (_ddbf *templateProcessor ,_dfabg *templateNode )(interface{},error ){return _ddbf .parseStyledParagraph (_dfabg );
};func (_egd rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _egd ._abec ,_egd ._eafb ,_egd ._baa };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_fdee *Creator )NewTextStyle ()TextStyle {return _ggbe (_fdee ._aebd )};

// FitMode returns the fit mode of the line.
func (_cgad *Line )FitMode ()FitMode {return _cgad ._bfeb };

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_acea *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _ebad (x ,y ,innerRadius ,outerRadius ,colorPoints );};func (_bceag *templateProcessor )parseTable (_cafb *templateNode )(interface{},error ){var _dcgf int64 ;
for _ ,_dbfbg :=range _cafb ._facfb .Attr {_aefcf :=_dbfbg .Value ;switch _ecdbd :=_dbfbg .Name .Local ;_ecdbd {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_dcgf =_bceag .parseInt64Attr (_ecdbd ,_aefcf );};};if _dcgf <=0{_bceag .nodeLogDebug (_cafb ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_dcgf );
_dcgf =1;};_ebaba :=_bceag .creator .NewTable (int (_dcgf ));for _ ,_eaed :=range _cafb ._facfb .Attr {_accde :=_eaed .Value ;switch _ddda :=_eaed .Name .Local ;_ddda {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_ebaba .SetColumnWidths (_bceag .parseFloatArray (_ddda ,_accde )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_badfe :=_bceag .parseMarginAttr (_ddda ,_accde );_ebaba .SetMargins (_badfe .Left ,_badfe .Right ,_badfe .Top ,_badfe .Bottom );case "\u0078":_ebaba .SetPos (_bceag .parseFloatAttr (_ddda ,_accde ),_ebaba ._dfdc );
case "\u0079":_ebaba .SetPos (_ebaba ._dcbdd ,_bceag .parseFloatAttr (_ddda ,_accde ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_ebaba ._adaae =int (_bceag .parseInt64Attr (_ddda ,_accde ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_ebaba ._begg =int (_bceag .parseInt64Attr (_ddda ,_accde ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_ebaba .EnableRowWrap (_bceag .parseBoolAttr (_ddda ,_accde ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_ebaba .EnablePageWrap (_bceag .parseBoolAttr (_ddda ,_accde ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_bceag .nodeLogDebug (_cafb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_ddda );
};};if _ebaba ._adaae !=0&&_ebaba ._begg !=0{_fbbae :=_ebaba .SetHeaderRows (_ebaba ._adaae ,_ebaba ._begg );if _fbbae !=nil {_bceag .nodeLogDebug (_cafb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_fbbae );
};}else {_ebaba ._adaae =0;_ebaba ._begg =0;};return _ebaba ,nil ;};

// Append adds a new text chunk to the paragraph.
func (_gggag *StyledParagraph )Append (text string )*TextChunk {_adec :=NewTextChunk (text ,_gggag ._aegbg );return _gggag .appendChunk (_adec );};

// BorderWidth returns the border width of the rectangle.
func (_caga *Rectangle )BorderWidth ()float64 {return _caga ._aebcg };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ebff *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ebff ._fbba .Left ,_ebff ._fbba .Right ,_ebff ._fbba .Top ,_ebff ._fbba .Bottom ;};func (_ebcee *templateProcessor )parseCellVerticalAlignmentAttr (_bbbec ,_abaec string )CellVerticalAlignment {_eef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bbbec ,_abaec );
_dbdc :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_abaec ];return _dbdc ;};


// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_dcbe *Image )SetWidth (w float64 ){_dcbe ._gfef =w };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_eeag *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_beee :=ctx ;_abgbc :=[]func (_cgdc DrawContext )([]*Block ,DrawContext ,error ){_eeag .generateHeaderBlocks ,_eeag .generateInformationBlocks ,_eeag .generateLineBlocks ,_eeag .generateTotalBlocks ,_eeag .generateNoteBlocks };
var _fbeae []*Block ;for _ ,_fgfe :=range _abgbc {_bace ,_ceefc ,_bgaa :=_fgfe (ctx );if _bgaa !=nil {return _fbeae ,ctx ,_bgaa ;};if len (_fbeae )==0{_fbeae =_bace ;}else if len (_bace )> 0{_fbeae [len (_fbeae )-1].mergeBlocks (_bace [0]);_fbeae =append (_fbeae ,_bace [1:]...);
};ctx =_ceefc ;};if _eeag ._fcgdf .IsRelative (){ctx .X =_beee .X ;};if _eeag ._fcgdf .IsAbsolute (){return _fbeae ,_beee ,nil ;};return _fbeae ,ctx ,nil ;};

// NewPolyline creates a new polyline.
func (_afb *Creator )NewPolyline (points []_ce .Point )*Polyline {return _fabb (points )};func _bbec (_ddac *Creator ,_bdgab string ,_dgaaa []byte ,_daad *TemplateOptions ,_babcb componentRenderer )*templateProcessor {if _daad ==nil {_daad =&TemplateOptions {};
};_daad .init ();if _babcb ==nil {_babcb =_ddac ;};return &templateProcessor {creator :_ddac ,_bbfa :_dgaaa ,_cbdga :_daad ,_fcaeg :_babcb ,_cdgag :_bdgab };};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cfbcg []*TextChunk ;_aegbg TextStyle ;_ggee TextStyle ;_dgbde TextAlignment ;_ggdf TextVerticalAlignment ;_gbcb float64 ;_dgba bool ;_fdfbb float64 ;_ebgbe bool ;_gadge bool ;_ebebd TextOverflow ;_cefe float64 ;_faaba Margins ;
_defc Positioning ;_gbdbe float64 ;_cgcgca float64 ;_bagd float64 ;_agddd float64 ;_egffa [][]*TextChunk ;_cddca func (_bdce *StyledParagraph ,_agab DrawContext );};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_efge *Creator )SetPageSize (size PageSize ){_efge ._cab =size ;_efge ._ggfe =size [0];_efge ._bbdg =size [1];_agag :=0.1*_efge ._ggfe ;_efge ._bcbf .Left =_agag ;_efge ._bcbf .Right =_agag ;_efge ._bcbf .Top =_agag ;_efge ._bcbf .Bottom =_agag ;
};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_ccgg []*_fa .PdfPage ;_ecd map[*_fa .PdfPage ]*Block ;_fgec map[*_fa .PdfPage ]*pageTransformations ;_aca *_fa .PdfPage ;_cab PageSize ;_gbb DrawContext ;_bcbf Margins ;_ggfe ,_bbdg float64 ;_eddf int ;_fcaa func (_cedb FrontpageFunctionArgs );
_eccg func (_abb *TOC )error ;_feef func (_efa *Block ,_bdba HeaderFunctionArgs );_ddb func (_fbb *Block ,_dccee FooterFunctionArgs );_geab func (_bfb PageFinalizeFunctionArgs )error ;_gbgd func (_dabd *_fa .PdfWriter )error ;_beb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_bbgg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_ffgcf *_fa .Outline ;_abfe *_fa .PdfOutlineTreeNode ;_adea *_fa .PdfAcroForm ;_aded _ea .PdfObject ;_effb _fa .Optimizer ;_gfc []*_fa .PdfFont ;_aebd *_fa .PdfFont ;_gaba *_fa .PdfFont ;};func (_dgefg *templateProcessor )parseTableCell (_efgfc *templateNode )(interface{},error ){if _efgfc ._bgba ==nil {_dgefg .nodeLogError (_efgfc ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_abag ;};_afge ,_fcafe :=_efgfc ._bgba ._ccfeb .(*Table );if !_fcafe {_dgefg .nodeLogError (_efgfc ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_efgfc ._bgba ._ccfeb );
return nil ,_abag ;};var _fgcaa ,_efaa int64 ;for _ ,_fbaff :=range _efgfc ._facfb .Attr {_ebbe :=_fbaff .Value ;switch _bcad :=_fbaff .Name .Local ;_bcad {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_fgcaa =_dgefg .parseInt64Attr (_bcad ,_ebbe );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_efaa =_dgefg .parseInt64Attr (_bcad ,_ebbe );
};};if _fgcaa <=0{_fgcaa =1;};if _efaa <=0{_efaa =1;};_aagcf :=_afge .MultiCell (int (_efaa ),int (_fgcaa ));for _ ,_acccd :=range _efgfc ._facfb .Attr {_dacee :=_acccd .Value ;switch _ddacb :=_acccd .Name .Local ;_ddacb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_aagcf .SetIndent (_dgefg .parseFloatAttr (_ddacb ,_dacee ));
case "\u0061\u006c\u0069g\u006e":_aagcf .SetHorizontalAlignment (_dgefg .parseCellAlignmentAttr (_ddacb ,_dacee ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_aagcf .SetVerticalAlignment (_dgefg .parseCellVerticalAlignmentAttr (_ddacb ,_dacee ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_aagcf .SetSideBorderStyle (CellBorderSideAll ,_dgefg .parseCellBorderStyleAttr (_ddacb ,_dacee ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_aagcf .SetSideBorderStyle (CellBorderSideTop ,_dgefg .parseCellBorderStyleAttr (_ddacb ,_dacee ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_aagcf .SetSideBorderStyle (CellBorderSideBottom ,_dgefg .parseCellBorderStyleAttr (_ddacb ,_dacee ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_aagcf .SetSideBorderStyle (CellBorderSideLeft ,_dgefg .parseCellBorderStyleAttr (_ddacb ,_dacee ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_aagcf .SetSideBorderStyle (CellBorderSideRight ,_dgefg .parseCellBorderStyleAttr (_ddacb ,_dacee ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_aagcf .SetSideBorderWidth (CellBorderSideAll ,_dgefg .parseFloatAttr (_ddacb ,_dacee ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_aagcf .SetSideBorderWidth (CellBorderSideTop ,_dgefg .parseFloatAttr (_ddacb ,_dacee ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_aagcf .SetSideBorderWidth (CellBorderSideBottom ,_dgefg .parseFloatAttr (_ddacb ,_dacee ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_aagcf .SetSideBorderWidth (CellBorderSideLeft ,_dgefg .parseFloatAttr (_ddacb ,_dacee ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_aagcf .SetSideBorderWidth (CellBorderSideRight ,_dgefg .parseFloatAttr (_ddacb ,_dacee ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_aagcf .SetSideBorderColor (CellBorderSideAll ,_dgefg .parseColorAttr (_ddacb ,_dacee ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_aagcf .SetSideBorderColor (CellBorderSideTop ,_dgefg .parseColorAttr (_ddacb ,_dacee ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_aagcf .SetSideBorderColor (CellBorderSideBottom ,_dgefg .parseColorAttr (_ddacb ,_dacee ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_aagcf .SetSideBorderColor (CellBorderSideLeft ,_dgefg .parseColorAttr (_ddacb ,_dacee ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_aagcf .SetSideBorderColor (CellBorderSideRight ,_dgefg .parseColorAttr (_ddacb ,_dacee ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_aagcf .SetBorderLineStyle (_dgefg .parseLineStyleAttr (_ddacb ,_dacee ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_aagcf .SetBackgroundColor (_dgefg .parseColorAttr (_ddacb ,_dacee ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_dgefg .nodeLogDebug (_efgfc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ddacb );
};};return _aagcf ,nil ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_baea *_ga .GraphicSVG ;_gacf Positioning ;_gfgc float64 ;_dffe float64 ;_eefa Margins ;};

// GeneratePageBlocks draws the chart onto a block.
func (_eadc *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffgc :=ctx ;_aebe :=_eadc ._gbdd .IsRelative ();var _cggca []*Block ;if _aebe {_ffd :=1.0;_ffgg :=_eadc ._ebga .Top ;if float64 (_eadc ._ccf .Height ())> ctx .Height -_eadc ._ebga .Top {_cggca =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _cdbcf error ;if _ ,ctx ,_cdbcf =_ddge ().GeneratePageBlocks (ctx );_cdbcf !=nil {return nil ,ctx ,_cdbcf ;};_ffgg =0;};ctx .X +=_eadc ._ebga .Left +_ffd ;ctx .Y +=_ffgg ;ctx .Width -=_eadc ._ebga .Left +_eadc ._ebga .Right +2*_ffd ;ctx .Height -=_ffgg ;
_eadc ._ccf .SetWidth (int (ctx .Width ));}else {ctx .X =_eadc ._ggf ;ctx .Y =_eadc ._gfe ;};_afad :=_bd .NewContentCreator ();_afad .Translate (0,ctx .PageHeight );_afad .Scale (1,-1);_afad .Translate (ctx .X ,ctx .Y );_fbaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_eadc ._ccf .Render (_ffe .NewRenderer (_afad ,_fbaf ._gae ),nil );if _adbe :=_fbaf .addContentsByString (_afad .String ());_adbe !=nil {return nil ,ctx ,_adbe ;};if _aebe {_daba :=_eadc .Height ()+_eadc ._ebga .Bottom ;ctx .Y +=_daba ;ctx .Height -=_daba ;
}else {ctx =_ffgc ;};_cggca =append (_cggca ,_fbaf );return _cggca ,ctx ,nil ;};

// Logo returns the logo of the invoice.
func (_eaab *Invoice )Logo ()*Image {return _eaab ._fabc };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_cbffg *RadialShading )SetAntiAlias (enable bool ){_cbffg ._gcbg .SetAntiAlias (enable )};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_cade *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _eaage (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Width returns Image's document width.
func (_adfe *Image )Width ()float64 {return _adfe ._gfef };

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_dgee *Paragraph )SetColor (col Color ){_dgee ._beaa =col };

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_gcbe *Rectangle )BorderOpacity ()float64 {return _gcbe ._gacec };

// SetColorRight sets border color for right.
func (_fcea *border )SetColorRight (col Color ){_fcea ._fdaa =col };func (_bccg *Invoice )generateTotalBlocks (_gbfbcc DrawContext )([]*Block ,DrawContext ,error ){_fgabf :=_bgfa (4);_fgabf .SetMargins (0,0,10,10);_fcdg :=[][2]*InvoiceCell {_bccg ._aeggf };
_fcdg =append (_fcdg ,_bccg ._cgca ...);_fcdg =append (_fcdg ,_bccg ._cadf );for _ ,_adaca :=range _fcdg {_eecc ,_aebc :=_adaca [0],_adaca [1];if _aebc .Value ==""{continue ;};_fgabf .SkipCells (2);_afce :=_fgabf .NewCell ();_afce .SetBackgroundColor (_eecc .BackgroundColor );
_afce .SetHorizontalAlignment (_aebc .Alignment );_bccg .setCellBorder (_afce ,_eecc );_fbad :=_defdc (_eecc .TextStyle );_fbad .SetMargins (0,0,2,1);_fbad .Append (_eecc .Value );_afce .SetContent (_fbad );_afce =_fgabf .NewCell ();_afce .SetBackgroundColor (_aebc .BackgroundColor );
_afce .SetHorizontalAlignment (_aebc .Alignment );_bccg .setCellBorder (_afce ,_eecc );_fbad =_defdc (_aebc .TextStyle );_fbad .SetMargins (0,0,2,1);_fbad .Append (_aebc .Value );_afce .SetContent (_fbad );};return _fgabf .GeneratePageBlocks (_gbfbcc );
};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_becg *Rectangle )ScaleToWidth (w float64 ){_edddd :=_becg ._baag /_becg ._faaa ;_becg ._faaa =w ;_becg ._baag =w *_edddd ;};

// TOC returns the table of contents component of the creator.
func (_gcb *Creator )TOC ()*TOC {return _gcb ._bbgg };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gggg *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gggg ._fe .Left ,_gggg ._fe .Right ,_gggg ._fe .Top ,_gggg ._fe .Bottom ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_efbg *Creator )MoveDown (dy float64 ){_efbg ._gbb .Y +=dy };

// SetOpacity sets the opacity of the line (0-1).
func (_fbaa *Line )SetOpacity (opacity float64 ){_fbaa ._gcaa =opacity };func _bdbc (_cfa *Chapter ,_cdda *TOC ,_gbeb *_fa .Outline ,_gcd string ,_bge int ,_dbeb TextStyle )*Chapter {var _fecc uint =1;if _cfa !=nil {_fecc =_cfa ._feed +1;};_dgf :=&Chapter {_fgb :_bge ,_ebfe :_gcd ,_faea :true ,_abee :true ,_eda :_cfa ,_gdaf :_cdda ,_eaa :_gbeb ,_cdde :[]Drawable {},_feed :_fecc };
_adf :=_gacc (_dgf .headingText (),_dbeb );_adf .SetFont (_dbeb .Font );_adf .SetFontSize (_dbeb .FontSize );_dgf ._abd =_adf ;return _dgf ;};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_abea *Ellipse )SetFillOpacity (opacity float64 ){_abea ._facc =opacity };

// SetFillColor sets the fill color.
func (_gdfg *CurvePolygon )SetFillColor (color Color ){_gdfg ._ddbg =color ;_gdfg ._dbag .FillColor =_gdfa (color );};func _edd (_dfgc ,_dcce ,_ddf ,_ggb float64 )*border {_abe :=&border {};_abe ._acb =_dfgc ;_abe ._edb =_dcce ;_abe ._dgga =_ddf ;_abe ._fbce =_ggb ;
_abe ._dcd =ColorBlack ;_abe ._ada =ColorBlack ;_abe ._bgfg =ColorBlack ;_abe ._fdaa =ColorBlack ;_abe ._ead =0;_abe ._bbdf =0;_abe ._feg =0;_abe ._gea =0;_abe .LineStyle =_ce .LineStyleSolid ;return _abe ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_edeb []_ce .CubicBezierCurve ;FillEnabled bool ;_dagdb Color ;BorderEnabled bool ;BorderWidth float64 ;_baed Color ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_eec *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cged :=ctx ;if _eec ._bcgd .IsRelative (){ctx .X +=_eec ._dee .Left ;ctx .Y +=_eec ._dee .Top ;ctx .Width -=_eec ._dee .Left +_eec ._dee .Right ;ctx .Height -=_eec ._dee .Top ;
};_dfb ,_eea ,_gbgg :=_eec ._abd .GeneratePageBlocks (ctx );if _gbgg !=nil {return _dfb ,ctx ,_gbgg ;};ctx =_eea ;_gdeg :=ctx .X ;_cbdb :=ctx .Y -_eec ._abd .Height ();_ecc :=int64 (ctx .Page );_fbe :=_eec .headingNumber ();_fgeg :=_eec .headingText ();
if _eec ._abee {_ega :=_eec ._gdaf .Add (_fbe ,_eec ._ebfe ,_a .FormatInt (_ecc ,10),_eec ._feed );if _eec ._gdaf ._cfgge {_ega .SetLink (_ecc ,_gdeg ,_cbdb );};};if _eec ._efcd ==nil {_eec ._efcd =_fa .NewOutlineItem (_fgeg ,_fa .NewOutlineDest (_ecc -1,_gdeg ,_cbdb ));
if _eec ._eda !=nil {_eec ._eda ._efcd .Add (_eec ._efcd );}else {_eec ._eaa .Add (_eec ._efcd );};}else {_cbcg :=&_eec ._efcd .Dest ;_cbcg .Page =_ecc -1;_cbcg .X =_gdeg ;_cbcg .Y =_cbdb ;};for _ ,_bcbb :=range _eec ._cdde {_efba ,_eege ,_adeec :=_bcbb .GeneratePageBlocks (ctx );
if _adeec !=nil {return _dfb ,ctx ,_adeec ;};if len (_efba )< 1{continue ;};_dfb [len (_dfb )-1].mergeBlocks (_efba [0]);_dfb =append (_dfb ,_efba [1:]...);ctx =_eege ;};if _eec ._bcgd .IsRelative (){ctx .X =_cged .X ;};if _eec ._bcgd .IsAbsolute (){return _dfb ,_cged ,nil ;
};return _dfb ,ctx ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_ffbf *List )Indent ()float64 {return _ffbf ._dcdc };

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_cbcgb *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_cbcgb ._bacfa .Left =left ;_cbcgb ._bacfa .Right =right ;_cbcgb ._bacfa .Top =top ;_cbcgb ._bacfa .Bottom =bottom ;};func (_fbcc *templateProcessor )parseLinkAttr (_aadae ,_bbfad string )*_fa .PdfAnnotation {_bbfad =_dc .TrimSpace (_bbfad );
if _dc .HasPrefix (_bbfad ,"\u0075\u0072\u006c(\u0027")&&_dc .HasSuffix (_bbfad ,"\u0027\u0029")&&len (_bbfad )> 7{return _daffb (_bbfad [5:len (_bbfad )-2]);};if _dc .HasPrefix (_bbfad ,"\u0070\u0061\u0067e\u0028")&&_dc .HasSuffix (_bbfad ,"\u0029")&&len (_bbfad )> 6{var (_fadc error ;
_ecdf int64 ;_dbef float64 ;_fdade float64 ;_gbdba =1.0;_ffgbg =_dc .Split (_bbfad [5:len (_bbfad )-1],"\u002c"););_ecdf ,_fadc =_a .ParseInt (_dc .TrimSpace (_ffgbg [0]),10,64);if _fadc !=nil {_eef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fadc );
return nil ;};if len (_ffgbg )>=2{_dbef ,_fadc =_a .ParseFloat (_dc .TrimSpace (_ffgbg [1]),64);if _fadc !=nil {_eef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fadc );
return nil ;};};if len (_ffgbg )>=3{_fdade ,_fadc =_a .ParseFloat (_dc .TrimSpace (_ffgbg [2]),64);if _fadc !=nil {_eef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fadc );
return nil ;};};if len (_ffgbg )>=4{_gbdba ,_fadc =_a .ParseFloat (_dc .TrimSpace (_ffgbg [3]),64);if _fadc !=nil {_eef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fadc );
return nil ;};};return _ccbeg (_ecdf -1,_dbef ,_fdade ,_gbdba );};return nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_agcge *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_eedfc :=NewTextChunk (text ,_agcge ._ggee );_eedfc ._gbgga =_daffb (url );return _agcge .appendChunk (_eedfc );};

// SetLineHeight sets the line height (1.0 default).
func (_febdd *Paragraph )SetLineHeight (lineheight float64 ){_febdd ._ecegc =lineheight };

// SetSubtotal sets the subtotal of the invoice.
func (_dagg *Invoice )SetSubtotal (value string ){_dagg ._aeggf [1].Value =value };

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_faeb *Ellipse )ScaleToHeight (h float64 ){_ffbb :=_faeb ._bgea /_faeb ._dceb ;_faeb ._dceb =h ;_faeb ._bgea =h *_ffbb ;};

// SetMargins sets the margins TOC line.
func (_adgbc *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_adgbc ._fdbdf =left ;_cffgg :=&_adgbc ._bagf ._faaba ;_cffgg .Left =_adgbc ._fdbdf +float64 (_adgbc ._dabge -1)*_adgbc ._ddccb ;_cffgg .Right =right ;_cffgg .Top =top ;_cffgg .Bottom =bottom ;
};

// Height returns Image's document height.
func (_eba *Image )Height ()float64 {return _eba ._ffab };func _cdaaa (_fece ...interface{})(map[string ]interface{},error ){_fddd :=len (_fece );if _fddd %2!=0{_eef .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_fddd );
return nil ,_ea .ErrRangeError ;};_ecgcb :=map[string ]interface{}{};for _gfbbe :=0;_gfbbe < _fddd ;_gfbbe +=2{_fdfdg ,_fefab :=_fece [_gfbbe ].(string );if !_fefab {_eef .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_fece [_gfbbe ]);
return nil ,_ea .ErrTypeError ;};_ecgcb [_fdfdg ]=_fece [_gfbbe +1];};return _ecgcb ,nil ;};

// SetBorderColor sets the cell's border color.
func (_dcbbc *TableCell )SetBorderColor (col Color ){_dcbbc ._cgce =col ;_dcbbc ._cfaea =col ;_dcbbc ._egddb =col ;_dcbbc ._bbcfdd =col ;};func _ecgd (_abca string )(*GraphicSVG ,error ){_ceea ,_gcedg :=_ga .ParseFromString (_abca );if _gcedg !=nil {return nil ,_gcedg ;
};return _dbcb (_ceea );};

// SetFillColor sets the fill color for the path.
func (_geedb *FilledCurve )SetFillColor (color Color ){_geedb ._dagdb =color };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_fcdc *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcdc ._gbba .Left ,_fcdc ._gbba .Right ,_fcdc ._gbba .Top ,_fcdc ._gbba .Bottom ;};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_deab *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _cfce (x ,y ,width ,height );};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_gagc *TOC )SetLineTitleStyle (style TextStyle ){_gagc ._agde =style };

// SetBorderRadius sets the radius of the background corners.
func (_be *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_be .BorderRadiusTopLeft =topLeft ;_be .BorderRadiusTopRight =topRight ;_be .BorderRadiusBottomLeft =bottomLeft ;_be .BorderRadiusBottomRight =bottomRight ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_gecf *Ellipse )Positioning ()Positioning {return _gecf ._dada };

// SetBorderColor sets border color of the rectangle.
func (_gafg *Rectangle )SetBorderColor (col Color ){_gafg ._bada =col };

// FillColor returns the fill color of the rectangle.
func (_eaec *Rectangle )FillColor ()Color {return _eaec ._abbg };

// SetBorderColor sets the border color of the ellipse.
func (_bedd *Ellipse )SetBorderColor (col Color ){_bedd ._edcd =col };func _gdaaa (_fgge *templateProcessor ,_dgbe *templateNode )(interface{},error ){return _fgge .parseImage (_dgbe );};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);
ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetStyleRight sets border style for right side.
func (_gcc *border )SetStyleRight (style CellBorderStyle ){_gcc ._adg =style };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_cgecf *_ce .Polygon ;_bege float64 ;_dgcea float64 ;_beba Color ;};

// NewFilledCurve returns a instance of filled curve.
func (_gaeg *Creator )NewFilledCurve ()*FilledCurve {return _eecf ()};